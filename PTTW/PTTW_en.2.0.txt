 /* Build Time: Oct 1, 2014 12:39:13 */ /*yepnope1.5.x|WTFPL*/
// yepnope.js
// Version - 1.5.4pre
//
// by
// Alex Sexton - @SlexAxton - AlexSexton[at]gmail.com
// Ralph Holzmann - @ralphholzmann - ralphholzmann[at]gmail.com
//
// http://yepnopejs.com/
// https://github.com/SlexAxton/yepnope.js/
//
// Tri-license - WTFPL | MIT | BSD
//
// Please minify before use.
// Also available as Modernizr.load via the Modernizr Project
//
( function ( window, doc, undef ) {

var docElement            = doc.documentElement,
    sTimeout              = window.setTimeout,
    firstScript           = doc.getElementsByTagName( "script" )[ 0 ],
    toString              = {}.toString,
    execStack             = [],
    started               = 0,
    noop                  = function () {},
    // Before you get mad about browser sniffs, please read:
    // https://github.com/Modernizr/Modernizr/wiki/Undetectables
    // If you have a better solution, we are actively looking to solve the problem
    isGecko               = ( "MozAppearance" in docElement.style ),
    isGeckoLTE18          = isGecko && !! doc.createRange().compareNode,
    insBeforeObj          = isGeckoLTE18 ? docElement : firstScript.parentNode,
    // Thanks to @jdalton for showing us this opera detection (by way of @kangax) (and probably @miketaylr too, or whatever...)
    isOpera               = window.opera && toString.call( window.opera ) == "[object Opera]",
    isIE                  = !! doc.attachEvent && !isOpera,
    strJsElem             = isGecko ? "object" : isIE  ? "script" : "img",
    strCssElem            = isIE ? "script" : strJsElem,
    isArray               = Array.isArray || function ( obj ) {
      return toString.call( obj ) == "[object Array]";
    },
    isObject              = function ( obj ) {
      return Object(obj) === obj;
    },
    isString              = function ( s ) {
      return typeof s == "string";
    },
    isFunction            = function ( fn ) {
      return toString.call( fn ) == "[object Function]";
    },
    globalFilters         = [],
    scriptCache           = {},
    prefixes              = {
      // key value pair timeout options
      timeout : function( resourceObj, prefix_parts ) {
        if ( prefix_parts.length ) {
          resourceObj['timeout'] = prefix_parts[ 0 ];
        }
        return resourceObj;
      }
    },
    handler,
    yepnope;

  /* Loader helper functions */
  function isFileReady ( readyState ) {
    // Check to see if any of the ways a file can be ready are available as properties on the file's element
    return ( ! readyState || readyState == "loaded" || readyState == "complete" || readyState == "uninitialized" );
  }


  // Takes a preloaded js obj (changes in different browsers) and injects it into the head
  // in the appropriate order
  function injectJs ( src, cb, attrs, timeout, /* internal use */ err, internal ) {
    var script = doc.createElement( "script" ),
        done, i;

    timeout = timeout || yepnope['errorTimeout'];

    script.src = src;

    // Add our extra attributes to the script element
    for ( i in attrs ) {
        script.setAttribute( i, attrs[ i ] );
    }

    cb = internal ? executeStack : ( cb || noop );

    // Bind to load events
    script.onreadystatechange = script.onload = function () {

      if ( ! done && isFileReady( script.readyState ) ) {

        // Set done to prevent this function from being called twice.
        done = 1;
        cb();

        // Handle memory leak in IE
        script.onload = script.onreadystatechange = null;
      }
    };

    // 404 Fallback
    sTimeout(function () {
      if ( ! done ) {
        done = 1;
        // Might as well pass in an error-state if we fire the 404 fallback
        cb(1);
      }
    }, timeout );

    // Inject script into to document
    // or immediately callback if we know there
    // was previously a timeout error
    err ? script.onload() : firstScript.parentNode.insertBefore( script, firstScript );
  }

  // Takes a preloaded css obj (changes in different browsers) and injects it into the head
  function injectCss ( href, cb, attrs, timeout, /* Internal use */ err, internal ) {

    // Create stylesheet link
    var link = doc.createElement( "link" ),
        done, i;

    timeout = timeout || yepnope['errorTimeout'];

    cb = internal ? executeStack : ( cb || noop );

    // Add attributes
    link.href = href;
    link.rel  = "stylesheet";
    link.type = "text/css";

    // Add our extra attributes to the link element
    for ( i in attrs ) {
      link.setAttribute( i, attrs[ i ] );
    }

    if ( ! err ) {
      firstScript.parentNode.insertBefore( link, firstScript );
      sTimeout(cb, 0);
    }
  }

  function executeStack ( ) {
    // shift an element off of the stack
    var i   = execStack.shift();
    started = 1;

    // if a is truthy and the first item in the stack has an src
    if ( i ) {
      // if it's a script, inject it into the head with no type attribute
      if ( i['t'] ) {
        // Inject after a timeout so FF has time to be a jerk about it and
        // not double load (ignore the cache)
        sTimeout( function () {
          (i['t'] == "c" ?  yepnope['injectCss'] : yepnope['injectJs'])( i['s'], 0, i['a'], i['x'], i['e'], 1 );
        }, 0 );
      }
      // Otherwise, just call the function and potentially run the stack
      else {
        i();
        executeStack();
      }
    }
    else {
      // just reset out of recursive mode
      started = 0;
    }
  }

  function preloadFile ( elem, url, type, splicePoint, dontExec, attrObj, timeout ) {

    timeout = timeout || yepnope['errorTimeout'];

    // Create appropriate element for browser and type
    var preloadElem = doc.createElement( elem ),
        done        = 0,
        firstFlag   = 0,
        stackObject = {
          "t": type,     // type
          "s": url,      // src
        //r: 0,        // ready
          "e": dontExec,// set to true if we don't want to reinject
          "a": attrObj,
          "x": timeout
        };

    // The first time (common-case)
    if ( scriptCache[ url ] === 1 ) {
      firstFlag = 1;
      scriptCache[ url ] = [];
    }

    function onload ( first ) {
      // If the script/css file is loaded
      if ( ! done && isFileReady( preloadElem.readyState ) ) {

        // Set done to prevent this function from being called twice.
        stackObject['r'] = done = 1;

        ! started && executeStack();

        // Handle memory leak in IE
        preloadElem.onload = preloadElem.onreadystatechange = null;
        if ( first ) {
          if ( elem != "img" ) {
            sTimeout(function(){ insBeforeObj.removeChild( preloadElem ) }, 50);
          }

          for ( var i in scriptCache[ url ] ) {
            if ( scriptCache[ url ].hasOwnProperty( i ) ) {
              scriptCache[ url ][ i ].onload();
            }
          }
        }
      }
    }


    // Setting url to data for objects or src for img/scripts
    if ( elem == "object" ) {
      preloadElem.data = url;
    } else {
      preloadElem.src = url;

      // Setting bogus script type to allow the script to be cached
      preloadElem.type = elem;
    }

    // Don't let it show up visually
    preloadElem.width = preloadElem.height = "0";

    // Attach handlers for all browsers
    preloadElem.onerror = preloadElem.onload = preloadElem.onreadystatechange = function(){
      onload.call(this, firstFlag);
    };
    // inject the element into the stack depending on if it's
    // in the middle of other scripts or not
    execStack.splice( splicePoint, 0, stackObject );

    // The only place these can't go is in the <head> element, since objects won't load in there
    // so we have two options - insert before the head element (which is hard to assume) - or
    // insertBefore technically takes null/undefined as a second param and it will insert the element into
    // the parent last. We try the head, and it automatically falls back to undefined.
    if ( elem != "img" ) {
      // If it's the first time, or we've already loaded it all the way through
      if ( firstFlag || scriptCache[ url ] === 2 ) {
        insBeforeObj.insertBefore( preloadElem, isGeckoLTE18 ? null : firstScript );

        // If something fails, and onerror doesn't fire,
        // continue after a timeout.
        sTimeout( onload, timeout );
      }
      else {
        // instead of injecting, just hold on to it
        scriptCache[ url ].push( preloadElem );
      }
    }
  }

  function load ( resource, type, dontExec, attrObj, timeout ) {
    // If this method gets hit multiple times, we should flag
    // that the execution of other threads should halt.
    started = 0;

    // We'll do 'j' for js and 'c' for css, yay for unreadable minification tactics
    type = type || "j";
    if ( isString( resource ) ) {
      // if the resource passed in here is a string, preload the file
      preloadFile( type == "c" ? strCssElem : strJsElem, resource, type, this['i']++, dontExec, attrObj, timeout );
    } else {
      // Otherwise it's a callback function and we can splice it into the stack to run
      execStack.splice( this['i']++, 0, resource );
      execStack.length == 1 && executeStack();
    }

    // OMG is this jQueries? For chaining...
    return this;
  }

  // return the yepnope object with a fresh loader attached
  function getYepnope () {
    var y = yepnope;
    y['loader'] = {
      "load": load,
      "i" : 0
    };
    return y;
  }

  /* End loader helper functions */
  // Yepnope Function
  yepnope = function ( needs ) {

    var i,
        need,
        // start the chain as a plain instance
        chain = this['yepnope']['loader'];

    function satisfyPrefixes ( url ) {
      // split all prefixes out
      var parts   = url.split( "!" ),
      gLen    = globalFilters.length,
      origUrl = parts.pop(),
      pLen    = parts.length,
      res     = {
        "url"      : origUrl,
        // keep this one static for callback variable consistency
        "origUrl"  : origUrl,
        "prefixes" : parts
      },
      mFunc,
      j,
      prefix_parts;

      // loop through prefixes
      // if there are none, this automatically gets skipped
      for ( j = 0; j < pLen; j++ ) {
        prefix_parts = parts[ j ].split( '=' );
        mFunc = prefixes[ prefix_parts.shift() ];
        if ( mFunc ) {
          res = mFunc( res, prefix_parts );
        }
      }

      // Go through our global filters
      for ( j = 0; j < gLen; j++ ) {
        res = globalFilters[ j ]( res );
      }

      // return the final url
      return res;
    }

    function getExtension ( url ) {
        return url.split(".").pop().split("?").shift();
    }

    function loadScriptOrStyle ( input, callback, chain, index, testResult ) {
      // run through our set of prefixes
      var resource     = satisfyPrefixes( input ),
          autoCallback = resource['autoCallback'],
          extension    = getExtension( resource['url'] );

      // if no object is returned or the url is empty/0 just exit the load
      if ( resource['bypass'] ) {
        return;
      }

      // Determine callback, if any
      if ( callback ) {
        callback = isFunction( callback ) ?
          callback :
          callback[ input ] ||
          callback[ index ] ||
          callback[ ( input.split( "/" ).pop().split( "?" )[ 0 ] ) ];
      }

      // if someone is overriding all normal functionality
      if ( resource['instead'] ) {
        return resource['instead']( input, callback, chain, index, testResult );
      }
      else {
        // Handle if we've already had this url and it's completed loaded already
        if ( scriptCache[ resource['url'] ] ) {
          // don't let this execute again
          resource['noexec'] = true;
        }
        else {
          scriptCache[ resource['url'] ] = 1;
        }

        // Throw this into the queue
        chain.load( resource['url'], ( ( resource['forceCSS'] || ( ! resource['forceJS'] && "css" == getExtension( resource['url'] ) ) ) ) ? "c" : undef, resource['noexec'], resource['attrs'], resource['timeout'] );

        // If we have a callback, we'll start the chain over
        if ( isFunction( callback ) || isFunction( autoCallback ) ) {
          // Call getJS with our current stack of things
          chain['load']( function () {
            // Hijack yepnope and restart index counter
            getYepnope();
            // Call our callbacks with this set of data
            callback && callback( resource['origUrl'], testResult, index );
            autoCallback && autoCallback( resource['origUrl'], testResult, index );

            // Override this to just a boolean positive
            scriptCache[ resource['url'] ] = 2;
          } );
        }
      }
    }

    function loadFromTestObject ( testObject, chain ) {
        var testResult = !! testObject['test'],
            group      = testResult ? testObject['yep'] : testObject['nope'],
            always     = testObject['load'] || testObject['both'],
            callback   = testObject['callback'] || noop,
            cbRef      = callback,
            complete   = testObject['complete'] || noop,
            needGroupSize,
            callbackKey;

        // Reusable function for dealing with the different input types
        // NOTE:: relies on closures to keep 'chain' up to date, a bit confusing, but
        // much smaller than the functional equivalent in this case.
        function handleGroup ( needGroup, moreToCome ) {
          if ( ! needGroup ) {
            // Call the complete callback when there's nothing to load.
            ! moreToCome && complete();
          }
          // If it's a string
          else if ( isString( needGroup ) ) {
            // if it's a string, it's the last
            if ( !moreToCome ) {
              // Add in the complete callback to go at the end
              callback = function () {
                var args = [].slice.call( arguments );
                cbRef.apply( this, args );
                complete();
              };
            }
            // Just load the script of style
            loadScriptOrStyle( needGroup, callback, chain, 0, testResult );
          }
          // See if we have an object. Doesn't matter if it's an array or a key/val hash
          // Note:: order cannot be guaranteed on an key value object with multiple elements
          // since the for-in does not preserve order. Arrays _should_ go in order though.
          else if ( isObject( needGroup ) ) {
            // I hate this, but idk another way for objects.
            needGroupSize = (function(){
              var count = 0, i
              for (i in needGroup ) {
                if ( needGroup.hasOwnProperty( i ) ) {
                  count++;
                }
              }
              return count;
            })();

            for ( callbackKey in needGroup ) {
              // Safari 2 does not have hasOwnProperty, but not worth the bytes for a shim
              // patch if needed. Kangax has a nice shim for it. Or just remove the check
              // and promise not to extend the object prototype.
              if ( needGroup.hasOwnProperty( callbackKey ) ) {
                // Find the last added resource, and append to it's callback.
                if ( ! moreToCome && ! ( --needGroupSize ) ) {
                  // If this is an object full of callbacks
                  if ( ! isFunction( callback ) ) {
                    // Add in the complete callback to go at the end
                    callback[ callbackKey ] = (function( innerCb ) {
                      return function () {
                        var args = [].slice.call( arguments );
                        innerCb && innerCb.apply( this, args );
                        complete();
                      };
                    })( cbRef[ callbackKey ] );
                  }
                  // If this is just a single callback
                  else {
                    callback = function () {
                      var args = [].slice.call( arguments );
                      cbRef.apply( this, args );
                      complete();
                    };
                  }
                }
                loadScriptOrStyle( needGroup[ callbackKey ], callback, chain, callbackKey, testResult );
              }
            }
          }
        }

        // figure out what this group should do
        handleGroup( group, !!always );

        // Run our loader on the load/both group too
        // the always stuff always loads second.
        always && handleGroup( always );
    }

    // Someone just decides to load a single script or css file as a string
    if ( isString( needs ) ) {
      loadScriptOrStyle( needs, 0, chain, 0 );
    }
    // Normal case is likely an array of different types of loading options
    else if ( isArray( needs ) ) {
      // go through the list of needs
      for( i = 0; i < needs.length; i++ ) {
        need = needs[ i ];

        // if it's a string, just load it
        if ( isString( need ) ) {
          loadScriptOrStyle( need, 0, chain, 0 );
        }
        // if it's an array, call our function recursively
        else if ( isArray( need ) ) {
          yepnope( need );
        }
        // if it's an object, use our modernizr logic to win
        else if ( isObject( need ) ) {
          loadFromTestObject( need, chain );
        }
      }
    }
    // Allow a single object to be passed in
    else if ( isObject( needs ) ) {
      loadFromTestObject( needs, chain );
    }
  };

  // This publicly exposed function is for allowing
  // you to add functionality based on prefixes on the
  // string files you add. 'css!' is a builtin prefix
  //
  // The arguments are the prefix (not including the !) as a string
  // and
  // A callback function. This function is passed a resource object
  // that can be manipulated and then returned. (like middleware. har.)
  //
  // Examples of this can be seen in the officially supported ie prefix
  yepnope['addPrefix'] = function ( prefix, callback ) {
    prefixes[ prefix ] = callback;
  };

  // A filter is a global function that every resource
  // object that passes through yepnope will see. You can
  // of course conditionally choose to modify the resource objects
  // or just pass them along. The filter function takes the resource
  // object and is expected to return one.
  //
  // The best example of a filter is the 'autoprotocol' officially
  // supported filter
  yepnope['addFilter'] = function ( filter ) {
    globalFilters.push( filter );
  };

  // Default error timeout to 10sec - modify to alter
  yepnope['errorTimeout'] = 1e4;

  // Webreflection readystate hack
  // safe for jQuery 1.4+ ( i.e. don't use yepnope with jQuery 1.3.2 )
  // if the readyState is null and we have a listener
  if ( doc.readyState == null && doc.addEventListener ) {
    // set the ready state to loading
    doc.readyState = "loading";
    // call the listener
    doc.addEventListener( "DOMContentLoaded", handler = function () {
      // Remove the listener
      doc.removeEventListener( "DOMContentLoaded", handler, 0 );
      // Set it to ready
      doc.readyState = "complete";
    }, 0 );
  }

  // Attach loader &
  // Leak it
  window['yepnope'] = getYepnope();

  // Exposing executeStack to better facilitate plugins
  window['yepnope']['executeStack'] = executeStack;
  window['yepnope']['injectJs'] = injectJs;
  window['yepnope']['injectCss'] = injectCss;

})( this, document );
var dependOnGoogleMaps = true;/*
arcgislink.js (http://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/)

arcgislink.js is modified to decrease the number of digitals after the decimal point. Now the 
latitude and longitude only have six digitals after the decimal point. The length of URL is decreased 
to make sure when buffer circle is combined with other conditions, the application is still working. 

Aug 23, 2013: arcgislink.js is modified to get ride the dependency on google maps by adding a global variable
dependOnGoogleMaps. If this is true, Google Maps will be initialized. Otherwise, this is purely used to generate report. 
*/

/*
arcgislink.js (http://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/)

arcgislink.js is modified to decrease the number of digitals after the decimal point. Now the 
latitude and longitude only have six digitals after the decimal point. The length of URL is decreased 
to make sure when buffer circle is combined with other conditions, the application is still working. 

Aug 23, 2013: arcgislink.js is modified to get ride the dependency on google maps by adding a global variable
dependOnGoogleMaps. If this is true, Google Maps will be initialized. Otherwise, this is purely used to generate report. 
*/

if(typeof(dependOnGoogleMaps) === 'undefined') {
	dependOnGoogleMaps = true;
}
(function(){  
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 */
/**
 * @preserve http://google-maps-utility-library-v3.googlecode.com
 */
/**
 * @name ArcGIS Server Link for Google Maps JavaScript API V3
 * @version 1.0
 * @author: Nianwei Liu (nianwei at gmail dot com)
 * @fileoverview 
 *  <p><a href="examples.html">Examples</a>
 *   </p> 
 *  <p>This library lets you add map resources accessible via 
 *    <a href = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/index.html'> 
 *    ESRI ArcGIS Server&#0153; REST API</a> into <a 
 *    href='http://code.google.com/apis/maps/documentation/javascript/'>
 *    Google Maps API V3</a> and provide some additional support for map tiles created 
 *    with different spatial reference and tiling scheme.</p>
 *    </p>.
 *    <table>
 *    <tr>
 *    <td style = 'width:200px'>
 *    {@link TileLayer}<br/>
 *    {@link TileLayerOptions}<br/>
 *    {@link MapType}<br/>
 *    {@link MapTypeOptions}<br/>
 *    {@link MapOverlay}<br/>
 *    {@link MapOverlayOptions}<br/>
 *    {@link Projection}<br/>
 *    </td>
 *    <td style = 'width:200px'>
 *    {@link Catalog}<br/>
 *    {@link MapService}<br/></b>
 *    {@link Layer}<br/>
 *    {@link GeocodeService}<br/>
 *    {@link GeometryService}<br/>
 *    {@link GPService}<br/>
 *    {@link GPTask}<br/>
 *    {@link RouteTask}<br/>
 *     <br/></td>
 *     <td style = 'width:200px'>
 *    {@link SpatialReference}<br/>
 *    {@link Geographic}<br/>
 *    {@link LambertConformalConic}<br/>
 *    {@link TransverseMercator}<br/>
 *    {@link SphereMercator}<br/>
 *    {@link Albers}<br/>
 *    {@link SpatialRelationship}<br/>
 *     </td>
 *     <td style = 'width:200px'>
 *    {@link Util} <br/> 
 *    {@link Config} <br/> 
 *    {@link Error} <br/> 
 *     </td>
 *    </tr></table>
 *    <p> There are many objects used in the REST API that do not require 
 *    a constructor and can be
 *    used just as object literal in the operation:</p>
 *    <table><tr>
 *    <td style = 'width:200px'>
 *    {@link Field}<br/>
 *    {@link TileInfo}<br/>
 *    {@link LOD}<br/>
 *    {@link ExportMapOptions}<br/>
 *    {@link MapImage}<br/>
 *    {@link IdentifyOptions}<br/>
 *    {@link IdentifyResults}<br/>
 *    {@link IdentifyResult}<br/>
 *     <br/></td>
 *     <td style = 'width:200px'>
 *    {@link QueryOptions}<br/>
 *    {@link ResultSet}<br/>
 *    {@link FindOptions}<br/>
 *    {@link FindResults}<br/>
 *    {@link FindResult}<br/>
 *    {@link Feature}<br/>
 *     </td>
 *     <td style = 'width:200px'>
 *    {@link GeocodeOptions}<br/>
 *    {@link GeocodeResults}<br/>
 *    {@link GeocodeResult}<br/>
 *    {@link ReverseGeocodeOptions}<br/>
 *    {@link ReverseGeocodeResult}<br/>
 *    {@link BufferOptions}<br/>
 *    {@link BufferResults}<br/> 
 *    {@link ProjectOptions}<br/>
 *    {@link ProjectResults}<br/> 
 *    </td>
 *     <td style = 'width:200px'>
 *    {@link RouteOptions}<br/>
 *    {@link RouteResults}<br/>  
 *    </td>
 *    </tr></table>
 */
  
  /*jslint evil: true, sub: true */ 
  /*global escape ActiveXObject */
var gmaps = gmaps || {};

/** @const */
var RAD_DEG = Math.PI / 180;
var jsonpID_ = 0;
window['ags_jsonp'] = window['ags_jsonp'] || {};

var G = {OverlayView: function () {},event: {trigger: function () {}}};
if (dependOnGoogleMaps) {
	G = google.maps; 
}
var WGS84, NAD83, WEB_MERCATOR, WEB_MERCATOR_AUX;

/**
 * @name Config
 * @class This is an object literal that sets common configuration values used across the lib.
 * @property {String} [proxyUrl] The URL to the web proxy page used in case the length of the URL request to an ArcGIS Server REST resource exceeds 2000 characters.
 * @property {Boolean} [alwaysUseProxy] whether to always use proxy page when send request to server.
 */
var Config = {
  proxyUrl:null,
  alwaysUseProxy: false
};

/**
 * an internal collection of Spatial Refeneces supported in the application.
 * The key of the collection is the wkid/wkt, and value is an instance of
 * {@link SpatialReference}.
 */
var spatialReferences_ = {};

/**
 * A set of utilities ((<code>Util</code>)
 * for commonly used functions.
 * @name Util
 * @namespace
 */
var Util = {};
/**
 * Extract the substring from full string, between start string and end string
 * @param {String} full
 * @param {String} start
 * @param {String} end
 */
function extractString_(full, start, end) {
  var i = (start === '') ? 0 : full.indexOf(start);
  var e = end === '' ? full.length : full.indexOf(end, i + start.length);
  return full.substring(i + start.length, e);
}

/**
 * Check if the object is String
 * @param {Object} o
 */
function isString_(o) {
  return o && typeof o === 'string';
}
  
  /**
   * Check if the object is array
   * @param {Object} o
   */
function isArray_(o) {
  return o && o.splice;
}
  
function isNumber_(o) {
  return typeof o === 'number';
}
 
   /**
   * Add the property of the source object to destination object 
   * if not already exists.
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} force
   * @return {Object}
   */
function augmentObject_(src, dest, force) {
    if (src && dest) {
      var p;
      for (p in src) {
        if (force || !(p in dest)) {
          dest[p] = src[p];
        }
      }
    }
    return dest;
}
  
/**
 * Wrapper around google.maps.event.trigger
 * @param {Object} src
 * @param {String} evtName
 * @param {Object} args
 */
function triggerEvent_(src, evtName, args) {
  G.event.trigger.apply(this, arguments);
}

/**
 * handle JSON error
 * @param {Object} errback
 * @param {Object} json
 */
function handleErr_(errback, json) {
  if (errback && json && json.error) {
    errback(json.error);
  }
}
/**
 * get REST format for 2 time
 * @param {Date} time
 * @param {Date} endTime
 */
function formatTimeString_(time, endTime) {
  var ret = '';
  if (time) {
    ret += (time.getTime() - time.getTimezoneOffset() * 60000);
  }
  if (endTime) {
    ret += ', ' + (endTime.getTime() - endTime.getTimezoneOffset() * 60000);
  }
  return ret;
}

/**
 * Set opacity of a node.
 * @param {Node} node
 * @param {Number} 0-1
 */
function setNodeOpacity_(node, op) {
  // closure compiler removed?
  op = Math.min(Math.max(op, 0), 1);
  if (node) {
    var st = node.style;
    if (typeof st.opacity !== 'undefined') {
      st.opacity = op;
    }
    if (typeof st.filters !== 'undefined') {
      st.filters.alpha.opacity = Math.floor(100 * op);
    }
    if (typeof st.filter !== 'undefined') {
      st.filter = "alpha(opacity:" + Math.floor(op * 100) + ")";
    }
  }
}
/**
 * get the layerdef text string from an object literal
 * @param {Object} defs
 */
function getLayerDefsString_(defs) {
  var strDefs = '';
  for (var x in defs) {
    if (defs.hasOwnProperty(x)) {
      if (strDefs.length > 0) {
        strDefs += ';';
      }
      strDefs += (x + ':' + defs[x]);
    }
  }
  return strDefs;
}

function getXmlHttp_() {
  if (typeof XMLHttpRequest === "undefined") {
    try {
      return new ActiveXObject("Msxml2.XMLHTTP.6.0");
    } catch (e) {
    }
    try {
      return new ActiveXObject("Msxml2.XMLHTTP.3.0");
    } catch (e1) {
    }
    try {
      return new ActiveXObject("Msxml2.XMLHTTP");
    } catch (e2) {
    }
    throw new Error("This browser does not support XMLHttpRequest.");
  } else {
    return new XMLHttpRequest();
  }
}

/**
 * @name GeometryType
 * @enum {String}
 * @const
 * @class List of Geometry type supported by ArcGIS server.
 * @property {String} [POINT] esriGeometryPoint
 * @property {String} [MULTIPOINT] esriGeometryMultipoint
 * @property {String} [POLYLINE] esriGeometryPolyline
 * @property {String} [POLYGON] esriGeometryPolygon
 * @property {String} [ENVELOPE] esriGeometryEnvelope
 */
var GeometryType = {
  POINT: 'esriGeometryPoint',
  MULTIPOINT: 'esriGeometryMultipoint',
  POLYLINE: 'esriGeometryPolyline',
  POLYGON: 'esriGeometryPolygon',
  ENVELOPE: 'esriGeometryEnvelope'
};

function getGeometryType_(obj) {
	//console.log(obj);
  var o = obj;
  if (isArray_(obj) && obj.length > 0) {
    o = obj[0];
  }
  if (o instanceof G.LatLng || o instanceof G.Marker) {
    if (isArray_(obj) && obj.length > 1) {
      return GeometryType.MULTIPOINT;
    } else {
      return GeometryType.POINT;
    }
  } else if (o instanceof G.Polyline) {
    return GeometryType.POLYLINE;
  } else if (o instanceof G.Polygon) {
    return GeometryType.POLYGON;
  } else if (o instanceof G.LatLngBounds) {
    return GeometryType.ENVELOPE;
  } else if (o.x !== undefined && o.y !== undefined) {
    return GeometryType.POINT;
  } else if (o.points) {
    return GeometryType.MULTIPOINT;
  } else if (o.paths) {
    return GeometryType.POLYLINE;
  } else if (o.rings) {
    return GeometryType.POLYGON;
  }
  return null;
}

/**
 * Is the object an Google Overlay?
 * @param {Object} obj
 * @return {Boolean}
 */
function isOverlay_(obj) {
  var o = obj;
  if (isArray_(obj) && obj.length > 0) {
    o = obj[0];
  }
  if (isArray_(o) && o.length > 0) {
    o = o[0];
  }
  if (o instanceof G.LatLng || o instanceof G.Marker ||
  o instanceof G.Polyline ||
  o instanceof G.Polygon ||
  o instanceof G.LatLngBounds) {
    return true;
  }
  return false;
}
  
function formatSRParam_(sr) {
  if (!sr) {
    return null;
  }
  // for 9.3 compatibility, return wkid if possible.
  return isNumber_(sr) ? sr : sr.wkid ? sr.wkid : sr.toJSON();
}

/**
 * @param {MVCArrayOfLatLng} pts
 */
function fromLatLngsToJSON_(pts, close) {
  var arr = [];
  var latlng;
  for (var i = 0, c = pts.getLength(); i < c; i++) {
    latlng = pts.getAt(i);
    arr.push('[' + latlng.lng().toFixed(6) + ',' + latlng.lat().toFixed(6) + ']');
  }
  if (close && arr.length > 0) {
    arr.push('[' + pts.getAt(0).lng().toFixed(6) + ',' + pts.getAt(0).lat().toFixed(6) + ']');
  }
  return arr.join(',');
}

/**
 * Convert overlays (Marker, Polyline, Polygons) to JSON string in AGS format.
 * @param {OverlayView|Array.OverlayView} geom
 */
function fromOverlaysToJSON_(geom) {
  var gtype = getGeometryType_(geom);
  var g, gs, i, pts;
  var json = '{';
  switch (gtype) {
  case GeometryType.POINT:
    g = isArray_(geom) ? geom[0] : geom;
    if (g instanceof G.Marker) {
      g = g.getPosition();
    }
    json += 'x:' + g.lng() + ',y:' + g.lat();
    break;
  case GeometryType.MULTIPOINT:
    pts = [];
    for (i = 0; i < geom.length; i++) {
      if (geom[i] instanceof G.Marker) {
        g = geom[i].getPosition();
      } else {
        g = geom[i];
      }
      pts.push('[' + g.lng() + ',' + g.lat() + ']');
    }
    json += 'points: [' + pts.join(',') + ']';
    break;
  case GeometryType.POLYLINE:
    // V3 does not support multiple paths yet
    pts = [];
    gs = isArray_(geom) ? geom : [geom];
    for (i = 0; i < gs.length; i++) {
      pts.push('[' + fromLatLngsToJSON_(gs[i].getPath()) + ']');
    }
    json += 'paths:[' + pts.join(',') + ']';
    break;
  case GeometryType.POLYGON:
    pts = [];
    g = isArray_(geom) ? geom[0] : geom;
    var paths = g.getPaths();
    for (i = 0; i < paths.getLength(); i++) {
      pts.push('[' + fromLatLngsToJSON_(paths.getAt(i), true) + ']');
    }
    json += 'rings:[' + pts.join(',') + ']';
    
    break;
  case GeometryType.ENVELOPE:
    g = isArray_(geom) ? geom[0] : geom;
    json += 'xmin:' + g.getSouthWest().lng() + ',ymin:' + g.getSouthWest().lat() + ',xmax:' + g.getNorthEast().lng() + ',ymax:' + g.getNorthEast().lat();
    break;
  }
  json += ', spatialReference:{wkid:4326}';
  json += '}';
  return json;
}
/**
 * From ESRI geometry format to JSON String, primarily used in Geometry service
 * @param {Object} geom
 */
function fromGeometryToJSON_(geom) {
  function fromPointsToJSON(pts) {
    var arr = [];
    for (var i = 0, c = pts.length; i < c; i++) {
      arr.push('[' + pts[i][0] + ',' + pts[i][1] + ']');
    }
    return '[' + arr.join(',') + ']';
  }
  function fromLinesToJSON(lines) {
    var arr = [];
    for (var i = 0, c = lines.length; i < c; i++) {
      arr.push(fromPointsToJSON(lines[i]));
    }
    return '[' + arr.join(',') + ']';
  }
  
  var json = '{';
  if (geom.x) {
    json += 'x:' + geom.x + ',y:' + geom.y;
  } else if (geom.xmin) {
    json += 'xmin:' + geom.xmin + ',ymin:' + geom.ymin + ',xmax:' + geom.xmax + ',ymax:' + geom.ymax;
  } else if (geom.points) {
    json += 'points:' + fromPointsToJSON(geom.points);
  } else if (geom.paths) {
    json += 'paths:' + fromLinesToJSON(geom.paths);
  } else if (geom.rings) {
    json += 'rings:' + fromLinesToJSON(geom.rings);
  }
  json += '}';
  return json;
}

/**
 * Helper method to convert an Envelope object to <code>google.maps.LatLngBounds</code>
 * @private
 * @param {Object} extent
 * @return {google.maps.LatLngBounds} gLatLngBounds
 */
function fromEnvelopeToLatLngBounds_(extent) {
  var sr = spatialReferences_[extent.spatialReference.wkid || extent.spatialReference.wkt];
  sr = sr || WGS84;
  var sw = sr.inverse([extent.xmin, extent.ymin]);
  var ne = sr.inverse([extent.xmax, extent.ymax]);
  return new G.LatLngBounds(new G.LatLng(sw[1], sw[0]), new G.LatLng(ne[1], ne[0]));
}

/**
 * Convert a ArcGIS Geometry JSON object to core Google Maps API
 * overlays such as  <code>google.maps.Marker</code>, <code>google.maps.Polyline</code> or <code>google.maps.Polygon</code>
 * Note ArcGIS Geometry may have multiple parts, but the coresponding OverlayView
 * may (Polygon) or may not (Polyline) support multi-parts, so the result is an array for consistency.
 * @param {Object} json geometry
 * @param {OverlayOptions} opts see {@link OverlayOptions}
 * @return {Array.OverlayView}
 */
function fromJSONToOverlays_(geom, opts) {
  var ovs = null;
  var ov;
  var i, ic, j, jc, parts, part, lnglat, latlngs;
  opts = opts || {};
  if (geom) {
    ovs = [];
    if (geom.x) {
      ov = new G.Marker(augmentObject_(opts.markerOptions || opts, {
        'position': new G.LatLng(geom.y, geom.x)
      }));
      ovs.push(ov);
    } else {
      //mulpt, line and poly
      parts = geom.points || geom.paths || geom.rings;
      if (!parts) {
        return ovs;
      }
      var rings = [];
      for (i = 0, ic = parts.length; i < ic; i++) {
        part = parts[i];
        if (geom.points) {
          // multipoint
          ov = new G.Marker(augmentObject_(opts.markerOptions || opts, {
            'position': new G.LatLng(part[1], part[0])
          }));
          ovs.push(ov);
        } else {
          latlngs = [];
          for (j = 0, jc = part.length; j < jc; j++) {
            lnglat = part[j];
            latlngs.push(new G.LatLng(lnglat[1], lnglat[0]));
          }
          if (geom.paths) {
            ov = new G.Polyline(augmentObject_(opts.polylineOptions || opts, {
              'path': latlngs
            }));
            ovs.push(ov);
          } else if (geom.rings) {
            // V3 supports multiple rings
            rings.push(latlngs);
          }
        }
      }
      if (geom.rings) {
        ov = new G.Polygon(augmentObject_(opts.polygonOptions || opts, {
          'paths': rings
        }));
        ovs.push(ov);
      }
    }
  }
  return ovs;
}
function parseFeatures_(features, ovOpts) {
  if (features) {
    var i, I, f;
    for (i = 0, I = features.length; i < I; i++) {
      f = features[i];
      if (f.geometry) {
        f.geometry = fromJSONToOverlays_(f.geometry, ovOpts);
      }
    }
  }
}

/**
 * get string as rest parameter
 * @param {Object} o
 */
function formatRequestString_(o) {
  var ret;
  if (typeof o === 'object') {
    if (isArray_(o)) {
      ret = [];
      for (var i = 0, I = o.length; i < I; i++) {
        ret.push(formatRequestString_(o[i]));
      }
      return '[' + ret.join(',') + ']';
    } else if (isOverlay_(o)) {
      return fromOverlaysToJSON_(o);
    } else if (o.toJSON) {
      return o.toJSON();
    } else {
      ret = '';
      for (var x in o) {
        if (o.hasOwnProperty(x)) {
          if (ret.length > 0) {
            ret += ', ';
          }
          ret += x + ':' + formatRequestString_(o[x]);
        }
      }
      return '{' + ret + '}';
    }
  }
  return o.toString();
}

function fromLatLngsToFeatureSet_(latlngs) {
  var i, I, latlng;
  var features = [];
  for (i = 0, I = latlngs.length; i < I; i++) {
    latlng = latlngs[i];
    if (latlng instanceof G.Marker) {
      latlng = latlng.getPosition();
    }
    features.push({
      'geometry': {
        'x': latlng.lng(),
        'y': latlng.lat(),
        'spatialReference': {
          'wkid': 4326
        }
      }
    });
  }
  return {
    'type': '"features"',
    'features': features,
    'doNotLocateOnRestrictedElements': false
  };
}

function prepareGeometryParams_(p) {
  var params = {};
  if (!p) {
    return null;
  }
  var json = [];
  var g, isOv;
  if (p.geometries && p.geometries.length > 0) {
    g = p.geometries[0];
    isOv = isOverlay_(g);
    for (var i = 0, c = p.geometries.length; i < c; i++) {
      if (isOv) {
        json.push(fromOverlaysToJSON_(p.geometries[i]));
      } else {
        json.push(fromGeometryToJSON_(p.geometries[i]));
      }
    }
  }
  if (!p.geometryType) {
    p.geometryType = getGeometryType_(g);
  }
  if (isOv) {
    params.inSR = WGS84.wkid;
  } else if (p.inSpatialReference) {
    params.inSR = formatSRParam_(p.inSpatialReference);
  }
  if (p.outSpatialReference) {
    params.outSR = formatSRParam_(p.outSpatialReference);
  }
  params.geometries = '{geometryType:"' + p.geometryType + '", geometries:[' + json.join(',') + ']}';
  return params;
}

function log_(msg) {
  if (window.console) {
    window.console.log(msg);
  } else {
    var l = document.getElementById('_ags_log');
    if (l) {
      l.innerHTML = l.innerHTML + msg + '<br/>';
    }
  }
}

/**
 * Format params to URL string
 * @param {Object} params
 */
function formatParams_(params) {
  var query = '';
  if (params) {
    params.f = params.f || 'json';
    for (var x in params) {
      if (params.hasOwnProperty(x) && params[x] !== null && params[x] !== undefined) { // wont sent undefined.
        //jslint complaint about escape cause NN does not support it.
        var val = formatRequestString_(params[x]); 
        query += (query.length > 0?'&':'')+(x + '=' + (escape ? escape(val) : encodeURIComponent(val)));
      }
    }
  }
  return query;
}

/** create a callback closure
 * @private
 * @param {Object} fn
 * @param {Object} obj
 */
function callback_(fn, obj) {
  var args = [];
  for (var i = 2, c = arguments.length; i < c; i++) {
    args.push(arguments[i]);
  }
  return function() {
    fn.apply(obj, args);
  };
}
function addCopyrightInfo_(cpArray, mapService, map) {
  if (mapService.hasLoaded()) {
    cpArray.push(mapService.copyrightText);
  } else {
    G.event.addListenerOnce(mapService, 'load', function() {
      setCopyrightInfo_(map);
    });
  }
}
/**
 * Find copyright control in the map
 * @param {Object} map
 */
function setCopyrightInfo_(map) {
  var div = null;
  if (map) {
    var mvc = map.controls[G.ControlPosition.BOTTOM_RIGHT];
    if (mvc) {
      for (var i = 0, c = mvc.getLength(); i < c; i++) {
        if (mvc.getAt(i).id === 'agsCopyrights') {
          div = mvc.getAt(i);
          break;
        }
      }
    }
    //var callback = callback_(setCopyrightInfo_, null, map);
    if (!div) {
      div = document.createElement('div');
      div.style.fontFamily = 'Arial,sans-serif';
      div.style.fontSize = '10px';
      div.style.textAlign = 'right';
      div.id = 'agsCopyrights';
      map.controls[G.ControlPosition.BOTTOM_RIGHT].push(div);
      G.event.addListener(map, 'maptypeid_changed', function() {
        setCopyrightInfo_(map);
      });
    }
    var ovs = map.agsOverlays;
    var cp = [];
    var svc, type;
    if (ovs) {
      for (var i = 0, c = ovs.getLength(); i < c; i++) {
        addCopyrightInfo_(cp, ovs.getAt(i).mapService_, map);
      }
    }
    var ovTypes = map.overlayMapTypes;
    if (ovTypes) {
      for (var i = 0, c = ovTypes.getLength(); i < c; i++) {
        type = ovTypes.getAt(i);
        if (type instanceof MapType) {
          for (var j = 0, cj = type.tileLayers_.length; j < cj; j++) {
            addCopyrightInfo_(cp, type.tileLayers_[j].mapService_, map);
          }
        }
      }
    }
    type = map.mapTypes.get(map.getMapTypeId());
    if (type instanceof MapType) {
      for (var i = 0, c = type.tileLayers_.length; i < c; i++) {
        addCopyrightInfo_(cp, type.tileLayers_[i].mapService_, map);
      }
      if (type.negative) {
        div.style.color = '#ffffff';
      } else {
        div.style.color = '#000000';
      }
    }
    div.innerHTML = cp.join('<br/>');
  }
}
function getJSON_(url, params, callbackName, callbackFn) {
  var sid = 'ags_jsonp_' + (jsonpID_++) + '_' + Math.floor(Math.random() * 1000000);
  var script = null;
  params = params || {};
 // AGS10.1 escapes && so had to take it off.
  params[callbackName || 'callback'] = 'ags_jsonp.' + sid;
  var query = formatParams_(params);
  var head = document.getElementsByTagName("head")[0];
  if (!head) {
    throw new Error("document must have header tag");
  }
  var jsonpcallback = function() {
    if (window['ags_jsonp'][sid]) {
      delete window['ags_jsonp'][sid]; //['ags_jsonp']
    }
    if (script) {
      head.removeChild(script);
    }
    script = null;
    callbackFn.apply(null, arguments);
    /**
     * This event is fired after a REST JSONP response was returned by server.
     * @name Util#jsonpend
     * @param {String} scriptID
     * @event
     */
    triggerEvent_(Util, 'jsonpend', sid);
  };
  window['ags_jsonp'][sid] = jsonpcallback;
  
  if ((query + url).length < 2000 && !Config.alwaysUseProxy) {
    script = document.createElement("script");
    script.src = url + (url.indexOf('?') === -1 ? '?' : '&') + query;
    script.id = sid;
    head.appendChild(script);
  } else {
    // check if same host
    var loc = window.location;
    var dom = loc.protocol + '//' + loc.hostname + (!loc.port || loc.port === 80 ? '' : ':' + loc.port + '/');
    var useProxy = true;
    if (url.toLowerCase().indexOf(dom.toLowerCase()) !== -1) {
      useProxy = false;
    }
    if (Config.alwaysUseProxy) {
      useProxy = true;
    }
    if (useProxy && !Config.proxyUrl) {
      throw new Error('No proxyUrl property in Config is defined');
    }
    var xmlhttp = getXmlHttp_();
    xmlhttp.onreadystatechange = function() {
      if (xmlhttp.readyState === 4) {
        if (xmlhttp.status === 200) {
          eval(xmlhttp.responseText);
        } else {
          throw new Error("Error code " + xmlhttp.status);
        }
      }
    };
    xmlhttp.open('POST', useProxy ? Config.proxyUrl + '?' + url : url, true);
    xmlhttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    xmlhttp.send(query);
  }
  /**
   * This event is fired before a REST request sent to server.
   * @name Util#jsonpstart
   * @param {String} scriptID
   * @event
   */
  triggerEvent_(Util, 'jsonpstart', sid);
  return sid;
}
  
/**
 * Make Cross Domain Calls. This function returns the
 * script ID which can be used to track the requests. parameters:
 * <ul>
 * <li>url: url of server resource
 * <li>params: an object with name,value pairs. value must be string
 * <li>callbackName: Callback parameter name the server is expecting.e.g:'callback'
 * <li>callbackFn: the actual callback function.
 * </ul>
 * @param {String} url
 * @param {Object} params
 * @param {String} callbackName
 * @param {Function} callbackFn
 * @return {String} scriptID
 */
Util.getJSON = function(url, params, callbackName, callbackFn) {
  getJSON_(url, params, callbackName, callbackFn);
};


/**
 * Add a list of overlays to map
 * @param {google.maps.Map} map
 * @param {Array.OverlayView} overlays
 */
Util.addToMap = function(map, overlays) {
  if (isArray_(overlays)) {
    var ov;
    for (var i = 0, I = overlays.length; i < I; i++) {
      ov = overlays[i];
      if (isArray_(ov)) {
        Util.addToMap(map, ov);
      } else if (isOverlay_(ov)) {
        ov.setMap(map);
      }
    }
  }
};
  /**
   * Add a list of overlays to map
   * @param {Array.OverlayView} overlays
   * @param {Boolean} clearArray
   */
Util.removeFromMap = function(overlays, clearArray) {
  Util.addToMap(null, overlays);
    if (clearArray) {
      overlays.length = 0;
    }
  };
  
  
/**
   * Create A Generic Spatial Reference Object
   * The <code>params </code> passed in constructor is a javascript object literal and depends on
   * the type of Coordinate System to construct.
   * @name SpatialReference
   * @class This  class (<code>SpatialReference</code>) is for coordinate systems that converts value
   * between geographic and real-world coordinates. The following classes extend this class:
   *    {@link Geographic}, {@link SphereMercator}, {@link LambertConformalConic}, and {@link TransverseMercator}.
   * @constructor
   * @property {Number} [wkid] well-known coodinate system id (EPSG code)
   * @property {String} [wkt] well-known coodinate system text
   * @param {Object} params
   */
  function SpatialReference(params) {
    params = params || {};
    this.wkid = params.wkid;
    this.wkt = params.wkt;
  }

  /**
   * Convert Lat Lng to real-world coordinates.
   * Note both input and output are array of [x,y], although their values in different units.
 * @param {Array.number} lnglat
 * @return {Array.number}
   */
SpatialReference.prototype.forward = function(lnglat) {
    return lnglat;
  };
  /**
   * Convert real-world coordinates  to Lat Lng.
   * Note both input and output are are array of [x,y], although their values are different.
 * @param {Array.number}  coords
 * @return {Array.number}
   */
SpatialReference.prototype.inverse = function(coords) {
    return coords;
  };
  /**
   * Get the map the periodicity in x-direction, in map units NOT pixels
 * @return {number} periodicity in x-direction
   */
SpatialReference.prototype.getCircum = function() {
    return 360;
  };
  /**
   * To JSON String
   * @return String
   */
SpatialReference.prototype.toJSON = function() {
    return '{' + (this.wkid ? ' wkid:' + this.wkid : 'wkt: \'' + this.wkt + '\'') + '}';
  };
  /**
   * Creates a Geographic Coordinate System. e.g.:<br/>
 * <code> var g2 = new Geographic({wkid:4326});
   * </code>
   * @name Geographic
   * @class This class (<code>Geographic</code>) will simply retuns same LatLng as Coordinates. 
   *   The <code>param</code> should have wkid property. Any Geographic Coordinate Systems (eg. WGS84(4326)) can 
   *   use this class As-Is. 
   *   <br/>Note:<b> This class does not support datum transformation</b>.
 * @constructor
   * @extends SpatialReference
   * @param {Object} params
   */
function Geographic (params) {
    params  = params || {};
  SpatialReference.call(this, params);
}

Geographic.prototype = new SpatialReference();

/**
 * Create a Lambert Conformal Conic Projection based Spatial Reference. The <code>params</code> passed in construction should
 * include the following properties:<code>
 * <br/>-wkid: well-known id
 * <br/>-semi_major:  ellipsoidal semi-major axis in meter
 * <br/>-unit: meters per unit
 * <br/>-inverse_flattening: inverse of flattening of the ellipsoid where 1/f  =  a/(a - b)
 * <br/>-standard_parallel_1: phi1, latitude of the first standard parallel
 * <br/>-standard_parallel_2: phi2, latitude of the second standard parallel
 * <br/>-latitude_of_origin: phi0, latitude of the false origin
 * <br/>-central_meridian: lamda0, longitude of the false origin  (with respect to the prime meridian)
 * <br/>-false_easting: FE, false easting, the Eastings value assigned to the natural origin
 * <br/>-false_northing: FN, false northing, the Northings value assigned to the natural origin
 * </code>
 * <br/> e.g. North Carolina State Plane NAD83 Feet: <br/>
 * <code> var ncsp82  = new LambertConformalConic({wkid:2264, semi_major: 6378137.0,inverse_flattening: 298.257222101,
 *   standard_parallel_1: 34.33333333333334, standard_parallel_2: 36.16666666666666,
 *   central_meridian: -79.0, latitude_of_origin: 33.75,false_easting: 2000000.002616666,
 *   'false_northing': 0, unit: 0.3048006096012192 }); </code>
 * @name LambertConformalConic
 * @class This class (<code>LambertConformalConic</code>) represents a Spatial Reference System based on <a target  = wiki href  = 'http://en.wikipedia.org/wiki/Lambert_conformal_conic_projection'>Lambert Conformal Conic Projection</a>. 
 * @extends SpatialReference
 * @constructor
 * @param {Object} params
 */
function LambertConformalConic(params) {
    //http://pubs.er.usgs.gov/djvu/PP/PP_1395.pdf
    //for NCSP83: GLatLng(35.102363,-80.5666)<  === > GPoint(1531463.95, 495879.744);
    params = params || {};
  SpatialReference.call(this, params);
    var f_i = params.inverse_flattening;
    var phi1 = params.standard_parallel_1 * RAD_DEG;
    var phi2 = params.standard_parallel_2 * RAD_DEG;
    var phi0 = params.latitude_of_origin * RAD_DEG;
    this.a_ = params.semi_major / params.unit;
    this.lamda0_ = params.central_meridian * RAD_DEG;
    this.FE_ = params.false_easting;
    this.FN_ = params.false_northing;
    
    var f = 1.0 / f_i; //e: eccentricity of the ellipsoid where e^2  =  2f - f^2 
    var es = 2 * f - f * f;
    this.e_ = Math.sqrt(es);
    var m1 = this.calc_m_(phi1, es);
    var m2 = this.calc_m_(phi2, es);
    var tF = this.calc_t_(phi0, this.e_);
    var t1 = this.calc_t_(phi1, this.e_);
    var t2 = this.calc_t_(phi2, this.e_);
    this.n_ = Math.log(m1 / m2) / Math.log(t1 / t2);
    this.F_ = m1 / (this.n_ * Math.pow(t1, this.n_));
    this.rho0_ = this.calc_rho_(this.a_, this.F_, tF, this.n_);
}
  
LambertConformalConic.prototype = new SpatialReference();
  /**
   * calc_m_
 * @param {number} phi
 * @param {number} es e square
   */
LambertConformalConic.prototype.calc_m_ = function(phi, es) {
    var sinphi = Math.sin(phi);
    return Math.cos(phi) / Math.sqrt(1 - es * sinphi * sinphi);
  };
  /**
   * calc_t_
   * @param {Object} phi
   * @param {Object} e
   */
LambertConformalConic.prototype.calc_t_ = function(phi, e) {
    var esp = e * Math.sin(phi);
    return Math.tan(Math.PI / 4 - phi / 2) / Math.pow((1 - esp) / (1 + esp), e / 2);
  };
  /**
   * calc_rho (15-7)_
   * @param {Object} a
   * @param {Object} F
   * @param {Object} t
   * @param {Object} n
   */
LambertConformalConic.prototype.calc_rho_ = function(a, F, t, n) {
    return a * F * Math.pow(t, n);
  };
  /**
   * calc_phi_
   * @param {Object} t_i
   * @param {Object} e
   * @param {Object} phi
   */
LambertConformalConic.prototype.calc_phi_ = function(t, e, phi) {
    var esp = e * Math.sin(phi);
    return Math.PI / 2 - 2 * Math.atan(t * Math.pow((1 - esp) / (1 + esp), e / 2));
  };
  /**
   * solve phi iteratively.
   * @param {Object} t_i
   * @param {Object} e
   * @param {Object} init
   */
LambertConformalConic.prototype.solve_phi_ = function(t_i, e, init) {
    // iteration
    var i = 0;
    var phi = init;
    var newphi = this.calc_phi_(t_i, e, phi);//this.
    while (Math.abs(newphi - phi) > 0.000000001 && i < 10) {
      i++;
      phi = newphi;
      newphi = this.calc_phi_(t_i, e, phi);//this.
    }
    return newphi;
  };
  /** 
   * see {@link SpatialReference}
 * @param {Array.number} lnglat
 * @return {Array.number}
   */
LambertConformalConic.prototype.forward = function(lnglat) {
    var phi = lnglat[1] * RAD_DEG;// (Math.PI / 180);
    var lamda = lnglat[0] * RAD_DEG;
    var t = this.calc_t_(phi, this.e_);
    var rho = this.calc_rho_(this.a_, this.F_, t, this.n_);
    var theta = this.n_ * (lamda - this.lamda0_);
    var E = this.FE_ + rho * Math.sin(theta);
    var N = this.FN_ + this.rho0_ - rho * Math.cos(theta);
    return [E, N];
  };
  /**
   * see {@link SpatialReference}
 * @param {Array.number}  coords
 * @return {Array.number}
   */
LambertConformalConic.prototype.inverse = function(coords) {
    var E = coords[0] - this.FE_;
    var N = coords[1] - this.FN_;
    var theta = Math.atan(E / (this.rho0_ - N));
    var rho = (this.n_ > 0 ? 1 : -1) * Math.sqrt(E * E + (this.rho0_ - N) * (this.rho0_ - N));
    var t = Math.pow((rho / (this.a_ * this.F_)), 1 / this.n_);
    var init = Math.PI / 2 - 2 * Math.atan(t);
    var phi = this.solve_phi_(t, this.e_, init);
    var lamda = theta / this.n_ + this.lamda0_;
    return [lamda / RAD_DEG, phi / RAD_DEG];
  };
  /**
   *  see {@link SpatialReference}
 *  @return {number}
   */
LambertConformalConic.prototype.getCircum = function() {
    return Math.PI * 2 * this.a_;
  };
		
/**
 * Create a Transverse Mercator Projection. The <code>params</code> passed in constructor should contain the 
 * following properties: <br/>
 * <code>
 * <br/>-wkid: well-known id
 * <br/>-semi_major:  ellipsoidal semi-major axis in meters
 * <br/>-unit: meters per unit
 * <br/>-inverse_flattening: inverse of flattening of the ellipsoid where 1/f  =  a/(a - b)
 * <br/>-Scale Factor: scale factor at origin
 * <br/>-latitude_of_origin: phi0, latitude of the false origin
 * <br/>-central_meridian: lamda0, longitude of the false origin  (with respect to the prime meridian)
 * <br/>-false_easting: FE, false easting, the Eastings value assigned to the natural origin 
 * <br/>-false_northing: FN, false northing, the Northings value assigned to the natural origin 
 * </code>
 * <br/>e.g. Georgia West State Plane NAD83 Feet:  
 * <br/><code> var gawsp83  = new TransverseMercator({wkid: 102667, semi_major:6378137.0,
 *  inverse_flattening:298.257222101,central_meridian:-84.16666666666667, latitude_of_origin: 30.0,
 *  scale_factor:0.9999, false_easting:2296583.333333333, false_northing:0, unit: 0.3048006096012192});
 *  </code>
 * @param {Object} params 
 * @name TransverseMercator
 * @constructor
 * @class This class (<code>TransverseMercator</code>) represents a Spatial Reference System based on 
 * <a target  = wiki href  = 'http://en.wikipedia.org/wiki/Transverse_Mercator_projection'>Transverse Mercator Projection</a>
 * @extends SpatialReference
 */
function TransverseMercator(params) {
    params = params || {};
  SpatialReference.call(this, params);
    //GLatLng(33.74561,-84.454308)<  === >  GPoint(2209149.07977075, 1362617.71496891);
    this.a_ = params.semi_major / params.unit;//this.
    var f_i = params.inverse_flattening;
    this.k0_ = params.scale_factor;
    var phi0 = params.latitude_of_origin * RAD_DEG;//(Math.PI / 180);
    this.lamda0_ = params.central_meridian * RAD_DEG;
    this.FE_ = params.false_easting;//this.
    this.FN_ = params.false_northing;//this.
    var f = 1.0 / f_i;//this.
    /*e: eccentricity of the ellipsoid where e^2  =  2f - f^2 */
    this.es_ = 2 * f - f * f;
    //var _e  =  Math.sqrt(this.es_);
    /* e^4 */
    this.ep4_ = this.es_ * this.es_;
    /* e^6 */
    this.ep6_ = this.ep4_ * this.es_;
    /* e'  second eccentricity where e'^2  =  e^2 / (1-e^2) */
    this.eas_ = this.es_ / (1 - this.es_);
    this.M0_ = this.calc_m_(phi0, this.a_, this.es_, this.ep4_, this.ep6_);
}
  
TransverseMercator.prototype = new SpatialReference();
  /**
   * calc_m_
   * @param {Object} phi
   * @param {Object} a
   * @param {Object} es
   * @param {Object} ep4
   * @param {Object} ep6
   */
TransverseMercator.prototype.calc_m_ = function(phi, a, es, ep4, ep6) {
    return a * ((1 - es / 4 - 3 * ep4 / 64 - 5 * ep6 / 256) * phi - (3 * es / 8 + 3 * ep4 / 32 + 45 * ep6 / 1024) * Math.sin(2 * phi) + (15 * ep4 / 256 + 45 * ep6 / 1024) * Math.sin(4 * phi) - (35 * ep6 / 3072) * Math.sin(6 * phi));
  };
  /**
   * see {@link SpatialReference}
 * @param {Array.number} lnglat
 * @return {Array.number}
   */
TransverseMercator.prototype.forward = function(lnglat) {
    var phi = lnglat[1] * RAD_DEG;// (Math.PI / 180);
    var lamda = lnglat[0] * RAD_DEG;//(Math.PI / 180);
    var nu = this.a_ / Math.sqrt(1 - this.es_ * Math.pow(Math.sin(phi), 2));
    var T = Math.pow(Math.tan(phi), 2);
    var C = this.eas_ * Math.pow(Math.cos(phi), 2);
    var A = (lamda - this.lamda0_) * Math.cos(phi);
    var M = this.calc_m_(phi, this.a_, this.es_, this.ep4_, this.ep6_);
    var E = this.FE_ + this.k0_ * nu * (A + (1 - T + C) * Math.pow(A, 3) / 6 + (5 - 18 * T + T * T + 72 * C - 58 * this.eas_) * Math.pow(A, 5) / 120);
    var N = this.FN_ + this.k0_ * (M - this.M0_) + nu * Math.tan(phi) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * Math.pow(A, 4) / 120 + (61 - 58 * T + T * T + 600 * C - 330 * this.eas_) * Math.pow(A, 6) / 720);
    return [E, N];
  };
  /**
   * see {@link SpatialReference}
 * @param {Array.number}  coords
 * @return {Array.number}
   */
TransverseMercator.prototype.inverse = function(coords) {
    var E = coords[0];
    var N = coords[1];
    var e1 = (1 - Math.sqrt(1 - this.es_)) / (1 + Math.sqrt(1 - this.es_));
    var M1 = this.M0_ + (N - this.FN_) / this.k0_;
    var mu1 = M1 / (this.a_ * (1 - this.es_ / 4 - 3 * this.ep4_ / 64 - 5 * this.ep6_ / 256));
    var phi1 = mu1 + (3 * e1 / 2 - 27 * Math.pow(e1, 3) / 32) * Math.sin(2 * mu1) + (21 * e1 * e1 / 16 - 55 * Math.pow(e1, 4) / 32) * Math.sin(4 * mu1) + (151 * Math.pow(e1, 3) / 6) * Math.sin(6 * mu1) + (1097 * Math.pow(e1, 4) / 512) * Math.sin(8 * mu1);
    var C1 = this.eas_ * Math.pow(Math.cos(phi1), 2);
    var T1 = Math.pow(Math.tan(phi1), 2);
    var N1 = this.a_ / Math.sqrt(1 - this.es_ * Math.pow(Math.sin(phi1), 2));
    var R1 = this.a_ * (1 - this.es_) / Math.pow((1 - this.es_ * Math.pow(Math.sin(phi1), 2)), 3 / 2);
    var D = (E - this.FE_) / (N1 * this.k0_);
    var phi = phi1 - (N1 * Math.tan(phi1) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * this.eas_) * Math.pow(D, 4) / 24 + (61 + 90 * T1 + 28 * C1 + 45 * T1 * T1 - 252 * this.eas_ - 3 * C1 * C1) * Math.pow(D, 6) / 720);
    var lamda = this.lamda0_ + (D - (1 + 2 * T1 + C1) * Math.pow(D, 3) / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * this.eas_ + 24 * T1 * T1) * Math.pow(D, 5) / 120) / Math.cos(phi1);
    return [lamda / RAD_DEG, phi / RAD_DEG];
  };
  /**
   * see {@link SpatialReference}
 * @return number
   */
TransverseMercator.prototype.getCircum = function() {
    return Math.PI * 2 * this.a_;
  };

/**
 * Creates a Spatial Reference based on Sphere Mercator Projection. 
 * The <code>params</code> passed in constructor should have the following properties:
 * <code><br/>-wkid: wkid
 * <br/>-semi_major:  ellipsoidal semi-major axis 
 * <br/>-unit: meters per unit
 * <br/>-central_meridian: lamda0, longitude of the false origin  (with respect to the prime meridian)
 * </code>
 * <br/>e.g. The "Web Mercator" used in ArcGIS Server:<br/>
 * <code> var web_mercator  = new SphereMercator({wkid: 102113,  semi_major:6378137.0,  central_meridian:0, unit: 1 });
 * </code>
 * @name SphereMercator
 * @class This class (<code>SphereMercator</code>) is the Projection Default Google Maps uses. It is a special form of Mercator.
 * @constructor
 * @param {Object} params 
 * @extends SpatialReference
 */
function SphereMercator(params) {
    /*  =========== parameters  =  ===================== */
  params = params || {};
  SpatialReference.call(this, params);
    this.a_ = (params.semi_major || 6378137.0) / (params.unit || 1);
    this.lamda0_ = (params.central_meridian || 0.0) * RAD_DEG;
}
  
SphereMercator.prototype = new SpatialReference();
  
  /**
   * See {@link SpatialReference}
 * @param {Array.number} lnglat
 * @return {Array.number}
   */
SphereMercator.prototype.forward = function(lnglat) {
    var phi = lnglat[1] * RAD_DEG;
    var lamda = lnglat[0] * RAD_DEG;
    var E = this.a_ * (lamda - this.lamda0_);
    var N = (this.a_ / 2) * Math.log((1 + Math.sin(phi)) / (1 - Math.sin(phi)));
    return [E, N];
  };
  /**
   * See {@link SpatialReference}
 * @param {Array.number}  coords
 * @return {Array.number}
   */
SphereMercator.prototype.inverse = function(coords) {
    var E = coords[0];
    var N = coords[1];
    var phi = Math.PI / 2 - 2 * Math.atan(Math.exp(-N / this.a_));
    var lamda = E / this.a_ + this.lamda0_;
   return [lamda / RAD_DEG, phi / RAD_DEG];
  };
  /**
   * See {@link SpatialReference}
   * @return {Number}
   */
  SphereMercator.prototype.getCircum = function () {
    return Math.PI * 2 * this.a_;
  };
  /**
 * Create a Albers Equal-Area Conic Projection based Spatial Reference. The <code>params</code> passed in construction should
 * include the following properties:<code>
 * <br/>-wkid: well-known id
 * <br/>-semi_major:  ellipsoidal semi-major axis in meter
 * <br/>-unit: meters per unit
 * <br/>-inverse_flattening: inverse of flattening of the ellipsoid where 1/f  =  a/(a - b)
 * <br/>-standard_parallel_1: phi1, latitude of the first standard parallel
 * <br/>-standard_parallel_2: phi2, latitude of the second standard parallel
 * <br/>-latitude_of_origin: phi0, latitude of the false origin
 * <br/>-central_meridian: lamda0, longitude of the false origin  (with respect to the prime meridian)
 * <br/>-false_easting: FE, false easting, the Eastings value assigned to the natural origin
 * <br/>-false_northing: FN, false northing, the Northings value assigned to the natural origin
 * </code>
 * <br/> e.g. 
 * <code> var albers  = new Albers({wkid:9999, semi_major: 6378206.4,inverse_flattening: 294.9786982,
 *   standard_parallel_1: 29.5, standard_parallel_2: 45.5,
 *   central_meridian: -96.0, latitude_of_origin: 23,false_easting: 0,
 *   'false_northing': 0, unit: 1 }); </code>
 * @name Albers
 * @class This class (<code>Albers</code>) represents a Spatial Reference System based on <a target=wiki href  = 'http://en.wikipedia.org/wiki/Albers_projection'>Albers Projection</a>. 
 * @extends SpatialReference
 * @constructor
 * @param {Object} params
 */
function Albers(params) {
    //http://pubs.er.usgs.gov/djvu/PP/PP_1395.pdf, page 101 &  292
    //for NAD_1983_Alaska_Albers: LatLng()<  === > Point();
    params = params || {};
  SpatialReference.call(this, params);
    var f_i = params.inverse_flattening;
    var phi1 = params.standard_parallel_1 * RAD_DEG;
    var phi2 = params.standard_parallel_2 * RAD_DEG;
    var phi0 = params.latitude_of_origin * RAD_DEG;
    this.a_ = params.semi_major / params.unit;
    this.lamda0_ = params.central_meridian * RAD_DEG;
    this.FE_ = params.false_easting;
    this.FN_ = params.false_northing;
    
    var f = 1.0 / f_i; //e: eccentricity of the ellipsoid where e^2  =  2f - f^2 
    var es = 2 * f - f * f;
    this.e_ = Math.sqrt(es);
    var m1 = this.calc_m_(phi1, es);
    var m2 = this.calc_m_(phi2, es);
    
    var q1 = this.calc_q_(phi1, this.e_);
    var q2 = this.calc_q_(phi2, this.e_);
    var q0 = this.calc_q_(phi0, this.e_);
    
    this.n_ = (m1 * m1 - m2 * m2) / (q2 - q1);
    this.C_ = m1 * m1 + this.n_ * q1;
    this.rho0_ = this.calc_rho_(this.a_, this.C_, this.n_, q0);
};
  
Albers.prototype = new SpatialReference();
  /**
   * calc_m_
 * @param {number} phi
 * @param {number} es e square
   */
Albers.prototype.calc_m_ = function(phi, es) {
    var sinphi = Math.sin(phi);
    return Math.cos(phi) / Math.sqrt(1 - es * sinphi * sinphi);
  };
  
  
  /**
   * formular (3-12) page 101
   * @param {Object} phi
   * @param {Object} e
   */
Albers.prototype.calc_q_ = function(phi, e) {
    var esp = e * Math.sin(phi);
    return (1 - e * e) * (Math.sin(phi) / (1 - esp * esp) - (1 / (2 * e)) * Math.log((1 - esp) / (1 + esp)));
  };
  
Albers.prototype.calc_rho_ = function(a, C, n, q) {
    return a * Math.sqrt(C - n * q) / n;
  };
    
Albers.prototype.calc_phi_ = function(q, e, phi) {
    var esp = e * Math.sin(phi);
    return phi + (1 - esp * esp) * (1 - esp * esp) / (2 * Math.cos(phi)) * (q / (1 - e * e) - Math.sin(phi) / (1 - esp * esp) + Math.log((1 - esp) / (1 + esp)) / (2 * e));
  };
  
Albers.prototype.solve_phi_ = function(q, e, init) {
    // iteration
    var i = 0;
    var phi = init;
    var newphi = this.calc_phi_(q, e, phi);
    while (Math.abs(newphi - phi) > 0.00000001 && i < 10) {
      i++;
      phi = newphi;
      newphi = this.calc_phi_(q, e, phi);
    }
    return newphi;
  };

  /** 
   * see {@link SpatialReference}
 * @param {Array.number} lnglat
 * @return {Array.number}
   */
Albers.prototype.forward = function(lnglat) {
    var phi = lnglat[1] * RAD_DEG;
    var lamda = lnglat[0] * RAD_DEG;
    var q = this.calc_q_(phi, this.e_);
    var rho = this.calc_rho_(this.a_, this.C_, this.n_, q);
    var theta = this.n_ * (lamda - this.lamda0_);
    var E = this.FE_ + rho * Math.sin(theta);
    var N = this.FN_ + this.rho0_ - rho * Math.cos(theta);
    return [E, N];
  };
  /**
   * see {@link SpatialReference}
 * @param {Array.number}  coords
 * @return {Array.number}
   */
Albers.prototype.inverse = function(coords) {
    var E = coords[0] - this.FE_;
    var N = coords[1] - this.FN_;
    var rho = Math.sqrt(E * E + (this.rho0_ - N) * (this.rho0_ - N)); 
    var adj = this.n_ > 0 ? 1 : -1;
    var theta = Math.atan(adj * E / (adj * this.rho0_  - adj * N));
    var q = (this.C_ - rho * rho * this.n_ * this.n_ / (this.a_ * this.a_)) / this.n_;
    var init = Math.asin(q / 2);
    var phi = this.solve_phi_(q, this.e_, init);
    var lamda = theta / this.n_ + this.lamda0_;
    return [lamda / RAD_DEG, phi / RAD_DEG];
  };
  /**
   *  see {@link SpatialReference}
 *  @return number
   */
Albers.prototype.getCircum = function() {
    return Math.PI * 2 * this.a_;
  };
  /**
   * See {@link SpatialReference}
 * @return {number}
   */
Albers.prototype.getCircum = function() {
    return Math.PI * 2 * this.a_;
  };
  
WGS84 = new Geographic({
  wkid: 4326
  });
NAD83 = new Geographic({
  wkid: 4269
  });
WEB_MERCATOR = new SphereMercator({
    wkid: 102113,
    semi_major: 6378137.0,
    central_meridian: 0,
    unit: 1
});
WEB_MERCATOR_AUX = new SphereMercator({
      wkid: 102100,
      semi_major: 6378137.0,
      central_meridian: 0,
      unit: 1
    });
	
  // declared early but assign here to avoid dependency error by jslint
  spatialReferences_ = {
    '4326': WGS84,
    '4269': NAD83,
    '102113': WEB_MERCATOR,
    '102100': WEB_MERCATOR_AUX
  };
  
SpatialReference.WGS84 = WGS84;
SpatialReference.NAD83 = NAD83;
//TODO: check advanced compile impact
SpatialReference.WEB_MERCATOR = WEB_MERCATOR;
SpatialReference.WEB_MERCATOR_AUX = WEB_MERCATOR_AUX;
    
  /**
   * <b> static</b> method. Call with Syntax <code>SpatialReference.register(..)</code>. 
   * Add A Spatial Reference to the internal collection of Spatial References.
   * the <code>wktOrSR</code> parameter can be String format of "well-known text" of the
   * Spatial Reference, or an instance of {@link SpatialReference}.
   * <br/><li> If passes in String WKT format, to be consistent, it should use the same format as listed
   * in <a  href  = 'http://edndoc.esri.com/arcims/9.2/elements/pcs.htm'>
   * ESRI documentation</a>. For example, add NC State Plane NAD83 as String:
   * <br/><code>
   * SpatialReference.register(2264,'PROJCS["NAD_1983_StatePlane_North_Carolina_FIPS_3200_Feet",
   * GEOGCS["GCS_North_American_1983",
   * DATUM["D_North_American_1983",
   * SPHEROID["GRS_1980",6378137.0,298.257222101]],
   * PRIMEM["Greenwich",0.0],
   * UNIT["Degree",0.0174532925199433]],
   * PROJECTION["Lambert_Conformal_Conic"],
   * PARAMETER["False_Easting",2000000.002616666],
   * PARAMETER["False_Northing",0.0],
   * PARAMETER["Central_Meridian",-79.0],
   * PARAMETER["Standard_Parallel_1",34.33333333333334],
   * PARAMETER["Standard_Parallel_2",36.16666666666666],
   * PARAMETER["Latitude_Of_Origin",33.75],
   * UNIT["Foot_US",0.3048006096012192]]');
   * <br/></code>
   * Note: only <b>Lambert Conformal Conic</b> and <b>Transverse Mercator</b> Projection
   * based Spatial References are supported if added via WKT String.
   * <br/><li> If passes in an instance of {@link SpatialReference}, it can be one of the
   * built in classes, or a class that extends SpatialReference. For example, add NC State Plane NAD83 as SR:
   * <br/><code>
   * SpatialReferences.register(2264: new LambertConformalConic({
   * wkid: 2264,
   * semi_major: 6378137.0,
   * inverse_flattening: 298.257222101,
   * standard_parallel_1: 34.33333333333334,
   * standard_parallel_2: 36.16666666666666,
   * central_meridian: -79.0,
   * latitude_of_origin: 33.75,
   * 'false_easting': 2000000.002616666,
   * 'false_northing': 0,
   * unit: 0.3048006096012192
   * });
   * <br/></code>
   * @static
   * @param {Number|String} wkid/wkt
   * @param {Object} wktOrSR
   * @return {SpatialReference} registered SR
   */
Util.registerSR = function(wkidt, wktOrSR) {
    var sr = spatialReferences_['' + wkidt];
    if (sr) {
      return sr;
    }
    if (wktOrSR instanceof SpatialReference) {
      spatialReferences_['' + wkidt] = wktOrSR;
      sr = wktOrSR;
      
    } else {
      var wkt = wktOrSR || wkidt; // only one param is passed in.
      var params = {
        'wkt': wkidt
      };
      if (wkidt === parseInt(wkidt, 10)) {
        params = {
          'wkid': wkidt
        };
      }
      var prj = extractString_(wkt, "PROJECTION[\"", "\"]");
      var spheroid = extractString_(wkt, "SPHEROID[", "]").split(",");
      if (prj !== "") {
        params.unit = parseFloat(extractString_(extractString_(wkt, "PROJECTION", ""), "UNIT[", "]").split(",")[1]);
        params.semi_major = parseFloat(spheroid[1]);
        params.inverse_flattening = parseFloat(spheroid[2]);
        params.latitude_of_origin = parseFloat(extractString_(wkt, "\"Latitude_Of_Origin\",", "]"));
        params.central_meridian = parseFloat(extractString_(wkt, "\"Central_Meridian\",", "]"));
        params.false_easting = parseFloat(extractString_(wkt, "\"False_Easting\",", "]"));
        params.false_northing = parseFloat(extractString_(wkt, "\"False_Northing\",", "]"));
      }
      switch (prj) {
      case "":
        sr = new SpatialReference(params);
        break;
      case "Lambert_Conformal_Conic":
        params.standard_parallel_1 = parseFloat(extractString_(wkt, "\"Standard_Parallel_1\",", "]"));
        params.standard_parallel_2 = parseFloat(extractString_(wkt, "\"Standard_Parallel_2\",", "]"));
        sr = new LambertConformalConic(params);
        break;
      case "Transverse_Mercator":
        params.scale_factor = parseFloat(extractString_(wkt, "\"Scale_Factor\",", "]"));
        sr = new TransverseMercator(params);
        break;
      case "Albers":
        params.standard_parallel_1 = parseFloat(extractString_(wkt, "\"Standard_Parallel_1\",", "]"));
        params.standard_parallel_2 = parseFloat(extractString_(wkt, "\"Standard_Parallel_2\",", "]"));
        sr = new Albers(params);
        break;
      // more implementations here.
      default:
        throw new Error(prj + "  not supported");
      }
      if (sr) {
        spatialReferences_['' + wkidt] = sr;
      }
    }
    
    return sr;
  };
  
  //end of projection related code//
/**
 * @name Error
   * @class Error returned from Server.
   * Syntax:
   * <pre>
   * {
   "error" : 
  {
    "code" : 500, 
    "message" : "Object reference not set to an instance of an object.", 
    "details" : [
      "'geometry' parameter is invalid"
    ]
  }
  }
  </pre>
   */
  /**
   * Create a ArcGIS service catalog instance using it's url:<code> http://&lt;host>/&lt;instance>/rest/services</code>
   * @name Catalog
   * @constructor
   * @class  The catalog resource is the root node and initial entry point into an ArcGIS Server host.
   * This resource represents a catalog of folders and services published on the host.
   *  @param {String} url
   * @property {String} [currentVersion] currentVersion
 * @property {Array.string} [folders] folders list
 * @property {Array.string} [services] list of services. Each has <code>name, type</code> property.
   */
  function Catalog(url) {
    this.url = url;
    var me = this;
    getJSON_(url, {}, '', function(json) {
      augmentObject_(json, me);
      /**
       * This event is fired when the catalog info is loaded.
       * @name Catalog#load
       * @event
       */
      triggerEvent_(me, 'load');
    });
  }

  /**
   * @name Field
   * @class This class represents a field in a {@link Layer}. It is accessed from
   * the <code> fields</code> property. There is no constructor for this class,
   *  use Object Literal.
   * @property {String} [name] field Name
   * @property {String} [type] field type (esriFieldTypeOID|esriFieldTypeString|esriFieldTypeInteger|esriFieldTypeGeometry}.
   * @property {String} [alias] field alias.
   * @property {Domain} [domain] domain
   * @property {Int} [length] length.
   */
  /**
   * Create a ArcGIS map Layer using it's url (http://[mapservice-url]/[layerId])
   * @name Layer
   * @class This class (<code>Layer</code>) The layer / table(v10+)
   *  resource represents a single layer / table in a map of a map service 
   *  published by ArcGIS Server.
   * @constructor
   * @param {String} url
   * @property {Number} [id] layer ID
   * @property {String} [name] layer Name
   * @property {String} [type] Feature Layer|Image Layer
   * @property {String} [description] description
   * @property {String} [definitionExpression] Layer definition.
   * @property {String} [geometryType] geometryType type(esriGeometryPoint|..), only available after load.
   * @property {String} [copyrightText] copyrightText, only available after load.
   * @property {Layer} [parentLayer] parent Layer {@link Layer}
   * @property {Boolean} [defaultVisibility] defaultVisibility
 * @property {Array.Layer} [subLayers] sub Layers. {@link Layer}.
   * @property {Boolean} [visibility] Visibility of this layer
   * @property {Number} [minScale] minScale
   * @property {Number} [maxScale] maxScale
   * @property {TimeInfo} [timeInfo] timeInfo
   * @property {DrawingInfo} [drawingInfo] rendering info See {@link DrawingInfo}
   * @property {Boolean} [hasAttachments] hasAttachments
   * @property {String} [typeIdField] typeIdField
 * @property {Array.Field} [fields] fields, only available after load. See {@link Field}
 * @property {Array.String} [types] subtypes: id, name, domains.
 * @property {Array.String} [relationships] relationships (id, name, relatedTableId)
   */
function Layer(url) {
    this.url = url;
    this.definition = null;
}

  /**
   * Load extra information such as it's fields from layer resource.
   * If opt_callback function will be called after it is loaded
   */
Layer.prototype.load = function() {
    var me = this;
    if (this.loaded_) {
      return;
    }
    getJSON_(this.url, {}, '', function (json) {
    augmentObject_(json, me);
      me.loaded_ = true;
      /**
       * This event is fired when layer's service info is loaded.
       * @name Layer#load
       * @event
       */
      triggerEvent_(me, 'load');
    });
  };

  
  /**
   * Whether the layer is viewable at given scale
   * @param {Number} scale
   * @return {Boolean}
   */
Layer.prototype.isInScale = function(scale) {
    // note if the layer's extra info is not loaded, it will return true
    if (this.maxScale && this.maxScale > scale) {
      return false;
    }
    if (this.minScale && this.minScale < scale) {
      return false;
    }
    return true;
  };
  /**
   * @name SpatialRelationship
   * @enum
   * @class This is actually a list of constants that represent spatial 
   * relationship types. 
   * @property {String} [INTERSECTS] esriSpatialRelIntersects 
   * @property {String} [CONTAINS] esriSpatialRelContains
   * @property {String} [CROSSES] esriSpatialRelCrosses
   * @property {String} [ENVELOPE_INTERSECTS] esriSpatialRelEnvelopeIntersects
   * @property {String} [INDEX_INTERSECTS] esriSpatialRelIndexIntersects
   * @property {String} [OVERLAPS] esriSpatialRelOverlaps
   * @property {String} [TOUCHES] esriSpatialRelTouches
   * @property {String} [WITHIN] esriSpatialRelWithin
  */
  var SpatialRelationship = {
    INTERSECTS: 'esriSpatialRelIntersects',
    CONTAINS: 'esriSpatialRelContains',
    CROSSES: 'esriSpatialRelCrosses',
    ENVELOPE_INTERSECTS: 'esriSpatialRelEnvelopeIntersects',
    INDEX_INTERSECTS: 'esriSpatialRelIndexIntersects',
    OVERLAPS: 'esriSpatialRelOverlaps',
    TOUCHES: 'esriSpatialRelTouches',
    WITHIN: 'esriSpatialRelWithin'
  };
  /**
   * @name QueryOptions
   * @class This class represent the parameters needed in an query operation for a {@link Layer}.
   *   There is no constructor, use JavaScript object literal.
   * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/query.html'>Query Operation</a>.
   * @property {String} [text]  A literal search text. If the layer has a display field
   *   associated with it, the server searches for this text in this field.
   *   This parameter is a short hand for a where clause of:
   *   where [displayField]like '%[text]%'. The text is case sensitive.
   *   This parameter is ignored if the where parameter is specified.
   * @property {OverlayView|Array.OverlayView} [geometry] The geometry to apply as the spatial filter.
   * @property {SpatialRelationship} [spatialRelationship] The spatial relationship to be applied on the
   *    input geometry while performing the query. The supported spatial relationships
   *    include intersects, contains, envelope intersects, within, etc.
   *    The default spatial relationship is intersects. See {@link SpatialRelationship}
   * @property {String} [where] A where clause for the query filter. Any legal SQL where clause operating on the fields in the layer is allowed.
   * @property {Array.string} [outFields] The list of fields to be included in the returned resultset.
   * @property {Boolean} [returnGeometry] If true, If true, the resultset will include the geometries associated with each result.
   * @property {Array.number} [objectIds] The object IDs of this layer / table to be queried
   * @property {Number} [maxAllowableOffset] This option can be used to specify the maximum allowable offset  to be used for generalizing geometries returned by the query operation
   * @property {Boolean} [returnIdsOnly] If true, the response only includes an array of object IDs. Otherwise the response is a feature set. The default is false.
   * @property {OverlayOptions} [overlayOptions] See {@link OverlayOptions}
   */
  /**
   * @name ResultSet
   * @class This class represent the results of an query operation for a {@link Layer}.
   *   There is no constructor, use JavaScript object literal.
   * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/query.html'>Query Operation</a>.
   * @property {String} [displayFieldName] display Field Name for layer
   * @property {Object} [fieldAliases] Field Name's Aliases. key is field name, value is alias.
   * @property {GemetryType} [geometryType] esriGeometryPoint | esriGeometryMultipoint | esriGeometryPolygon | esriGeometryPolyline
   * @property {Array.feature} [features] result as array of {@link Feature}
   * @property {String} [objectIdFieldName] objectIdFieldName when returnIdsOnly=true
   * @property {Array.int} [objectIds] objectIds when returnIdsOnly=true
   */
  /**
   * The query operation is performed on a layer resource. The result of this operation is a resultset resource that will be
   * passed in the callback function. param is an instance of {@link QueryOptions}
   * <br/>For more info see <a href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/query.html'>Query Operation</a>.
   * @param {QueryOptions} params
   * @param {Function} callback
   * @param {Function} errback
   */
  Layer.prototype.query = function(p, callback, errback) {
    if (!p) {
      return;
    }
    // handle text, where, relationParam, objectIds, maxAllowableOffset
    var params = augmentObject_(p, {});
    if (p.geometry && !isString_(p.geometry)) {
      params.geometry = fromOverlaysToJSON_(p.geometry);
      params.geometryType = getGeometryType_(p.geometry);
      params.inSR = 4326;
    }
    if (p.spatialRelationship) {
      params.spatialRel = p.spatialRelationship;
      delete params.spatialRelationship;
    }
    if (p.outFields && isArray_(p.outFields)) {
      params.outFields = p.outFields.join(',');
    }
    if (p.objectIds) {
      params.objectIds = p.objectIds.join(',');
    }
    if (p.time) {
      params.time = formatTimeString_(p.time, p.endTime);
    }
    params.outSR = 4326;
    params.returnGeometry = p.returnGeometry === false ? false : true;
    params.returnIdsOnly = p.returnIdsOnly === true ? true : false;
    delete params.overlayOptions;
    getJSON_(this.url + '/query', params, '', function(json) {
      parseFeatures_(json.features, p.overlayOptions);
      callback(json, json.error);
      handleErr_(errback, json);
    });
  };
  /**
   * @name QueryRelatedRecordsOptions
   * @class This class represent the parameters needed in an query related records operation for a {@link Layer}.
   * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/queryrelatedrecords.html'>Query Related Records Operation</a>.
 * @property {Array.number} [objectIds] The object IDs of this layer / table to be queried
   * @property {Int} [relatioshipId] The ID of the relationship to be queried
 * @property {Array.string} [outFields] The list of fields to be included in the returned resultset. This list is a comma delimited list of field names.
   * @property {String} [definitionExpression]  The definition expression to be applied to the related table / layer. From the list of objectIds, only those records that conform to this expression will be returned.
   * @property {Boolean} [returnGeometry  = true] If true, the resultset will include the geometries associated with each result.
   * @property [Number] [maxAllowableOffset] This option can be used to specify the maximum allowable offset  to be used for generalizing geometries returned by the query operation
   * @property {Number} [outSR] The well-known ID of or the {@link SpatialReference} of the output geometries
   */
  /**
   * @name RelatedRecords
   * @class This class represent the results of an query related records operation for a {@link Layer}.
   * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/queryrelatedrecords.html'>Query Operation</a>.
   * @property {String} [geometryType] esriGeometryPoint | esriGeometryMultipoint | esriGeometryPolygon | esriGeometryPolyline
   * @property {Object} [spatialReference] {@link SpatialReference}
   * @property {String} [displayFieldName] display Field Name for layer
 * @property {Array.object} [relatedRecordGroups] list of related records
   */
   /**
   * @name RelatedRecord
   * @class This class represent the result of an query related records operation for a {@link Layer}.
   *   There is no constructor, use JavaScript object literal.
   * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/queryrelatedrecords.html'>Query Operation</a>.
   * @property {int} [objectId] objectid of original record
 * @property {Array.feature} [relatedRecords] list of {@link Feature}s.
   */
  /**
   * The query related records operation is performed on a layer / table resource. 
   * The result of this operation are featuresets grouped by source layer / table 
   * object IDs. Each featureset contains Feature objects including the values for 
   * the fields requested by the user. For related layers, if you request geometry 
   * information, the geometry of each feature is also returned in the featureset. 
   * For related tables, the featureset does not include geometries. 
   * @param {QueryRelatedRecordsParameters} params
   * @param {Function} callback
   * @param {Function} errback
   */
Layer.prototype.queryRelatedRecords = function(qparams, callback, errback) {
    if (!qparams) {
      return;
    } 
  var params = augmentObject_(qparams, {});
    params.f = params.f || 'json';
    if (params.outFields && !isString_(params.outFields)) {
      params.outFields = params.outFields.join(',');
    }
    params.returnGeometry = params.returnGeometry === false ? false : true;
    getJSON_(this.url + '/query', params, '', function (json) {
      handleErr_(errback, json);
      callback(json);
    });
  };
  
  /**
   * @name MapSerivceOptions
   * @class provides options to construct a {@link MapService}
   * @property {Number} delayLoad number of seconds to delay loading meta data on construction.
   */
  /**
   * Creates a MapService objects that can be used by UI components.
   * <ul><li> <code> url</code> (required) is the URL of the map servive, e.g. <code>
   * http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Specialty/ESRI_StateCityHighway_USA/MapServer</code>.
   * <ul/> Note the spatial reference of the map service must already exists
   * in the {@link spatialReferences_} if actual coordinates transformation is needed.
   * @name MapService
   * @class This class (<code>MapService</code>) is the core class for all map service operations.
   * It represents an ArcGIS Server map service that offer access to map and layer content
   * @constructor
   * @param {String} url
   * @property {String} [url] map service URL
   * @property {String} [serviceDescription] serviceDescription
   * @property {String} [mapName] map frame Name inside the map document
   * @property {String} [description] description
   * @property {String} [copyrightText] copyrightText
   * @property {Array.Layer} [layers] array of {@link Layer}s.
   * @property {Array.Layer} [tables] array of Tables of type {@link Layer}.
   * @property {SpatialReference} [spatialReference] see {@link SpatialReference}
   * @property {Boolean} [singleFusedMapCache] if map cache is singleFused
   * @property {TileInfo} [tileInfo] See {@link TileInfo}
   * @property {TimeInfo} [timeInfo] see {@link TimeInfo}
   * @property {String} [units] unit
   * @property {String} [supportedImageFormatTypes] supportedImageFormatTypes, comma delimited list.
   * @property {Object} [documentInfo] Object with the folloing properties: <code>Title, Author,Comments,Subject,Category,Keywords</code>
   */
  function MapService(url, opts) {
    this.url = url;
    this.loaded_ = false;
    var tks = url.split("/");
    this.name = tks[tks.length - 2].replace(/_/g, ' ');
    opts = opts || {};
    if (opts.delayLoad) {
      var me = this;
      window.setTimeout(function() {
        me.loadServiceInfo();
      }, opts.delayLoad * 1000);
    } else {
      this.loadServiceInfo();
    }
  }

  /**
   * Load serviceInfo
   */
  MapService.prototype.loadServiceInfo = function() {
    var me = this;
    getJSON_(this.url, {}, '', function(json) {
      me.init_(json);
    });
  };
  /**
   * initialize an ArcGIS Map Service from the meta data information.
   * The <code>json</code> parameter is the json object returned by Map Service.
   * @private
   * @param {Object} json
   */
  MapService.prototype.init_ = function (json) {
    var me = this;
    if (json.error) {
      throw new Error(json.error.message);
    }
    augmentObject_(json, this);
    if (json.spatialReference.wkt) {
      this.spatialReference = Util.registerSR(json.spatialReference.wkt);
    } else {
      this.spatialReference = spatialReferences_[json.spatialReference.wkid];
    }
    if (json.tables !== undefined) {
      // v10.0 +
      getJSON_(this.url + '/layers', {}, '', function (json2) {
        me.initLayers_(json2);
        // V10 SP1 
        getJSON_(me.url + '/legend', {}, '', function (json3){
          me.initLegend_(json3);
          me.setLoaded_();
        });
      });
    } else {
      // v9.3
      me.initLayers_(json);
      me.setLoaded_();
    }
  };
   
  MapService.prototype.setLoaded_ = function() {
    this.loaded_ = true;
    /**
     * This event is fired when the service and it's service info is loaded.
     * @name MapService#load
     * @event
     */
    triggerEvent_(this, "load");
  };
   /**
   * initialize an Layers.
   * The <code>json</code> parameter is the json object returned by Map Service or layers operation(v10+).
   * @private
   * @param {Object} json2
   */ 
  MapService.prototype.initLayers_ = function (json2) {
    var layers = [];
    var tables = [];
    this.layers = layers;
    if (json2.tables) {
      this.tables = tables;
    }
    var layer, i, c, info;
    for (i = 0, c = json2.layers.length; i < c; i++) {
      info = json2.layers[i];
      layer = new Layer(this.url + '/' + info.id);
      augmentObject_(info, layer);
      layer.visible = layer.defaultVisibility;
      layers.push(layer);
    }
    if (json2.tables) {
      for (i = 0, c = json2.tables.length; i < c; i++) {
        info = json2.tables[i];
        layer = new Layer(this.url + '/' + info.id);
        augmentObject_(info, layer);
        tables.push(layer);
      }
    }
    for (i = 0, c = layers.length; i < c; i++) {
      layer = layers[i];
      if (layer.subLayerIds) {
        layer.subLayers = [];
        for (var j = 0, jc = layer.subLayerIds.length; j < jc; j++) {
          var subLayer = this.getLayer(layer.subLayerIds[j]);
          layer.subLayers.push(subLayer);
          subLayer.parentLayer = layer;
        }
      }
    }
    
  };
  /**
   * initialize an Layers.
   * The <code>json</code> parameter is the json object returned by Map Service or layers operation(v10+).
   * @private
   * @param {Object} json2
   */ 
  MapService.prototype.initLegend_ = function(json3) {
    // if not AGS10 SP1, server will return error.
    var layers = this.layers;
    if (json3.layers) {
      var layer, i, c, info;
      for (i = 0, c = json3.layers.length; i < c; i++) {
        info = json3.layers[i];
        layer = layers[info.layerId]; // layers id should same as index.
        augmentObject_(info, layer);
      }
    }
  };
  /**
   * Get a map layer by it's name(String) or id (Number), return {@link Layer}.
   * @param {String|Number} nameOrId
   * @return {Layer}
   */
  MapService.prototype.getLayer = function (nameOrId) {
    var layers = this.layers;
    if (layers) {
      for (var i = 0, c = layers.length; i < c; i++) {
        if (nameOrId === layers[i].id) {
          return layers[i];
        }
        if (isString_(nameOrId) && layers[i].name.toLowerCase() === nameOrId.toLowerCase()) {
          return layers[i];
        }
      }
    }
    return null;
  };

  /**
   * Get the layer definitions.
   * @return {Object} key as id, value as string of definition expression.
   */
  MapService.prototype.getLayerDefs_ = function() {
    var ret = {};
    if (this.layers) {
      for (var i = 0, c = this.layers.length; i < c; i++) {
        var layer = this.layers[i];
        if (layer.definition) {
          ret[String(layer.id)] = layer.definition;
        }
      }
    }
    return ret;
  };
  /**
   * If the map service meta info is loaded
   * @return {Boolean}
   */
  MapService.prototype.hasLoaded = function () {
    return this.loaded_;
  }
  /**
   * get a  list of visible layer's Ids
   * @return {Array.number} null if not initialized
   */
  MapService.prototype.getVisibleLayerIds_ = function () {
    var ret = [];
    if (this.layers) { // in case service not loaded_
      var layer;
      // a special behavior of REST (as of 9.3.1): 
      // if partial group then parent must be off
      var i, c;
      for (i = 0, c = this.layers.length; i < c; i++) {
        layer = this.layers[i];
        if (layer.subLayers) {
          for (var j = 0, jc = layer.subLayers.length; j < jc; j++) {
            if (layer.subLayers[j].visible === false) {
              layer.visible = false;
              break;
            }
          }
        }
      }
      for (i = 0, c = this.layers.length; i < c; i++) {
        layer = this.layers[i];
        //2010-10-26: in AGS10, group layer behavior is opposite of 9.3.1. And UNDOUMENTED in REST API!
        if (layer.subLayers && layer.subLayers.length > 0) {
          continue;
        }
        if (layer.visible === true) {
          ret.push(layer.id);
        }
      }
    }
    return ret;
  };
  /**
   * get initial bounds of the map serivce
   * @return {google.maps.LatLngBounds}
   */
  MapService.prototype.getInitialBounds = function () {
    if (this.initialExtent) {
      this.initBounds_ = this.initBounds_ || fromEnvelopeToLatLngBounds_(this.initialExtent);
      return this.initBounds_;
    }
    return null;
  };
  /**
   * get full bounds of the map serivce
   * @return {google.maps.LatLngBounds}
   */
  MapService.prototype.getFullBounds = function () {
    if (this.fullExtent) {
      this.fullBounds_ = this.fullBounds_ || fromEnvelopeToLatLngBounds_(this.fullExtent)
      return this.fullBounds_;
    }
    return null;
  };
/**
 * @name ExportMapOptions
 * @class This class represent the parameters needed in an exportMap operation for a {@link MapService}.
  * <br/>For more info see <a  href='http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/export.html'>Export Operation</a>.
 * @property {Number} [width] width of image, in pixel;
 * @property {Number} [height] height of image, in pixel;
 * @property {SpatialReference} [imageSR] The well-known ID of the spatial reference of the exported image or instance of {@link SpatialReference}.
 * @property {String} [format  = png] The format of the exported image. png | png8 | png24 | jpg | pdf | bmp | gif | svg
 * @property {Number} [dpi] The dpi of the exported image, default 96
 * @property {Object} [layerDefinitions] Allows you to filter the features of individual layers in the exported map by specifying 
 *   definition expressions for those layers. Syntax: { "&lt;layerId1>" : "&lt;layerDef1>" , "&lt;layerId2>" : "&lt;layerDef2>" }
 *   key is layerId returned by server, value is definition for that layer.
 * @property {Array.number} [layerIds] list of layer ids. If not specified along with layerOptions, show list of visible layers. 
 * @property {String} [layerOptions] show | hide | include | exclude. If not specified with along layerIds, show list of visible layers. 
 * @property {Boolean} [transparent  = true] If true, the image will be exported with 
 *  the background color of the map set as its transparent color. note the REST API default value is false.
 * @property {google.maps.LatLngBounds} [bounds] bounds of map
 * @property {Date} [time] The time instant the exported map image if the service supports time (since AGS10).
 * @property {Date} [endTime] The end time instant the exported map image if the service supports time (since AGS10).
 *  time=&lt;timeInstant> or time=&lt;startTime>, &lt;endTime>, e.g. time=1199145600000, 1230768000000 (1 Jan 2008 00:00:00 GMT to 1 Jan 2009 00:00:00 GMT) 
 * @property {Object} [layerTimeOptions] layerTimeOptions The time options per layer. Users can indicate whether or not the layer should use the time extent
 *  specified by the time parameter or not, whether to draw the layer 
 *  features cumulatively or not and the time offsets for the layer. Syntax: <pre>
 *  {
  "&lt;layerId1>" : {
    //If true, use the time extent specified by the time parameter
    "useTime" : &lt; true | false >,
    //If true, draw all the features from the beginning of time for that data
    "timeDataCumulative" : &lt; true | false >,
    //Time offset for this layer so that it can be overlaid on the top of a previous or future time period
    "timeOffset" : &lt;timeOffset1>,
    "timeOffsetUnits" : "&lt;esriTimeUnitsCenturies | esriTimeUnitsDays | esriTimeUnitsDecades | 
                             esriTimeUnitsHours | esriTimeUnitsMilliseconds | esriTimeUnitsMinutes | 
                             esriTimeUnitsMonths | esriTimeUnitsSeconds | esriTimeUnitsWeeks | esriTimeUnitsYears |
                             esriTimeUnitsUnknown>"
  },
  "&lt;layerId2>" : {
    "useTime" : &lt; true | false >,
    "timeDataCumulative" : &lt; true | false >,
    "timeOffsetOffset" : &lt;timeOffset2>,
    "timeOffsetUnits" : "&lt;timeOffsetUnits2>"
  }
}
</pre>
 */

/**
 * @name MapImage
 * @class This is the result of {@link MapService}.exportMap operation.
 *   There is no constructor, use as JavaScript object literal.
 * @property {String} [href] URL of image
 * @property {google.maps.LatLngBounds} [bounds] The bounding box of the exported image. 
 * @property {Number} [width] width of the exported image.
 * @property {Number} [height] height of the exported image.
 * @property {Number} [scale] scale of the exported image.
 */

  /**
   * Export an image with given parameters.
   * For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/export.html'>Export Operation</a>.
   * <br/> The <code>params</code> is an instance of {@link ExportMapOptions}.
   * The following properties will be set automatically if not specified:...
   * <br/> The <code>callback</code> is the callback function with argument of
   * an instance of {@link MapImage}.
   * @param {ExportMapOptions} params
   * @param {Function} callback
   * @param {Function} errback
   * @return {String|None} url of image if f=image, none if f=json
   */
  MapService.prototype.exportMap = function (p, callback, errback) {
    if (!p || !p.bounds) {
      return;
    }
    // note: dynamic map may overlay on top of maptypes with different projection
    var params = {};// augmentObject_(p, );
    params.f = p.f;
    var bnds = p.bounds;
    params.bbox = '' + bnds.getSouthWest().lng() + ',' + '' + bnds.getSouthWest().lat() + ',' +
    bnds.getNorthEast().lng() +
    ',' +
    '' +
    bnds.getNorthEast().lat();
    //delete params.bounds;
    //log_('send '+bnds.toUrlValue());
    params.size = '' + p.width + ',' + p.height;
    params.dpi = p.dpi;
    
    if (p.imageSR) {
      if (p.imageSR.wkid) {
        params.imageSR = p.imageSR.wkid;
      } else {
        params.imageSR = '{wkt:' + p.imageSR.wkt + '}';
      }
    }
    params.bboxSR = '4326';
    params.format = p.format;
    var defs = p.layerDefinitions;
    // there is a slightly difference between {} and undefined
    // if do not want use def at all, pass in {}, if want to use 
    // in service, do not pass in anything.
    if (defs === undefined) {
      defs = this.getLayerDefs_();
    } 
    // for 9.3 compatibility:
    params.layerDefs = getLayerDefsString_(defs);
    var vlayers = p.layerIds;
    var layerOpt = p.layerOption || 'show';   
    if (vlayers === undefined) {
      vlayers = this.getVisibleLayerIds_();
    }
    if (vlayers.length > 0) {
      params.layers =  layerOpt + ':' + vlayers.join(',');
    } else {
      // no layers visible, no need to go to server, note if vlayers is null means not init yet in which case do not send layers 
      if (this.loaded_ && callback) {
        callback({
          href: null
        });
        return;
      }
      
    }
    params.transparent = (p.transparent === false ? false : true);
    if (p.time) {
      params.time = formatTimeString_(p.time, p.endTime);
    }
    //TODO: finish once v10 released
    params.layerTimeOptions = p.layerTimeOptions;
    
    if (params.f === 'image') {
      return this.url + '/export?' + formatParams_(params);
    } else {
      getJSON_(this.url + '/export', params, '', function (json) {
        if (json.extent) {
          json.bounds = fromEnvelopeToLatLngBounds_(json.extent);
          //log_('got '+json.bounds.toUrlValue());
          delete json.extent;
          callback(json); 
        } else {
          handleErr_(errback, json.error);  
        }
      });
    }
  };
 /**
 * @name Feature
 * @class This class represent JSON feature object as returned by the REST API.
 *   There is no constructor, use JavaScript object literal.
 * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/feature.html'>Feature Object</a>.
 * Syntax:
 * <pre>
{
  "geometry" : &lt;overlays>,
  "attributes" : {
    "name1" : &lt;value1>,
    "name2" : &lt;value2>,
  }
}
 * </pre>
 * @property {Array.OverlayView} [geometry] geometries. Array of Marker, Polyline or Polygon.
 * @property {Object} [attributes] attributes as name-value JSON object.
 */
  /**
   * @name IdentifyOptions
   * @class This class represent the parameters needed in an identify operation for a {@link MapService}.
   *   There is no constructor, use JavaScript object literal.
   * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/identify.html'>Identify Operation</a>.
   * @property {Geometry} [geometry] The geometry to identify on, <code>google.maps.LatLng</code>, <code>Polyline</code>, or <code>Polygon</code>.
   * @property {Array.number} [layerIds] The layers to perform the identify operation on. 
   * @property {String} [layerOption] The layers to perform the identify operation on. 'top|visible|all'. 
   * @property {Number} [tolerance] The distance in screen pixels from the specified geometry within which the identify should be performed
   * @property {google.maps.LatLngBounds} [bounds] The bounding box of the map currently being viewed.
   * @property {Number} [width] width of image in pixel
   * @property {Number} [height] height of image in pixel
   * @property {Number} [dpi] dpi of image, default 96;
   * @property {Boolean} [returnGeometry  = true] If true, the resultset will include the geometries associated with each result.
   * @property {Number} [maxAllowableOffset] This option can be used to specify the maximum allowable offset  to be used for generalizing geometries returned by the identify operation
   * @property {OverlayOptions} [overlayOptions] how results should be rendered. See {@link OverlayOptions}
   */
  /**
   * @name IdentifyResults
   * @class This class represent the results of an identify operation for
   * a {@link MapService}.
   *   There is no constructor, use JavaScript object literal.
   * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/identify.html'>Identify Operation</a>.
   * @property {Array.IdentifyResult} [results] The identify results as an array of {@link IdentifyResult}
   */
  /**
   * @name IdentifyResult
   * @class This class represent one entry in the results of an identify operation for a {@link MapService}.
   *   There is no constructor, use JavaScript object literal.
   * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/identify.html'>Identify Operation</a>.
   * @property {Number} [layerId] layerId
   * @property {String} [layerName] layerName
   * @property {String} [value] value of the display field
   * @property {String} [displayFieldName] displayFieldName
   * @property {Feature} [feature] {@link Feature}
   */
  /**
   * Identify features on a particular Geographic location, using {@link IdentifyOptions} and
   * process {@link IdentifyResults} using the <code>callback</code> function.
   * For more info see <a
   * href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/identify.html'>Identify Operation</a>.
   * @param {IdentifyOptions} params
   * @param {Function} callback
   * @param {Function} errback
   */
  MapService.prototype.identify = function (p, callback, errback) {
    if (!p) {
      return;
    }
    var params = {};//augmentObject_(p, );
    params.geometry = fromOverlaysToJSON_(p.geometry);
    params.geometryType = getGeometryType_(p.geometry);
    params.mapExtent = fromOverlaysToJSON_(p.bounds);
    params.tolerance = p.tolerance || 2;
    params.sr = 4326;
    params.imageDisplay = '' + p.width + ',' + p.height + ',' + (p.dpi || 96);
    params.layers = (p.layerOption || 'all');
    if (p.layerIds) {
      params.layers += ':' + p.layerIds.join(',');
    }
    if (p.layerDefs) {
      params.layerDefs = getLayerDefsString_(p.layerDefs);
    }
    params.maxAllowableOffset = p.maxAllowableOffset;
    params.returnGeometry = (p.returnGeometry === false ? false : true);
    
    getJSON_(this.url + '/identify', params, '', function (json) {
      // process results;
      var rets = null;
      var i, js, g;
      if (json.results) {
        rets = [];
        for (i = 0; i < json.results.length; i++) {
          js = json.results[i];
          g = fromJSONToOverlays_(js.geometry, p.overlayOptions);
          js.feature = {
            geometry: g,
            attributes: js.attributes
          };
          delete js.attributes;
        }
      }
      callback(json);
      handleErr_(errback, json);
    });
  };
  /**
   * @name FindOptions
   * @class This class represent the parameters needed in an find operation for a {@link MapService}.
   *   There is no constructor, use JavaScript object literal.
   * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/find.html'>Find Operation</a>.
   * @property {String} [searchText] The search string. This is the text that is searched across the layers and the fields that the user specifies.
   * @property {Boolean} [contains  = true] If false, the operation searches for an exact match of
   *   the searchText string. An exact match is case sensitive.
   *   Otherwise, it searches for a value that contains the searchText provided.
   *    This search is not case sensitive. The default is true.
   * @property {Array.string} [searchFields] The names of the fields to search. 
   *    If this parameter is not specified, all fields are searched.
   * @property {Array.number} [layerIds] The layer Ids to perform the find operation on. The layers to perform the find operation on.
   * @property {Boolean} [returnGeometry  = true] If true, the resultset will include the geometries associated with each result.
   * @property {Number} [maxAllowableOffset] This option can be used to specify the maximum allowable offset  to be used for generalizing
   *             geometries returned by the find operation 
   */
  /**
   * @name FindResults
   * @class This class represent the results of a find operation for a {@link MapService}.
   *   There is no constructor, use JavaScript object literal.
   * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/find.html'>Find Operation</a>.
   * @property {Array.FindResult} [results] The find results as an array of {@link FindResult}
   */
  /**
   * @name FindResult
   * @class This class represent one entry in the results of a find operation for a {@link MapService}.
   *   There is no constructor, use JavaScript object literal.
   * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/find.html'>Find Operation</a>.
   * @property {Number} [layerId] layerId
   * @property {String} [layerName] layerName
   * @property {String} [value] value of the display field
   * @property {String} [displayFieldName] displayFieldName
   * @property {String} [foundFieldName] foundFieldName
   * @property {String} [geometryType] esriGeometryPoint | esriGeometryPolyline | esriGeometryPolygon | esriGeometryEnvelope
   * @property {Feature} [feature] {@link Feature}
   */
  /**
   * Find features using the {@link FindOptions} and process {@link FindResults}
   * using the <code>callback</code> function.
   * For more info see <a
   * href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/find.html'>Find Operation</a>.
   * @param {FindOptions} opts
   * @param {Function} callback
   * @param {Function} errback
   */
  MapService.prototype.find = function (opts, callback, errback) {
    if (!opts) {
      return;
    }
    // handle searchText, contains, maxAllowableOffset
    var params = augmentObject_(opts, {});
    if (opts.layerIds) {
      params.layers = opts.layerIds.join(',');
      delete params.layerIds;
    }
    if (opts.searchFields) {
      params.searchFields = opts.searchFields.join(',');
    }
    params.contains = (opts.contains === false ? false : true);
    if (opts.layerDefinitions) {
      params.layerDefs = getLayerDefsString_(opts.layerDefinitions);
      delete params.layerDefinitions;
    }
    params.sr = 4326;
    params.returnGeometry = (opts.returnGeometry === false ? false : true);
    getJSON_(this.url + '/find', params, '', function (json) {
      var rets = null;
      var i, js, g;
      if (json.results) {
        rets = [];
        for (i = 0; i < json.results.length; i++) {
          js = json.results[i];
          g = fromJSONToOverlays_(js.geometry, opts.overlayOptions);
          js.feature = {
            'geometry': g,
            'attributes': js.attributes
          };
          delete js.attributes;
        }
      }
      callback(json);
      handleErr_(errback, json);
    });
  };
  
  /**
   * Query a layer with given id or name using the {@link QueryOptions} and process {@link ResultSet}
   * using the <code>callback</code> function.
   * See {@link Layer}.
   * For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/query.html'>Query Layer Operation</a>.
   * @param {Number|String} layerNameOrId
   * @param {QueryOptions} params
   * @param {Function} callback
   * @param {Function} errback
   */
  MapService.prototype.queryLayer = function (layerNameOrId, params, callback, errback) {
    var layer = this.getLayer(layerNameOrId);
    if (layer) {
      layer.query(params, callback, errback);
    }
  };
 
   /**
 * Creates a GeocodeService class.
 * Params:<li><code>url</code>: URL of service, syntax:<code>	http://{catalogurl}/{serviceName}/GeocodeServer</code>
 * @name GeocodeService
 * @class This class (<code>GeocodeService</code>) represent an ArcGIS <a href="http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/geocodeserver.html">GeocodeServer</a>
 *  service.
 * @constructor
 * @param {String} url
 * @property {String} [serviceDescription] serviceDescription
 * @property {Array.Field} [addressFields] input fields. 
 *    Each entry is an object of type {@link Field}, plus <code>required(true|false)</code>
 * @property {Array.Field} [candidateFields] candidate Fields. 
 *    Each entry is an object of type {@link Field}
 * @property {Array.Field} [intersectionCandidateFields] intersectionCandidateFields
 *    Each entry is an object of type {@link Field}
 * @property {SpatialReference} [spatialReference] spatialReference
 * @property {Object} [locatorProperties] an object with key-value pair that is specific to Locator type.
 */
  function GeocodeService(url) {
    this.url = url;
    this.loaded_ = false;
    var me = this;
    getJSON_(url, {}, '', function (json) {
      me.init_(json);
    });
  }
  
  /**
   * init
   * @param {Object} json
   */
  GeocodeService.prototype.init_ = function (json) {
    augmentObject_(json, this);
    if (json.spatialReference) {
      this.spatialReference = spatialReferences_[json.spatialReference.wkid || json.spatialReference.wkt] || WGS84;
    }
    this.loaded_ = true;
    /**
     * This event is fired when the service and it's service info is loaded.
     * @name GeocodeService#load
     * @event
     */
    triggerEvent_(this, 'load');
  };
  
  
/**
 * @name GeocodeOptions
 * @class This class represent the parameters needed in a find address candidate operation
 *  on a {@link GeocodeService}.
 *   There is no constructor, use JavaScript object literal.
 * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/candidates.html'>Find Adddress Candidates Operation</a>.
 * @property {Object} [inputs] an object literal with name-value pair of input values.
 * @property {Array.string} [outFields] The list of fields to be included in the returned resultset. 
 * @property {int|SpatialReference} [outSR] output SR, see {@link SpatialReference}
 */
/**
 * @name GeocodeResults
 * @class This class represent the results of an find address candidate operation for a 
 *  {@link GeocodeService}.
 *   There is no constructor, use JavaScript object literal.
 * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/candidates.html'>Find Adddress Candidates Operation</a>.
 * @property {Array.GeocodeResult} [candidates] The find address results as 
 * an array of {@link GeocodeResult}
 */
/**
 * @name GeocodeResult
 * @class This class represent one entry in the results of a find address operation for a
 *  {@link GeocodeService}.
 *   There is no constructor, use JavaScript object literal.
 * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/candidates.html'>Find Adddress Candidates Operation</a>.
 * @property {String} [address] matched address
 * @property {google.maps.LatLng} [location] matched location
 * @property {Number} [score] matching score
 * @property {Object} [attributes] attributes as name-value JSON object. 
 */
/**
 * The findAddressCandidates operation is performed on a geocode service
 *  resource. The result of this operation is a resource representing 
 *  the list of address candidates. This resource provides information 
 *  about candidates including the address, location, and score.
 *  param is an instance of {@link GeocodeOptions}. An instance of
 *  {@link GeocodeResults} will be passed into callback function.
 * @param {GeocodeOptions} params
 * @param {Function} callback
 * @param {Function} errback
 */
  GeocodeService.prototype.findAddressCandidates = function (gparams, callback, errback) {
    var params = augmentObject_(gparams, {});
    if (params.inputs) {
      augmentObject_(params.inputs, params);
      delete params.inputs;
    }
    if (isArray_(params.outFields)) {
      params.outFields = params.outFields.join(',');
    }
    //params.outSR = 4326;
    var me = this;
    getJSON_(this.url + '/findAddressCandidates', params, '', function (json) {
      if (json.candidates) {
        var res, loc;
        var cands = [];
        for (var i = 0; i < json.candidates.length; i++) {
          res = json.candidates[i];
          loc = res.location;
          if (!isNaN(loc.x) &&  !isNaN(loc.y)) {
            var ll = [loc.x, loc.y];
            // problem: AGS9.31 does not support outSR, so it wil be ignored.
            // however 10.0 does not return wkid in the result.
            // as compromise, use outSR in 10's request, not included in 9.3.
            var sr = me.spatialReference; 
            if (gparams.outSR){
               sr = spatialReferences_[gparams.outSR];  
            } 
            if (sr) ll = sr.inverse(ll);
            res.location = new G.LatLng(ll[1], ll[0]);
            cands[cands.length] = res;
          }
        }
      }
      callback({
        candidates:cands
      });
      handleErr_(errback, json);
    });
  };
  /**
   * Alias of <code>GeocodeService.findAddressCandidates</code>;
   * @param {GeocodeOptions} params
   * @param {Function} callback
   */
  GeocodeService.prototype.geocode = function (params, callback) {
    this.findAddressCandidates(params, callback);
  };

/**
 * @name ReverseGeocodeOptions
 * @class This class represent the parameters needed in a reverseGeocode operation
 *  on a {@link GeocodeService}.
 *   There is no constructor, use JavaScript object literal.
 * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/inverse.html'>Reverse Geocode Operation</a>.
 * @property {google.maps.LatLng} [location] an object literal of LatLng. 
 * @property {Number} [distance] The distance in meters from the given location within which 
 *  a matching address should be searched.
 */
/**
 * @name ReverseGeocodeResult
 * @class This class represent one entry in the results of a find address operation for a
 *  {@link GeocodeService}.
 *   There is no constructor, use JavaScript object literal.
 * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/inverse.html'>Reverse Geocode Operation</a>.
 * @property {Object} [address] matched address, object literal with name-value address parts. 
 * @property {google.maps.LatLng} [location] matched location
 */
/**
 * The reverseGeocode operation is The reverseGeocode operation is performed on a geocode service resource. 
 * The result of this operation is a inverse geocoded address resource.
 *  param is an instance of {@link ReverseGeocodeOptions}. An instance of
 *  {@link ReverseGeocodeResult} will be passed into callback function.
 * @param {ReverseGeocodeOptions} params
 * @param {Function} callback
 * @param {Function} errback
 */
  GeocodeService.prototype.reverseGeocode = function (params, callback, errback) {
    if (!isString_(params.location)) {
      params.location = fromOverlaysToJSON_(params.location);
    }
    params.outSR = 4326;
    var me = this;
    getJSON_(this.url + '/reverseGeocode', params, '', function (json) {
      if (json.location) {
        var loc = json.location;
        if (!isNaN(loc.x) && !isNaN(loc.y)) {
          var ll = [loc.x, loc.y];
          if (me.spatialReference) {
            ll = me.spatialReference.inverse(ll);
          }
          json.location = new G.LatLng(ll[1], ll[0]);
        }
      }
      callback(json);
      handleErr_(errback, json);
    });
  };
  
  //TODO: implement more Geometry operations
 /**
 * Creates an GeometryService class.
 * Params:<li><code>url</code>: URL of service, syntax:<code>	http://{catalogurl}/{serviceName}/GeometryServer</code>
 * @name GeometryService
 * @constructor
 * @class This class (<code>GeometryService</code>) represent an ArcGIS 
 * <a href="http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/geometryserver.html">Geometry</a>
 *  service.
 * @param {String} url
 */
  function GeometryService(url) {
    this.url  = url;
    this.t = 'geocodeservice';
  }
  
  /**
   * @name ProjectOptions
   * @class This class represent the parameters needed in an project operation
   *  for a {@link GeometryService}.
   *   There is no constructor, use JavaScript object literal.
   * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/project.html'>Project Operation</a>.
 * @property {Array.OverlayView|Array.object} [geometries] Array of <code>google.maps.LatLng, Polyline, Polygon</code>, or ESRI Geometry format to project.
   * @property {GeometryType} [geometryType] esriGeometryPoint | esriGeometryPolyline | esriGeometryPolygon | esriGeometryEnvelope
   * @property {SpatialReference} [inSpatialReference] The well-known ID of or the {@link SpatialReference} of the input geometries
   * @property {SpatialReference} [outSpatialReference] The well-known ID of or the {@link SpatialReference} of the out geometries
   */
  /**
   * @name ProjectResults
   * @class This class represent the parameters needed in an project operation
   *  for a {@link GeometryService}.
   *   There is no constructor, use JavaScript object literal.
   * <br/>For more info see <a  href  = 'http://sampleserver3.arcgisonline.com/ArcGIS/SDK/REST/project.html'>Project Operation</a>.
   * @property {Array.OverlayView|Array.object} [geometries] Array of <code>google.maps.LatLng, Polyline, Polygon<code>, or ESRI Geometry format to project. 
    */
  /**
   * This resource projects an array of input geometries from an input spatial reference
   * to an output spatial reference. Result of type {@link ProjectResults} is passed in callback function.
   * @param {ProjectOptions} params
   * @param {Function} callback
   * @param {Function} errback
   */
  GeometryService.prototype.project = function (p, callback, errback) {
    var params = prepareGeometryParams_(p);
    getJSON_(this.url + '/project', params, "callback", function (json) {
      var geom = [];
      if (p.outSpatialReference === 4326 || p.outSpatialReference.wkid === 4326) {
        for (var i = 0, c = json.geometries.length; i < c; i++) {
          geom.push(fromJSONToOverlays_(json.geometries[i]));
        }
        json.geometries = geom;
      }
      callback(json);
      handleErr_(errback, json);
    });
  };
 
 /**
  * Common units code in spatialReferences. Used in buffer operation.
  * This only has the most common units, for a full list of supported units, see 
  * <a href=http://resources.esri.com/help/9.3/ArcGISDesktop/ArcObjects/esriGeometry/esriSRUnitType.htm>esriSRUnitType</a>
  * and <a href=http://resources.esri.com/help/9.3/ArcGISDesktop/ArcObjects/esriGeometry/esriSRUnit2Type.htm>esriSRUnit2Type</a>
   * @enum {Number}
  * @property {Number} [METER] 9001 International meter.
  * @property {Number} [FOOT] 9002 International meter.
  * @property {Number} [SURVEY_FOOT] 9003 US survey foot.
  * @property {Number} [SURVEY_MILE] 9035 US survey mile.
  * @property {Number} [KILLOMETER] 9036 killometer.
  * @property {Number} [RADIAN] 9101 radian.
  * @property {Number} [DEGREE] 9102 degree.
  */
  var SRUnit = {
    METER: 9001,
    FOOT: 9002,
    SURVEY_FOOT: 9003,
    SURVEY_MILE: 9035,
    KILLOMETER: 9036,
    RADIAN: 9101,
    DEGREE: 9102
  };
  /**
   * @name BufferOptions
   * @class This class represent the parameters needed in an buffer operation
   *  for a {@link GeometryService}.
   * @property {Array.OverlayView|Array.object} [geometries] Array of <code>google.maps.LatLng</code>, <code>Polyline</code>, <code>Polygon</code>, or ESRI Geometry format to buffer. 
   * @property {SpatialReference} [bufferSpatialReference] The well-known ID of or the {@link SpatialReference} of the buffer geometries
   * @property {Array.number} [distances] The distances the input geometries are buffered.
   * @property {Number} [unit] see <a href='http://resources.esri.com/help/9.3/ArcGISDesktop/ArcObjects/esriGeometry/esriSRUnitType.htm'>esriSRUnitType Constants </a> .
   * @property {Boolean} [unionResults] If true, all geometries buffered at a given distance are unioned into a single (possibly multipart) polygon, and the unioned geometry is placed in the output array.
   * @property {OverlayOptions} [overlayOptions] how to render result overlay. See {@link OverlayOptions}
   */
  /**
   * @name BufferResults
   * @class This class represent the parameters needed in an project operation
   *  for a {@link GeometryService}.
   *   There is no constructor, use JavaScript object literal.
   * @property {Array.OverlayView|Array.object} [geometries] Array of <code>google.maps.LatLng, Polyline, Polygon</code>, or ESRI Geometry format to project. 
   */
  /**
   * This resource projects an array of input geometries from an input spatial reference
   * to an output spatial reference. Result of type {@link BufferResults} is passed in callback function.
   * @param {BufferOptions} params
   * @param {Function} callback. 
   * @param {Function} errback
   */
  GeometryService.prototype.buffer = function (p, callback, errback) {
    var params = prepareGeometryParams_(p);
    if (p.bufferSpatialReference) {
      params.bufferSR = formatSRParam_(p.bufferSpatialReference);
    }
    params.outSR = 4326;
    params.distances = p.distances.join(',');
    if (p.unit) {
      params.unit = p.unit;
    }
    getJSON_(this.url + '/buffer', params, "callback", function (json) {
      var geom = [];
      if (json.geometries) {
        for (var i = 0, c = json.geometries.length; i < c; i++) {
          geom.push(fromJSONToOverlays_(json.geometries[i], p['overlayOptions']));
        }
      }
      json.geometries = geom;
      callback(json);
      handleErr_(errback, json);
    });
  };
  /**
   * @name GPService
   * @class GPService
   * @constructor
   * @property {String} [serviceDescription]
   * @property {Array.string} [tasks]
   * @property {String} [executionType]
   * @property {String} [resultMapServerName]
   * @param {String} url http://[catalog-url]/[serviceName]/GPServer 
   */
  function GPService(url) {
    this.url = url;
    this.loaded_ = false;
    var me = this;
    getJSON_(url, {}, '', function (json) {
      augmentObject_(json, me);
      me.loaded_ = true;
      /**
     * This event is fired when the service and it's service info is loaded.
     * @name GPService#load
     * @event
     */
      triggerEvent_(me, 'load');
    });
  }

  /**
   * @name GPParameter
   * @property {String} [name]
   * @property {String} [dataType]
   * @property {String} [displayName]
   * @property {String} [direction]
   * @property {Object} [defaultValue]
   * @property {Object} [parameterType]
   * @property {String} [category]
   * @property {Array.object} [choiceList]
   */
  /**
   * @name GPTask
   * @class GPTask
   * @constructor
   * @property {String} [name]
   * @property {String} [displayName]
   * @property {String} [category]
   * @property {String} [helpUrl]
   * @property {String} [executionType]
   * @property {Array.GPParameter} [parameters] see {@link GPParameter}
   * @property {String} [name]
   * @property {String} [name]
   * @property {Array.string} [tasks]
   * @property {String} [resultMapServerName]
   * @param {String} url http://[catalog-url]/[serviceName]/GPServer 
   */
  function GPTask(url) {
    this.url = url;
    this.loaded_ = false;
    var me = this;
    getJSON_(url, {}, '', function (json) {
      augmentObject_(json, me);
      me.loaded_ = true;
      /**
     * This event is fired when the service and it's service info is loaded.
     * @name GPService#load
     * @event
     */
      triggerEvent_(me, 'load');
    });
  }
  /**
   * @name GPOptions
   * @property {Object} [parameters] name-value pair of params. 
   * @property {Number|SpatialReference} [outSpatialReference] 
   * @property {Number|SpatialReference} [processSpatialReference] 
   */
  /**
   * execute a GeoProcessing task
   * @param {GPOptions} p
   * @param {Function} callback will pass {@link GPResults} 
   * @param {Function} errback pass in {@link Error}
   */
  GPTask.prototype.execute = function (p, callback, errback) {
    var params = {};
    if (p.parameters) {
      augmentObject_(p.parameters, params);
    }
    if (p.outSpatialReference) {
      params['env:outSR'] = formatSRParam_(p.outSpatialReference);
    } else {
      params['env:outSR'] = 4326;
    }
    if (p.processSpatialReference) {
      params['env:processSR'] = formatSRParam_(p.processSpatialReference);
    } 
    getJSON_(this.url + '/execute', params, '', function (json) {
      if (json.results) {
        var res, f;
        for (var i = 0; i < json.results.length; i++) {
          res = json.results[i];
          if (res.dataType === 'GPFeatureRecordSetLayer') {
            for (var j = 0, J = res.value.features.length; j < J; j++) {
              f = res.value.features[j];
              if (f.geometry) {
                f.geometry = fromJSONToOverlays_(f.geometry, p.overlayOptions);
              }
            }
          }
        }
      }
      callback(json);
      handleErr_(errback, json);
    });
  };
  
  /**
   * @name GPResults
   * @property {Array.string} messages
   * @property {Array.GPResult} results
   */
  /**
   * @name GPResult
   * @property {String} paramName
   * @property {String} dataType
   * @property {Object} value
   */
  /**
   * @name NetworkService
   * @class NetworkService
   * @constructor
   * @property {String} serviceDescription
   * @property {Array.string} routeLayers
   * @property {Array.string} serviceAreaLayers
   * @property {Array.string} closestFacilityLayers
   * @param {String} url http://[catalog-url]/[serviceName]/NAServer 
   */
  function NetworkService(url) {
    this.url = url;
    this.loaded_ = false;
    var me = this;
  getJSON_(url, {}, '', function(json) {
      augmentObject_(json, me);
      me.loaded_ = true;
     /**
     * This event is fired when the service and it's service info is loaded.
     * @name NetworkService#load
     * @event
     */
      triggerEvent_(me, 'load');
    });
  }

  /**
   * @name RouteOptions
   * @class intance that specify how a route should be solved.
   * @property {Array.google.maps.LatLng|Array.Marker} [stops] the locations the route must pass
   * @property {Array.google.maps.LatLng|Array.Marker} [barriers] the locations the route must avoid
   * @property {Boolean} [returnDirections] If true, directions will be generated and returned with the analysis results. Default is true
   * @property {Boolean} [returnRoutes] If true, routes will be returned with the analysis results. Default is true. 
   * @property {Boolean} [findBestSequence] If true, the solver should resequence the route in the optimal order. The default is as defined in the network layer. 
   * @property {Boolean} [preserveFirstStop] If true, the solver should resequence the route in the optimal order. The default is as defined in the network layer. 
   * @property {Boolean} [preserveLastStop] If true, the solver should resequence the route in the optimal order. The default is as defined in the network layer. 
   */
  /**
   * @name RouteResults
   * @class intance that specify the results of the solve operation.
   * @property {Array.google.maps.LatLng} [stops]
   */
  /**
   * Create a route task with the URL of the routing server resource.
   * @name RouteTask 
   * @class This class (<code>RouteTask</code>) represent a Network Layer resource deployed in a NetWorkService.
   * It can solve a route based on stops, barrier
   * @constructor
   * @param {String} url
   */
  function RouteTask(url) {
    this.url = url;
  }
  /**
   * Solve a route based on inputs such as stops and barriers. Result of type {@link RouteResults} 
   * is passed to Function callback, and error of type {@link Error} is passed to Function errback.
   * @param {RouteOptions} opt_Route
   * @param {Function} callback
   * @param {Function} errback
   */
  RouteTask.prototype.solve = function (opts, callback, errback) {
    if (!opts) {
      return;
    }
    // handle many other fields
    var params = augmentObject_(opts, {});
    //params['outSR'] = WGS84.wkid;
    if (isArray_(opts.stops)) {
      params.stops = fromLatLngsToFeatureSet_(opts.stops);
    }
    if (isArray_(opts.barriers)) {
      if (opts.barriers.length > 0) {
        params.barriers = fromLatLngsToFeatureSet_(opts.barriers);
      } else {
        delete params.barriers;
      }
    }
    params.returnRoutes = (opts.returnRoutes === false ? false : true);
    params.returnDirections = (opts.returnDirections === true ? true : false);
    params.returnBarriers = (opts.returnBarriers === true ? true : false);
    params.returnStops = (opts.returnStops === true ? true : false);
    
    getJSON_(this.url + '/solve', params, '', function (json) {
      if (json.routes) {
        parseFeatures_(json.routes.features, opts.overlayOptions);
      }
      callback(json);
      handleErr_(errback, json);
    });
  };
  
  
  /**
   * @name OverlayOptions
   * @class Instance of this classes that specify how
   *   the geometry features returned by ArcGIS server should be rendered in the browser.
   * @property {google.maps.MarkerOptions} [markerOptions] style option for points.
   * @property {google.maps.PolylineOptions} [polylineOptions] style option for polylines. <a href=http://code.google.com/apis/maps/documentation/javascript/reference.html#PolylineOptions>PolylineOptions</a>
   * @property {google.maps.PolygonOptions} [polygonOptions] style option for polygons. <a href=http://code.google.com/apis/maps/documentation/javascript/reference.html#PolygonOptions>PolygonOptions</a>
   * @property {Number} [strokeOpacity] The stroke opacity between 0.0 and 1.0
   * @property {Number} [fillOpacity] The fill opacity between 0.0 and 1.0
   * @property {String} [strokeColor] The stroke color in HTML hex style, ie. "#FFAA00"
   * @property {String} [fillColor] The fill color in HTML hex style, ie. "#FFAA00"
   * @property {Number} [strokeWeight] The stroke width in pixels.
   * @property {Number} [zIndex] The zIndex compared to other overlays.
   * @property {String|google.maps.MarkerImage} [icon] Icon for the foreground
   * @property {String|google.maps.MarkerImage} [shadow] Shadow image
   */
  /**
   * @name TileInfo
   * @class This class contains information about map tile infornation for a cached map service.
   *    <br/>There is no constructor for this class.
   * @property {Number} [rows] tile row size,  e.g. 512, must be same as cols
   * @property {Number} [cols] tile cols size,  e.g. 512, must be same as rows
   * @property {Number} [dpi] dot per inch for map tiles.
   * @property {String} [format] PNG8 | PNG24 | PNG32 | GIF | JPEG
   * @property {Number} [compressionQuality] JPEG only.0-100.
   * @property {Point} [origin] origin of tile system of type
   * @property {SpatialReference} [spatialReference] spatial reference.  <b>wkid info only</b>.
   * @property {Array.LOD} [lods] Array of Level of Details. See {@link LOD}
   */
  /**
   * @name LOD
   * @class This class contains information about one "Level Of Detail" for a cached map service.
   *   It is the type of {@link lods} property of {@link TileInfo}
   *   <br/>There is no constructor for this class. Use as object literal.
   * @property {Number} [level] zoom level.
   * @property {Number} [resolution] map unit per pixel
   * @property {Number} [scale] actual map scale. e.g a value of 5000 means 1:5000 scale.
   */
  /**
   * Creates an ArcGIS Map Tiling Reference System.
   * <ul>
   * <li><code>tileInfo</code> tiling information. An instance of {@link TileInfo}
   * </ul>Applications normally do not create instances of this class directly.
   * @name Projection
   * @implements {google.maps.Projection}
   * @constructor
   * @class This class (<code>Projection</code>) implements a custom
   * <a href  = 'http://code.google.com/apis/maps/documentation/javascript/reference.html#Projection'>google.maps.Projection</a>
   * from the core Google Maps API.
   *   It includes a real {@link SpatialReference} object to convert LatLng from/to
   *   map coordinates, and tiling scheme informations to convert
   *   map coordinates from/to pixel coordinates.
   * @param {TileInfo} tileInfo
   */
  function Projection(tileInfo) {
    //if (!tileInfo) {
    //  throw new Error('map service is not tiled');
    //}
    this.lods_ = tileInfo ? tileInfo.lods : null;
    this.spatialReference_ = tileInfo ? spatialReferences_[tileInfo.spatialReference.wkid || tileInfo.spatialReference.wkt] : WEB_MERCATOR;
    if (!this.spatialReference_) {
      throw new Error('unsupported Spatial Reference');
    }
    // resolution (unit/pixel) at lod level 0. Due to changes from V2-V3, 
    // zoom is no longer defined in Projection. It is assumed that level's zoom factor is 2. 
    this.resolution0_ = tileInfo ? tileInfo.lods[0].resolution : 156543.033928;
    // zoom offset of this tileinfo's zoom 0 to Google's zoom0
    this.minZoom = Math.floor(Math.log(this.spatialReference_.getCircum() / this.resolution0_ / 256) / Math.LN2 + 0.5);
    this.maxZoom = tileInfo ? this.minZoom + this.lods_.length - 1 : 20;
    if (G.Size) {
      this.tileSize_ = tileInfo ? new G.Size(tileInfo.cols, tileInfo.rows) : new G.Size(256, 256);
    }
    // Find out how the map units scaled to 1 tile at zoom 0. 
    // from V2-V3, coords must scaled to 256 pixel under Mercator at zoom 0.
    // scale can be considered under this SR, what's the actual pixel number to 256 to cover whole earth?
    this.scale_ = Math.pow(2, this.minZoom) * this.resolution0_;
    this.originX_ = tileInfo ? tileInfo.origin.x : -20037508.342787;
    this.originY_ = tileInfo ? tileInfo.origin.y : 20037508.342787;
    // validation check
    if (tileInfo) {
      var ratio;
      for (var i = 0; i < tileInfo.lods.length - 1; i++) {
        ratio = tileInfo.lods[i].resolution / tileInfo.lods[i + 1].resolution;
        if (ratio > 2.001 || ratio < 1.999) {
          throw new Error('This type of map cache is not supported in V3. \nScale ratio between zoom levels must be 2');
        }
      }
    }
  }
  
  /**
   * See <a href  = 'http://code.google.com/apis/maps/documentation/javascript/reference.html#Projection'>google.maps.Projection</a>.
   * @param {LatLng} gLatLng
   * @param {Point} opt_point
   * @return {Point} pixel
   */
  Projection.prototype.fromLatLngToPoint = function (latlng, opt_point) {
    if (!latlng || isNaN(latlng.lat()) || isNaN(latlng.lng())) {
      return null;
    }
    var coords = this.spatialReference_.forward([latlng.lng(), latlng.lat()]);
    var point = opt_point || new G.Point(0, 0);
    point.x = (coords[0] - this.originX_) / this.scale_;
    point.y = (this.originY_ - coords[1]) / this.scale_;
    return point;
  };
  // somehow externs was ignored in adv mode.
  Projection.prototype['fromLatLngToPoint'] = Projection.prototype.fromLatLngToPoint;
  /**
   * See <a href  = 'http://code.google.com/apis/maps/documentation/javascript/reference.html#Projection'>google.maps.Projection</a>.
   * @param {Point} pixel
   * @param {Boolean} opt_nowrap
   * @return {LatLng}
   */
  Projection.prototype.fromPointToLatLng = function (pixel, opt_nowrap) {
    //TODO: handle nowrap
    if (pixel === null) {
      return null;
    }
    var x = pixel.x * this.scale_ + this.originX_;
    var y = this.originY_ - pixel.y * this.scale_;
    var geo = this.spatialReference_.inverse([x, y]);
    return new G.LatLng(geo[1], geo[0]);
  };
  //Projection.prototype['fromLatLngToPoint'] = Projection.prototype.fromLatLngToPoint;
  /**
   * Get the scale at given level;
   * @param {Number} zoom
   * @return {Number}
   */
  Projection.prototype.getScale = function (zoom) {
    var zoomIdx = zoom - this.minZoom;
    var res = 0;
    if (this.lods_[zoomIdx]) {
      res = this.lods_[zoomIdx].scale;
    }
    return res;
  };
  
  Projection.WEB_MECATOR = new Projection();
  /**
   * @name TileLayerOptions
   * @class Instances of this class are used in the {@link opt_layerOpts} argument
   *   to the constructor of the {@link TileLayer} class.
   * @property {String} [hosts] host pattern of tile servers if they are numbered. Most browser
   *   has default restrictions on how many concurrent connections can be made to
   *   a single host. One technique to workaround this is to create multiple hosts and rotate them when
   *   loading tiles.
   *   The syntax is <code>prefix[<i>numberOfHosts</i>]suffix</code>, for example, <code>"mt[4].google.com"</code> means
   *   rotate hosts in <code>mt0.google.com, mt1.google.com, mt2.google.com, mt3.google.com</code> (4 hosts).
   * @property {Number} [minZoom] min zoom level.
   * @property {Number} [maxZoom] max zoom level.
   * @property {Number} [opacity] opacity (0-1).
   */
  /** Creates a tile layer from a cached by ArcGIS map service. 
   * <br/> <code> service</code> (required) is the underline {@link MapService}
   * <br/> <code>opt_layerOpts</code> (optional) is an instance of {@link TileLayerOptions}.
   * @name TileLayer
   * @constructor
   * @class This class (<code>TileLayer</code>) provides access to a cached ArcGIS Server
   * map service. There is no <code>GTileLayer</code> class in Google Maps API V3, this class is kept to allow
   * finer control of zoom levels for each individual tile sets within a map type, such as zoom level range and opacity.
   * @param {MapService} service
   * @param {TileLayerOptions} opt_layerOpts
   */
  function TileLayer(service, opt_layerOpts) {
    opt_layerOpts = opt_layerOpts || {};
    if (opt_layerOpts.opacity) {
      this.opacity_ = opt_layerOpts.opacity;
      delete opt_layerOpts.opacity;
    }
    augmentObject_(opt_layerOpts, this);
    this.mapService_ = (service instanceof MapService) ? service : new MapService(service);
    //In the format of mt[number].domain.com
    if (opt_layerOpts.hosts) {
      var pro = extractString_(this.mapService_.url, '', '://');
      var host = extractString_(this.mapService_.url, '://', '/');
      var path = extractString_(this.mapService_.url, pro + '://' + host, '');
      this.urlTemplate_ = pro + '://' + opt_layerOpts.hosts + path;
      this.numOfHosts_ = parseInt(extractString_(opt_layerOpts.hosts, '[', ']'), 10);
    }
    this.name = opt_layerOpts.name || this.mapService_.name;
    this.maxZoom = opt_layerOpts.maxZoom || 19;
    this.minZoom = opt_layerOpts.minZoom || 0;
    this.dynaZoom = opt_layerOpts.dynaZoom || this.maxZoom;
    if (this.mapService_.loaded_) {
      this.init_(opt_layerOpts);
    } else {
      var me = this;
      G.event.addListenerOnce(this.mapService_, 'load', function () {
        me.init_(opt_layerOpts);
      });
    }
    this.tiles_ = {};
    this.map_ = opt_layerOpts.map;
  }
  
  /**
   * Initialize the tile layer from a loaded map service
   * @param {Object} opt_layerOpts
   */
  TileLayer.prototype.init_ = function (opt_layerOpts) {
    if (this.mapService_.tileInfo) {
      this.projection_ = new Projection(this.mapService_.tileInfo);
      this.minZoom = opt_layerOpts.minZoom || this.projection_.minZoom;
      this.maxZoom = opt_layerOpts.maxZoom || this.projection_.maxZoom;
    }
  };
  
  
  /**
   * Returns a string (URL) for given tile coordinate (x, y) and zoom level
   * @private not meant to be called by client
   * @param {Object} tile
   * @param {Number} zoom
   * @return {String} url
   */
  TileLayer.prototype.getTileUrl = function (tile, zoom) {
    var z = zoom - (this.projection_ ? this.projection_.minZoom : this.minZoom);
    var url = '';
    if (!isNaN(tile.x) && !isNaN(tile.y) && z >= 0 && tile.x >= 0 && tile.y >= 0) {
      var u = this.mapService_.url;
      if (this.urlTemplate_) {
        u = this.urlTemplate_.replace('[' + this.numOfHosts_ + ']', '' + ((tile.y + tile.x) % this.numOfHosts_));
      }
      var prj = this.projection_ || (this.map_ ? this.map_.getProjection() : Projection.WEB_MECATOR);
      if (!prj instanceof Projection) {
        // if use Google's image 
        prj = Projection.WEB_MECATOR;
      }
      var size = prj.tileSize_;
      var numOfTiles = 1 << zoom;
      var gworldsw = new G.Point(tile.x * size.width / numOfTiles, (tile.y + 1) * size.height / numOfTiles);
      var gworldne = new G.Point((tile.x + 1) * size.width / numOfTiles, tile.y * size.height / numOfTiles);
      var bnds = new G.LatLngBounds(prj.fromPointToLatLng(gworldsw), prj.fromPointToLatLng(gworldne));
      var fullBounds = this.mapService_.getFullBounds();
      if (this.mapService_.singleFusedMapCache === false || zoom > this.dynaZoom) {
        // dynamic map service
        var params = {
        'f': 'image'
        };
        params.bounds = bnds;
        params.format = 'png32';
        params.width = size.width;
        params.height = size.height;
        params.imageSR = prj.spatialReference_;
        url = this.mapService_.exportMap(params);
      } else if (fullBounds && !fullBounds.intersects(bnds)){
        url = '';
      } else {
        url = u + '/tile/' + z + '/' + tile.y + '/' + tile.x;
      }
    }
    //log_('url=' + url);
    return url;
  };
  /**
   * set Opacity
   * @param {Number} op (0-1)
   */
  TileLayer.prototype.setOpacity = function (op) {
    this.opacity_ = op;
    var tiles = this.tiles_;
    for (var x in tiles) {
      if (tiles.hasOwnProperty(x)) {
        setNodeOpacity_(tiles[x], op);
      }
    }
  };
  /**
   * get the opacity (0-1) of the tile layer
   * @return {Number}
   */
  TileLayer.prototype.getOpacity = function () {
    return this.opacity_;
  };
  /**
   * get the underline {@link MapService}
   * @return {MapService}
   */
  TileLayer.prototype.getMapService = function () {
    return this.mapService_;
  };
  /**
   * @name MapTypeOptions
   * @class Instance of this class are used in the {@link opt_typeOpts} argument
   *  to the constructor of the {@link MapType} class. See
   *  <a href=http://code.google.com/apis/maps/documentation/javascript/reference.html#MapType>google.maps.MapType</a>.
   * @property {String} [name] map type name
   * @property {Projection} [projection] an instance of {@link Projection}.
   * @property {String} [alt] Alt text to display when this MapType's button is hovered over in the MapTypeControl. Optional.
   * @property {Number} [maxZoom] The maximum zoom level for the map when displaying this MapType. Required for base MapTypes, ignored for overlay MapTypes.
   * @property {Number} [minZoom] The minimum zoom level for the map when displaying this MapType. Optional; defaults to 0.
   * @property {google.maps.Size} [tileSize] The dimensions of each tile.
   */
  // * @property {Number} [radius] Radius of the planet for the map, in meters. Optional; defaults to Earth's equatorial radius of 6378137 meters.
  /**
   * Creates a MapType, with a array of {@link TileLayer}s, or a single URL as shortcut.
   * @name MapType
   * @constructor
   * @class This class implements the Google Maps API's
   * <a href  = http://code.google.com/apis/maps/documentation/javascript/reference.html#MapType>GMapType</a>.
   * It holds a list of {@link TileLayer}s.
   * <p> Note: all tiled layer in the same map type must use same spatial reference and tile scheme.</p>
   * @param {Array.TileLayer|String} tileLayers
   * @param {MapTypeOptions} opt_typeOpts
   */
  function MapType(tileLayers, opt_typeOpts) {
    
    opt_typeOpts = opt_typeOpts || {};
    var i;
    if (opt_typeOpts.opacity) {
      this.opacity_ = opt_typeOpts.opacity;
      delete opt_typeOpts.opacity;
    }
    augmentObject_(opt_typeOpts, this);
    var layers = tileLayers;
    if (isString_(tileLayers)) {
      layers = [new TileLayer(tileLayers, opt_typeOpts)];
    } else if (tileLayers instanceof MapService) {
      layers = [new TileLayer(tileLayers, opt_typeOpts)];
    } else if (tileLayers instanceof TileLayer) {
      layers = [tileLayers];
    } else if (tileLayers.length > 0 && isString_(tileLayers[0])) {
      layers = [];
      for (i = 0; i < tileLayers.length; i++) {
        layers[i] = new TileLayer(tileLayers[i], opt_typeOpts);
      }
    }
    this.tileLayers_ = layers;
    this.tiles_ = {};
    if (opt_typeOpts.maxZoom !== undefined) {
      this.maxZoom = opt_typeOpts.maxZoom;
    } else {
      var maxZ = 0;
      for (i = 0; i < layers.length; i++) {
        maxZ = Math.max(maxZ, layers[i].maxZoom);
      }
      this.maxZoom = maxZ;
    }
    if (layers[0].projection_) {
      this.tileSize = layers[0].projection_.tileSize_;
      this.projection = layers[0].projection_;
    } else {
      this.tileSize = new G.Size(256, 256);
    }
    if (!this.name) {
      this.name = layers[0].name;
    }
    
  }
  
  /**
   * Get a tile for given tile coordinates Returns a tile for the given tile coordinate (x, y) and zoom level.
   * This tile will be appended to the given ownerDocument.
   * @private not meant to be called directly.
   * @param {Point} tileCoord
   * @param {Number} zoom
   * @return {Node}
   */
  MapType.prototype.getTile = function (tileCoord, zoom, ownerDocument) {
    var div = ownerDocument.createElement('div');
    var tileId = '_' + tileCoord.x + '_' + tileCoord.y + '_' + zoom;
    for (var i = 0; i < this.tileLayers_.length; i++) {
      var t = this.tileLayers_[i];
      if (zoom <= t.maxZoom && zoom >= t.minZoom) {
        var url = t.getTileUrl(tileCoord, zoom);
        if (url) {
          var img = ownerDocument.createElement(document.all ? 'img' : 'div');//IE does not like img
          img.style.border = '0px none';
          img.style.margin = '0px';
          img.style.padding = '0px';
          img.style.overflow = 'hidden';
          img.style.position = 'absolute';
          img.style.top = '0px';
          img.style.left = '0px';
          img.style.width = '' + this.tileSize.width + 'px';
          img.style.height = '' + this.tileSize.height + 'px';
          //log_(url);
          if (document.all) {
            img.src = url;
          } else {
            img.style.backgroundImage = 'url(' + url + ')';
          }
          div.appendChild(img);
          t.tiles_[tileId] = img;
          if (t.opacity_ !== undefined) {
            setNodeOpacity_(img, t.opacity_);
          } else if (this.opacity_ !== undefined) {
            // in FF it's OK to set parent div just once but IE does not like it.
            setNodeOpacity_(img, this.opacity_);
          }
        } else {
          // TODO: use a div to display NoData
        }
      }
    }
    this.tiles_[tileId] = div;
    div.setAttribute('tid', tileId);
    return div;
  };
  MapType.prototype['getTile'] = MapType.prototype.getTile;
  /**
   * Release tile and cleanup
   * @private not meant to be called directly.
   * @param {Node} node
   */
  MapType.prototype.releaseTile = function (node) {
    if (node.getAttribute('tid')) {
      var tileId = node.getAttribute('tid');
      if (this.tiles_[tileId]) {
        delete this.tiles_[tileId];
      }
      for (var i = 0; i < this.tileLayers_.length; i++) {
        var t = this.tileLayers_[i];
        if (t.tiles_[tileId]) {
          delete t.tiles_[tileId];
        }
      }
    }
  };
   MapType.prototype['releaseTile'] = MapType.prototype.releaseTile;
  /**
   * Set Opactity
   * @param {Number} op
   */
  MapType.prototype.setOpacity = function (op) {
    this.opacity_ = op;
    var tiles = this.tiles_;
    for (var x in tiles) {
      if (tiles.hasOwnProperty(x)) {
        var nodes = tiles[x].childNodes;
        for (var i = 0; i < nodes.length; i++) {
          setNodeOpacity_(nodes[i], op);
        }
      }
    }
  };
  /**
   * get opacity
   * @return {Number}
   */
  MapType.prototype.getOpacity = function () {
    return this.opacity_;
  };
  /**
   * get list of {@link TileLayer} in this map type
   * @return {Array.TileLayer}
   */
  MapType.prototype.getTileLayers = function () {
    return this.tileLayers_;
  };
 

  
  /**
   * @name MapOverlayOptions
   * @class Instance of this class are used in the {@link opt_ovelayOpts} argument
   *  to the constructor of the {@link MapOverlay} class.
   * @property {Number} [opacity  = 1.0] Opacity of map image from 0.0 (invisible) to 1.0 (opaque)
   * @property {ExportMapOptions} [exportOptions] See {@link ExportMapOptions}
   * @property {google.maps.Map} [map] map to attach to.
   */
  /**
   * Creates an Map Overlay using <code>url</code> of the map service and optional {@link MapOverlayOptions}.
   * <li/> <code> service</code> (required) is url of the underline {@link MapService} or the MapService itself.
   * <li/> <code>opt_overlayOpts</code> (optional) is an instance of {@link MapOverlayOptions}.
   * @name MapOverlay
   * @class This class (<code>MapOverlay</code>) extends the Google Maps API's
   * <a href  = http://code.google.com/apis/maps/documentation/reference.html#OverlayView>OverlayView</a>
   * that draws map images from data source on the fly. It is also known as "<b>Dynamic Maps</b>".
   * It can be added to the map via <code>setMap(map) </code> method.
   * The similar class in the core Map API is <a href  = http://code.google.com/apis/maps/documentation/javascript/reference.html#GroundOverlay>google.maps.GroundOverlay</a>,
   * however, the instance of this class always cover the viewport exactly, and will redraw itself as map moves.
   * @constructor
   * @param {String|MapService} service
   * @param {MapOverlayOptions} opt_overlayOpts
   */
  function MapOverlay(service, opt_overlayOpts) {
    opt_overlayOpts = opt_overlayOpts || {};
    this.mapService_ = (service instanceof MapService) ? service : new MapService(service);
    
    this.minZoom  = opt_overlayOpts.minZoom;
    this.maxZoom  = opt_overlayOpts.maxZoom;
    this.opacity_ = opt_overlayOpts.opacity || 1;
    this.exportOptions_ = opt_overlayOpts.exportOptions || {};
    this.drawing_ = false;
    // do we need another refresh. Normally happens bounds changed before server returns image.
    this.needsNewRefresh_ = false;
    this.overlay_ = null;
    this.div_ = null;
    // Once the LatLng and text are set, add the overlay to the map.  This will
    // trigger a call to panes_changed which should in turn call draw.
    if (opt_overlayOpts.map) {
      this.setMap(opt_overlayOpts.map);
    }
    this.map_ = null;
    this.listeners_= [];
  }

  MapOverlay.prototype = new G.OverlayView();
  /**
   * Called by API not by app code.
   * Handler when overlay is added. Interface method.
   * This will be called after setMap(map) is called.
   */
  MapOverlay.prototype.onAdd = function() {
    var me = this;
    this.listeners_.push(G.event.addListener(this.getMap(), 'bounds_changed', callback_(this.refresh, this)));
    this.listeners_.push(G.event.addListener(this.getMap(), 'dragstart', function(){
      me.dragging = true; 
    }));
    this.listeners_.push(G.event.addListener(this.getMap(), 'dragend', function(){
      me.dragging = false; 
    }));
    var map = this.getMap();
    map.agsOverlays = map.agsOverlays || new G.MVCArray();
    map.agsOverlays.push(this);
    setCopyrightInfo_(map);
    this.map_ = map;
  };
  MapOverlay.prototype['onAdd'] = MapOverlay.prototype.onAdd;
  /** 
   * Called by API not by app code.
   * Handler when overlay is removed.
   */
  MapOverlay.prototype.onRemove = function() {
    for (var i = 0, j = this.listeners_.length; i < j; i++){
      G.event.removeListener(this.listeners_[i]);
    }
    //G.event.removeListener(this.zoomChangedListener_);
    //this.div_.parentNode.removeChild(this.div_);
    //this.div_ = null;
    if (this.overlay_) this.overlay_.setMap(null);
    var map = this.map_;// getMap();
    var agsOvs = map.agsOverlays;
    if (agsOvs) {
      for (var i = 0, c = agsOvs.getLength(); i < c; i++) {
        if (agsOvs.getAt(i) == this) {
          agsOvs.removeAt(i);
          break;
        }
      }
    }
    setCopyrightInfo_(map);
    this.map_ = null;
  };
  MapOverlay.prototype['onRemove'] = MapOverlay.prototype.onRemove;
  /**
   * Called by API not by app code.
   * See OverlayView.draw in core API docs.
   */
  MapOverlay.prototype.draw = function () {
    if (!this.drawing_ || this.needsNewRefresh_ === true) {
      this.refresh(); 
    }
  };

  MapOverlay.prototype['draw'] = MapOverlay.prototype.draw;
  /**
   * Gets Image Opacity. return <code>opacity</code> between 0-1.
   * @return {Number} opacity
   */
  MapOverlay.prototype.getOpacity = function () {
    return this.opacity_;
  };
  /**
   * Sets Image Opacity. parameter <code>opacity</code> between 0-1.
   * @param {Number} opacity
   */
  MapOverlay.prototype.setOpacity = function (opacity) {
    var op = Math.min(Math.max(opacity, 0), 1);
    this.opacity_ = op;
    if (this.overlay_) {
      setNodeOpacity_(this.overlay_.div_, op);
    }
  };
  /**
   * Gets underline {@link MapService}.
   * @return {MapService} MapService
   */
  MapOverlay.prototype.getMapService = function () {
    return this.mapService_;
  };
  /**
   * Refresh the map image in current view port.
   */
  MapOverlay.prototype.refresh = function () {
    if (this.drawing_ === true) {
      this.needsNewRefresh_ = true;
      return;
    }
    var m = this.getMap();
    var bnds = m ? m.getBounds() : null;
    if (!bnds) {
      return;
    }
    var params = this.exportOptions_;
    params.bounds = bnds;
    var sr = WEB_MERCATOR;
    // V3 no map.getSize()
    var s = m.getDiv();
    params.width = s.offsetWidth;
    params.height = s.offsetHeight;
    if (s.offsetWidth == 0 || s.offsetHeight ==0){
      return;
    }
    var prj = m.getProjection(); // note this is not same as this.getProjection which returns MapCanvasProjection
    if (prj && prj instanceof Projection) {
      sr = prj.spatialReference_;
    }
    params.imageSR = sr;
    /**
     * This event is fired before the the drawing request was sent to server.
     * @name MapOverlay#drawstart
     * @event
     */
    triggerEvent_(this, 'drawstart');
    var me = this;
    this.drawing_ = true;
    if (!this.dragging && this.overlay_){
      this.overlay_.setMap(null);
      this.overlay_ = null;
    }
    //this.div_.style.backgroundImage = '';
    
    this.mapService_.exportMap(params, function (json) {
      me.drawing_ = false;
      
      if (me.needsNewRefresh_ === true) {
        me.needsNewRefresh_ = false;
        me.refresh();
        return;
      }
      if (json.href) {
        if (me.overlay_) {
          me.overlay_.setMap(null);
          me.overlay_ = null;
        }
       me.overlay_ = new ImageOverlay(json.bounds, json.href, me.map_, me.opacity_);
       
      }
      /**
       * This event is fired after the the drawing request was returned by server.
       * @name MapOverlay#drawend
       * @event
       */
      triggerEvent_(me, 'drawend');
    });
  };
  

  /**
   * Check if the overlay is visible, and within zoomzoom range and current map bounds intersects with it's fullbounds.
   * @return {Boolean} visible
   */
  MapOverlay.prototype.isHidden = function () {
    return !(this.visible_ && this.isInZoomRange_());
  };
  /**
   * If this in zoom range
   * @private
   * @return {Boolean}
   */
  MapOverlay.prototype.isInZoomRange_ = function () {
    var z = this.getMap().getZoom();
    if ((this.minZoom !== undefined && z < this.minZoom) ||
    (this.maxZoom !== undefined && z > this.maxZoom)) {
      return false;
    }
    return true;
  };
  
  /**
   * Makes the overlay visible.
   */
  MapOverlay.prototype.show = function () {
    this.visible_ = true;
    this.div_.style.visibility = 'visible';
    this.refresh();
  };
  /**
   * Hide the overlay
   */
  MapOverlay.prototype.hide = function () {
    this.visible_ = false;
    this.div_.style.visibility = 'hidden';
  };
  
  /**
   * @class simply an image overaly. Added due to some unknown problems related to 
   * overlayLayer pane after bounds change since gmaps API v3.4. 
   * this class is based on sample code USGSOverlay
   * @constructor
   * @param {Object} bounds
   * @param {Object} url
   * @param {Object} map
   */
  function ImageOverlay(bounds, url, map, op) {
    this.bounds_ = bounds;
    this.url_ = url;
    this.map_ = map;
    this.div_ = null;
    this.op_ = op;
    this.setMap(map);
  }
  
  ImageOverlay.prototype = new G.OverlayView();
  ImageOverlay.prototype.onAdd = function() {
    var div = document.createElement('DIV');
    div.style.border = "none";
    div.style.borderWidth = "0px";
    div.style.position = "absolute";
    div.style.backgroundImage = 'url(' + this.url_ + ')';
    
    // Set the overlay's div_ property to this DIV
    this.div_ = div;
    
    // We add an overlay to a map via one of the map's panes.
    // We'll add this overlay to the overlayImage pane.
    var panes = this.getPanes();
    setNodeOpacity_(div, this.op_);
    panes.overlayLayer.appendChild(div);
  };
  ImageOverlay.prototype.draw = function() {
  
    // Size and position the overlay. We use a southwest and northeast
    // position of the overlay to peg it to the correct position and size.
    // We need to retrieve the projection from this overlay to do this.
    var overlayProjection = this.getProjection();
    
    // Retrieve the southwest and northeast coordinates of this overlay
    // in latlngs and convert them to pixels coordinates.
    // We'll use these coordinates to resize the DIV.
    var sw = overlayProjection.fromLatLngToDivPixel(this.bounds_.getSouthWest());
    var ne = overlayProjection.fromLatLngToDivPixel(this.bounds_.getNorthEast());
    
    // Resize the image's DIV to fit the indicated dimensions.
    var div = this.div_;
    div.style.left = sw.x + 'px';
    div.style.top = ne.y + 'px';
    div.style.width = (ne.x - sw.x) + 'px';
    div.style.height = (sw.y - ne.y) + 'px';
  };
  ImageOverlay.prototype.onRemove = function() {
    this.div_.parentNode.removeChild(this.div_);
    this.div_ = null;
  }
  /**
 * Creates a copyright control
 * @name CopyrightControl
 * @class put a copyright notice at bottom rigth corner.
 * @constructor
 * @param {google.maps.Map} map
 */
  function CopyrightControl(map){
    // reason to put div creation out is allow MapOverlay tigger it if this control is not created.
    this.map_ = map;
    setCopyrightInfo_(map);
  }
  
  /**
   * refresh copyright text 
   */
  CopyrightControl.prototype.refresh = function(){
    setCopyrightInfo_(this.map_);
  };
  
  gmaps.ags = {
    SpatialReference: SpatialReference,
    Geographic: Geographic,
    LambertConformalConic: LambertConformalConic,
    SphereMercator: SphereMercator,
    TransverseMercator: TransverseMercator,
    SpatialRelationship: SpatialRelationship,
    GeometryType: GeometryType,
    SRUnit : SRUnit,
    Catalog: Catalog,
    MapService: MapService,
    Layer: Layer,
    GeocodeService: GeocodeService,
    GeometryService: GeometryService,
    GPService: GPService,
    GPTask: GPTask,
    RouteTask: RouteTask,
    Util: Util,
    Config: Config,
    Projection: Projection,
    TileLayer: TileLayer,
    MapOverlay: MapOverlay,
    MapType: MapType,
    CopyrightControl:CopyrightControl
  };

window.gmaps = gmaps; })()  



 /* Build Time: Oct 1, 2014 12:39:13 */ globalConfig = {};
globalConfig.language = "EN";
//globalConfig.searchHelpTxt = "Zoom in, or Search with Watershed, Permit Holder Name, Address.";
//globalConfig.searchHelpTxt = "You may search by <strong>watershed</strong>, <strong>permit holder name</strong> or <strong>address</strong>.";
//globalConfig.tableSimpleTemplateTitleLang = "Note: The Distance(KM) column represents the distance between your search location and the permit location in the specific row. Data is in English only.";
//globalConfig.tableSimpleTemplateTitleLang = "Note: Data is in English only.";
//globalConfig.tableSimpleTemplateTitleLang = "The following table contains the records with valid coordinates.";
globalConfig.otherInfoHTML = ""; 


/*
globalConfig.searchControlHTML = '<center><input id = "map_query" type="text" size="50" onkeypress="return globalConfig.entsub(event)" maxlength="100"></input>\
	&nbsp;&nbsp;<input type="submit" onclick="globalConfig.search()" value="Search"></input>&nbsp;&nbsp;\
	<br>\
	<input id = "searchWatershed" type="radio" name="searchGroup" value="watershed" onclick="globalConfig.searchChange(\'Watershed\')">Watershed\
	<input id = "searchBusiness" type="radio" name="searchGroup" value="business" onclick="globalConfig.searchChange(\'Business\')">Permit Holder Name\
	<input id = "searchLocation" type="radio" name="searchGroup" value="location" onclick="globalConfig.searchChange(\'Location\')">Address with Radius of\
		<select name="searchCriteria.radius" id="lstRadius">\
	   	 					<option value="1" >1 km</option>\
	   	 					<option value="2" >2 km</option>\
	   	 					<option value="5" >5 km</option>\
	   	 					<option value="10" >10 km</option>\
							<option value="25" >25 km</option>\
							<option value="50" >50 km</option>\
						</select>\
	<div id="information" style="color:#0000FF">' + globalConfig.searchHelpTxt + '</div></center>';
*///globalConfig.url = "http://www.appliomapss.lrc.gov.on.ca/ArcGIS/rest/services/MOE/PTTW_Search/MapServer"; //LRC staging
globalConfig.url = "http://www.appliomaps.lrc.gov.on.ca/ArcGIS/rest/services/MOE/PTTW_Search/MapServer";  //LRC production
//globalConfig.url = "http://lrcdrrvsdvap002/ArcGIS/rest/services/Interactive_Map_Public/PTTW_Search1/MapServer";

globalConfig.InformationLang = "Information";
globalConfig.chooseLang = function (en, fr) {return (globalConfig.language === "EN") ? en : fr;};
globalConfig.searchableFieldsList = [{en: "watershed", fr: "bassin versant"}, {en: "permit holder name", fr: "nom du titulaire de permis"}, {en: "address", fr: "adresse"}];
globalConfig.searchHelpTxt = globalConfig.chooseLang("You may search by ", "Vous pouvez rechercher par ");
for(var i=0; i<globalConfig.searchableFieldsList.length - 1; i++) {
	globalConfig.searchHelpTxt = globalConfig.searchHelpTxt + "<strong>" + globalConfig.chooseLang(globalConfig.searchableFieldsList[i].en, globalConfig.searchableFieldsList[i].fr) + "</strong>, ";
}
globalConfig.searchHelpTxt = globalConfig.searchHelpTxt + "<strong>" + globalConfig.chooseLang(globalConfig.searchableFieldsList[i].en, globalConfig.searchableFieldsList[i].fr) + "</strong> " + globalConfig.chooseLang("or see help for advanced options.", "ou consulter l'aide pour de l'information sur les recherches avanc&eacute;es.");
globalConfig.tableSimpleTemplateTitleLang = globalConfig.chooseLang("Note: Data is in English only.", "\u00c0 noter : les donn\u00e9es sont en anglais seulement.");

globalConfig.searchControlHTML = '<div id="searchTheMap"></div><div id="searchHelp"></div><br><label class="element-invisible" for="map_query">' + globalConfig.chooseLang('Search the map', 'Recherche carte interactive') + '</label>\
	<input id="map_query" type="text" title="' + globalConfig.chooseLang('Search term', 'Terme de recherche') + '" maxlength="100" size="50" onkeypress="return globalConfig.entsub(event)"></input>\
	<label class="element-invisible" for="search_submit">' + globalConfig.chooseLang('Search', 'Recherche') + '</label>\
	<input id="search_submit" type="submit" title="' + globalConfig.chooseLang('Search', 'Recherche') + '" onclick="globalConfig.search()" value="' + globalConfig.chooseLang('Search', 'Recherche') + '"></input>\
	<fieldset>\
		<input type="radio" id="searchWatershed" name="searchGroup" title="' + globalConfig.chooseLang('Watershed', "Bassin versant") + '" name="watershed" value="watershed" onclick="globalConfig.searchChange(\'Watershed\')"></input>\
		<label class="option" for="watershed">\
			' + globalConfig.chooseLang('Watershed', "Bassin versant") + '\
		</label>\
		<input type="radio" id="searchBusiness" name="searchGroup" title="' + globalConfig.chooseLang('Permit Holder Name', "Nom du titulaire de permis") + '" name="business" value="business" onclick="globalConfig.searchChange(\'Business\')"></input>\
		<label class="option" for="business">\
			' + globalConfig.chooseLang('Permit Holder Name', "Nom du titulaire de permis") + '\
		</label>\
		<input type="radio" id="searchLocation" name="searchGroup" title="' + globalConfig.chooseLang('Address with Radius of', "Adresse dans un rayon de") + '" name="location" value="location" onclick="globalConfig.searchChange(\'Location\')"></input>\
		<label class="option" for="location">\
			' + globalConfig.chooseLang('Address with Radius of', "Adresse dans un rayon de") + '\
			<select name="searchCriteria.radius" id="lstRadius">\
				<option value="1" >1 km</option>\
				<option value="2" >2 km</option>\
				<option value="5" >5 km</option>\
				<option value="10" >10 km</option>\
				<option value="25" >25 km</option>\
				<option value="50" >50 km</option>\
			</select>\
		</label>\
	</fieldset>\
<div id="information"></div>';

if (globalConfig.accessible) {
	globalConfig.usePredefinedMultipleTabs = false;
} else {
	globalConfig.usePredefinedMultipleTabs = true;
}

globalConfig.infoWindowWidth = '560px';
globalConfig.infoWindowHeight = '200px';
globalConfig.infoWindowContentHeight = '160px';

globalConfig.isRoutingServiceAvailable = false;
globalConfig.displayDisclaimer = true;
if (globalConfig.language === "EN") {
	globalConfig.fieldNamesList = [
		"Permit Number", 
		"Permit Holder Name", 
		"Purpose", 
		"Specific Purpose", 
		"Max Litres per Day", 
		"Source Type"
	];
} else {
	globalConfig.fieldNamesList = [
		"Num\u00e9ro du permis", 
		"Nom du titulaire de permis", 
		"Raison", 
		"Raison particuli\u00e8re", 
		"Litres (max. par jour)",
		"Type de source"
	];
}
if (globalConfig.accessible) {
	globalConfig.queryLayerList = [{
		url: globalConfig.url + "/0",
		tableTemplate: {
			title: globalConfig.tableSimpleTemplateTitleLang, 
			content: "<tr><td>{PERMITNO}</td><td>{CLIENTNAME}</td><td>{PURPOSECAT}</td><td>{SPURPOSE}</td><td>{MAXL_DAY}</td><td>{SURFGRND}</td></tr>",
			head: "<table class='fishTable'  border='1'><tr><th class='shaded'><center>" + globalConfig.fieldNamesList.join("</center></th><th class='shaded'><center>") + "</center></th></tr>",
			tail: "</table>"			
		} 
	}];
	globalConfig.postConditionsCallbackName = "AccessibleWells";
} else {
	globalConfig.tableFieldList = [
		{name: globalConfig.fieldNamesList[0], value: "{PERMITNO}"}, 
		{name: globalConfig.fieldNamesList[1], value: "{CLIENTNAME}"}, 
		{name: globalConfig.fieldNamesList[2], value: "{PURPOSECAT}"}, 
		{name: globalConfig.fieldNamesList[3], value: "{SPURPOSE}"}, 
		{name: globalConfig.fieldNamesList[4], value: "{MAXL_DAY}"}, 
		{name: globalConfig.fieldNamesList[5], value: "{SURFGRND}"}
	];

	globalConfig.queryLayerList = [{
		url: globalConfig.url + "/0",
		tabsTableTemplate: [{
			label: globalConfig.InformationLang,
			content:globalConfig.tableFieldList
		}], 
		tableSimpleTemplate: {
			title: globalConfig.tableSimpleTemplateTitleLang, 
			content: globalConfig.tableFieldList
		} 
	}];
}
	globalConfig.watershedNames = ["Agawa","Albany - Mouth","Arrow","Atikameg","Ausable","Big Creek","Black Duck","Black River - Lake Simcoe","Black Sturgeon","Bonnechere","Cataraqui","Cedar Creek","Central Abitibi","Central Mattagami","Central Missinaibi - Mattawishkwia","Central Missinaibi - Mattawitchewan","Central Rainy","Central Severn","Credit River - 16 Mile Creek","Crowe","Deep","Dog","Dogskin","Drowning","Echoing","Englehart","Fawn","French","Ganaraska","Garden","Goulais","Gull","Humber - Don Rivers","Jackpine","Kabinakagami","Kaskattama","Kattawagami","Kawartha Lakes","Kesagami","Killarney Channel","Kinosheo","Lac Seul","Lake of the Woods","Larus","Little Current","Little Pic","Lower Attawapiskat","Lower Ekwan","Lower English","Lower Grand","Lower Groundhog","Lower Kapuskasing","Lower Kenogami","Lower Madawaska","Lower Mattagami","Lower Missinaibi","Lower Ogoki","Lower Ottawa - South Nation","Lower Rainy","Lower Thames","Lower Winisk","Lower Winnipeg","Magnetawan","Maitland","Manatoulin Islands","Manigotagan","Mattagami","Michipicoten - Magpie","Middle Attawapiskat","Middle Winisk","Mississagi","Mississippi","Moira","Montreal","Muskoka","Napanee","Negagami","Niagara","Nipigon","Niskibi","North Grey Sauble Bruce Peninsula Watersheds","North Wanapitei","Nottawasaga","Oiseau","Onaping","Opasatika","Otonabee","Otter Rapids - Abitiby River Watersheds","Owen Sound Watersheds","Penetangore","Petawawa","Pic","Polar Bear Park Watersheds","Poplar","Prince Edward Bay","Red","Rideau","Ridge","Rondeau Watersheds","Sachigo","Sagawitchewan","Saugeen","Scugog","Seeber","Serpent","Shagamu","South Wanapitei","Spanish","Sturgeon","Sutton","Sydenham","Upper Abitibi","Upper Albany - Cat","Upper Albany - Makokibatan","Upper Albany - Misehkow","Upper Albany - Muswabik","Upper Attawapiskat","Upper Berens","Upper Ekwan","Upper English","Upper Grand","Upper Groundhog","Upper Kapiskau","Upper Kapuskasing","Upper Kenogami","Upper Madawaska","Upper Missinaibi","Upper Moose","Upper Ogoki","Upper Ottawa - Kipawa","Upper Rainy","Upper Severn","Upper St. Lawrence - Raisin","Upper St. Lawrence - Thousand Islands","Upper Thames","Upper Winisk","Upper Winnipeg","Wabigoon","Watabeag","Wenebegon","White","Whitefish","Whiteshell","Windigo"];

	globalConfig.watershedTypeParameter = "Watershed";
	globalConfig.searchChange = function(type){
		document.getElementById(globalConfig.searchInputBoxDivId).value = "";
		if(type === globalConfig.businessTypeParameter){
			$( "#" + globalConfig.searchInputBoxDivId ).autocomplete({
				disabled: true,
				source: []
			});
			document.getElementById(globalConfig.radiusSelectionDivId).disabled = true;
		}else if (type === globalConfig.watershedTypeParameter){
			document.getElementById(globalConfig.radiusSelectionDivId).disabled = true;
			$("#" + globalConfig.searchInputBoxDivId).autocomplete({
				source: globalConfig.watershedNames,
				disabled: false, 
				select: function(e, ui) {
					MOEMAP.clearOverlays();
					var searchString = ui.item.value;
					var queryParams = {
						searchString: searchString,
						withinExtent: false,
						where: "NAME = '" + searchString + "'",
						requireGeocode: false,
						address: searchString
					};				
					MOEMAP.queryLayersWithConditionsExtent(queryParams);
				}
			});				
		}else{
			$( "#" + globalConfig.searchInputBoxDivId ).autocomplete({
				disabled: true,
				source: []
			});
			document.getElementById(globalConfig.radiusSelectionDivId).disabled = false;
		}
	};
	globalConfig.searchWatershedDivId = "searchWatershed";	
	globalConfig.search = function(){
			var searchString = document.getElementById(globalConfig.searchInputBoxDivId).value.trim();
			if(searchString.length === 0){
				return;
			}
			document.getElementById(globalConfig.queryTableDivId).innerHTML = "";
			MOEMAP.clearOverlays();
			var queryParams = {
				searchString: searchString,
				withinExtent: false
			};
			if(globalConfig.accessible || document.getElementById(globalConfig.searchBusinessDivId).checked){
				var name = searchString.toUpperCase();
				name = globalConfig.replaceChar(name, "'", "''");
				name = globalConfig.replaceChar(name, "\u2019", "''");
				var fuzzyConditionsGenerator = function(field, str) {
					return "(UPPER(" + field + ") LIKE '% " + str + " %') OR (UPPER(" + field + ") LIKE '" + str + " %') OR (UPPER(" + field + ") LIKE '% " + str + "') OR (UPPER(" + field + ") = '" + str + "') OR (UPPER(" + field + ") LIKE '%" + str + ",%')";
				};				
				queryParams.where = fuzzyConditionsGenerator("CLIENTNAME", name);
				queryParams.requireGeocode = false;
				queryParams.address = searchString;
				MOEMAP.queryLayersWithConditionsExtent(queryParams);				
				return;
			}			
			if(document.getElementById(globalConfig.searchWatershedDivId).checked){
				queryParams.where = "NAME = '" + searchString + "'";
				queryParams.requireGeocode = false;
				queryParams.address = searchString;
				MOEMAP.queryLayersWithConditionsExtent(queryParams);
				return;
			}			

			if(document.getElementById(globalConfig.searchLocationDivId).checked){
				queryParams.address = searchString;
				queryParams.radius = document.getElementById(globalConfig.radiusSelectionDivId).value;
				queryParams.callback = MOEMAP.addressBufferCallback;			
				LOCATOR.locate(queryParams);			
			}			
	};
	if (!globalConfig.accessible) {
		globalConfig.autoCompleteSearch = function(){
			$("#" + globalConfig.searchInputBoxDivId).autocomplete({
				source: [],
				select: function(e, ui) {
				},
				disabled: true
			});
		};
		$(function() {
			globalConfig.autoCompleteSearch();
		});
	}

if (globalConfig.language === "EN"){
	globalConfig.SearchInteractiveMapFormLang = globalConfig.SearchInteractiveMapFormLang || 'Search interactive map form';
	//globalConfig.SearchInteractiveMapLang = globalConfig.SearchInteractiveMapLang || 'Search interactive map';
	globalConfig.SearchInteractiveMapLang = globalConfig.SearchInteractiveMapLang || 'Search the map';
	globalConfig.SearchLang = globalConfig.SearchLang || 'Search';
	globalConfig.TermLang = globalConfig.TermLang || 'Term';
	globalConfig.InputBoxSizeLang = globalConfig.InputBoxSizeLang || '415px';	
	globalConfig.degreeSymbolLang = globalConfig.degreeSymbolLang || "&deg;";
	globalConfig.selectTooltip = globalConfig.selectTooltip || "Select";
	globalConfig.UTM_ZoneLang = globalConfig.UTM_ZoneLang || "UTM Zone";
	globalConfig.EastingLang = globalConfig.EastingLang || "Easting";
	globalConfig.NorthingLang = globalConfig.NorthingLang || "Northing";
	//globalConfig.designLang = globalConfig.designLang || "This application is designed and implemented by <strong>Ministry of the Environment Environmental Science Facilitation and Reporting Unit</strong> using <strong>MOE Mapping library version 2.0</strong>.";	
	globalConfig.noResultFoundMsg = globalConfig.noResultFoundMsg || "Your search returned no result. Please refine your search.";
	globalConfig.searchCenterLang = globalConfig.searchCenterLang || "Search center";
	globalConfig.searchRadiusLang = globalConfig.searchRadiusLang || "search radius";
	globalConfig.searchKMLang = globalConfig.searchKMLang || "KM";	
	globalConfig.totalFeatureReturnedLang = globalConfig.totalFeatureReturnedLang || "Total features returned";
	globalConfig.only1DisplayedLang = globalConfig.only1DisplayedLang || ", only 1 is displayed.";
	globalConfig.westSymbolLang = globalConfig.westSymbolLang || "W";
	globalConfig.distanceLang = globalConfig.distanceLang || "Distance (KM)";
	globalConfig.searchingLang = globalConfig.searchingLang || "Searching for results...";
	globalConfig.inGobalRegionLang = globalConfig.inGobalRegionLang || "in Ontario";
	globalConfig.inCurrentMapExtentLang = globalConfig.inCurrentMapExtentLang || "in the current map display";
	globalConfig.forLang = "for";
	globalConfig.yourSearchLang = globalConfig.yourSearchLang || "Your search";
	globalConfig.returnedNoResultLang = globalConfig.returnedNoResultLang || "returned no result";
	globalConfig.pleaseRefineSearchLang = globalConfig.pleaseRefineSearchLang || "Please refine your search";
	globalConfig.oneResultFoundLang = globalConfig.oneResultFoundLang || "1 result found";
	globalConfig.moreThanLang = globalConfig.moreThanLang || "More than";
	globalConfig.resultsFoundLang = globalConfig.resultsFoundLang || "results found";
	globalConfig.onlyLang = globalConfig.onlyLang || "Only";
	globalConfig.returnedLang = globalConfig.returnedLang || "returned";
	globalConfig.seeHelpLang = globalConfig.seeHelpLang || "See help for options to refine your search";
	globalConfig.disclaimerLang = globalConfig.disclaimerLang || "<p>This website and all of the information it contains are provided &quot;as is&quot; without warranty of any kind, whether express or implied. <a href=\"/environment/en/resources/collection/data_downloads/STDPROD_078135.html\">View the terms of use</a>.</p>";
	globalConfig.InformationLang = globalConfig.InformationLang || "Information";
	//globalConfig.CurrentMapDisplayLang = globalConfig.CurrentMapDisplayLang || 'Current Map Display';
	globalConfig.CurrentMapDisplayLang = globalConfig.CurrentMapDisplayLang || 'Search current map display only';
	globalConfig.CurrentMapDisplayTitleLang = globalConfig.CurrentMapDisplayTitleLang || 'Current Map Display: Limit your search to the area displayed';
	globalConfig.distanceFieldNote = globalConfig.distanceFieldNote || "The Distance(KM) column represents the distance between your search location and the permit location in the specific row.";
	globalConfig.noCoordinatesTableTitleLang = globalConfig.noCoordinatesTableTitleLang || "The following table contains the records without valid coordinates. <a href='#WhyAmISeeingThis'>Why am I seeing this?</a>";
	globalConfig.whyAmISeeingThisLang = globalConfig.whyAmISeeingThisLang || "<a id='WhyAmISeeingThis'><strong>Why am I seeing this?</strong></a><br>The map locations shown as points have been determined by using addresses or other information to calculate a physical location on the map.  In some cases, the information needed to calculate a location was incomplete, incorrect or missing.  The records provided in the table have been included because there is a close match on the name or city/town or other field(s). These records may or may not be near your specified location, and users are cautioned in using these records. They have been included as potential matches only.";
	globalConfig.ThisResultDoesNotHaveValidCoordinates = globalConfig.ThisResultDoesNotHaveValidCoordinates || "This result does not have valid coordinates.";
	globalConfig.AmongReturnedResults = globalConfig.AmongReturnedResults || "Among returned results";
	globalConfig.ResultDoesNotHaveValidCoordinates = globalConfig.ResultDoesNotHaveValidCoordinates || " result does not have valid coordinates.";
	globalConfig.ResultsDoNotHaveValidCoordinates = globalConfig.ResultsDoNotHaveValidCoordinates || " results do not have valid coordinates.";
	globalConfig.youMaySearchByLang = globalConfig.youMaySearchByLang || "You may search by ";
	globalConfig.seeHelpForAdvancedOptionsLang = globalConfig.seeHelpForAdvancedOptionsLang || "or see help for advanced options.";
} else {
	globalConfig.SearchInteractiveMapFormLang = globalConfig.SearchInteractiveMapFormLang || 'Recherche carte interactive forme';
	//globalConfig.SearchInteractiveMapLang = globalConfig.SearchInteractiveMapLang || 'Recherche carte interactive';
	globalConfig.SearchInteractiveMapLang = globalConfig.SearchInteractiveMapLang || 'Recherche dans la carte interactive';
	globalConfig.SearchLang = globalConfig.SearchLang || 'Recherche';
	globalConfig.TermLang = globalConfig.TermLang || 'Terme';
	globalConfig.InputBoxSizeLang = globalConfig.InputBoxSizeLang || '450px';
	globalConfig.degreeSymbolLang = globalConfig.degreeSymbolLang || "&deg;";
	globalConfig.selectTooltip = globalConfig.selectTooltip || globalConfig.selectTooltip || "Choisir";
	globalConfig.UTM_ZoneLang = globalConfig.UTM_ZoneLang || "Zone UTM";
	globalConfig.EastingLang = globalConfig.EastingLang || "abscisse";
	globalConfig.NorthingLang = globalConfig.NorthingLang || "ordonn\u00e9e";
	//globalConfig.designLang = globalConfig.designLang || "Cette application est con\u00e7ue et mise en \u0153uvre par <strong>l\u0027Unit\u00e9 de la facilitation de la gestion de l\u0027information et des rapports \u2013 sciences environnementales du minist\u00e8re de l\u0027Environnement</strong> au moyen de la <strong>cartoth\u00e8que du MEO (version 2.0)</strong>.";	
	globalConfig.noResultFoundMsg = globalConfig.noResultFoundMsg || "Votre recherche n'a produit aucun r\u00e9sultat. Veuillez affiner la recherche.";	
	globalConfig.searchCenterLang = globalConfig.searchCenterLang || "Cercle de recherche";
	globalConfig.searchRadiusLang = globalConfig.searchRadiusLang || "rayon de recherche";
	globalConfig.searchKMLang = globalConfig.searchKMLang || "km";	
	globalConfig.totalFeatureReturnedLang = globalConfig.totalFeatureReturnedLang || "Nombre total de r\u00e9sultats";
	globalConfig.only1DisplayedLang = globalConfig.only1DisplayedLang || ", only 1 is displayed.";	
	globalConfig.westSymbolLang = globalConfig.westSymbolLang || "O";
	globalConfig.distanceLang = globalConfig.distanceLang || "Distance (en km)";
	globalConfig.searchingLang = globalConfig.searchingLang || "Recherche des r\u00e9sultats ...";
	globalConfig.inGobalRegionLang = globalConfig.inGobalRegionLang || "en Ontario";
	globalConfig.inCurrentMapExtentLang = globalConfig.inCurrentMapExtentLang || "dans l'affichage actuel de la carte";
	globalConfig.forLang = "pour";
	globalConfig.yourSearchLang = globalConfig.yourSearchLang || "Votre recherche";
	globalConfig.returnedNoResultLang = globalConfig.returnedNoResultLang || "n'a donn\u00e9 aucun r\u00e9sultat";
	globalConfig.pleaseRefineSearchLang = globalConfig.pleaseRefineSearchLang || "S'il vous plait affiner votre recherche";
	globalConfig.oneResultFoundLang = globalConfig.oneResultFoundLang || "1 r\u00e9sultat";
	globalConfig.moreThanLang = globalConfig.moreThanLang || "Plus de";
	globalConfig.resultsFoundLang = globalConfig.resultsFoundLang || "r\u00e9sultats";
	globalConfig.onlyLang = globalConfig.onlyLang || "Seulement";
	globalConfig.returnedLang = globalConfig.returnedLang || "retourn\u00e9s";
	globalConfig.seeHelpLang = globalConfig.seeHelpLang || "Consulter l'aide pour affiner votre recherche";	
	globalConfig.disclaimerLang = globalConfig.disclaimerLang || "<p>Ce site web et toute l&rsquo;information qu&rsquo;il contient sont fournis sans garantie quelconque, expr&egrave;s ou tacite. <a href=\"/environment/fr/resources/collection/data_downloads/STDPROD_078138.html\">Voir l&rsquo;avis de non-responsabilit&eacute;</a>.</p>";
	globalConfig.InformationLang = globalConfig.InformationLang || "Information";
	globalConfig.CurrentMapDisplayLang = globalConfig.CurrentMapDisplayLang || '\u00c9tendue de la carte courante';
	globalConfig.CurrentMapDisplayTitleLang = globalConfig.CurrentMapDisplayTitleLang || 'Afficher la carte : Limiter la recherche \u00e0 la carte donn\u00e9e.';	
	globalConfig.distanceFieldNote = globalConfig.distanceFieldNote || "La colonne de distance (en km) donne la distance entre le lieu de votre recherche et le lieu du puits dans la rang\u00e9e donn\u00e9e.";
	globalConfig.noCoordinatesTableTitleLang = globalConfig.noCoordinatesTableTitleLang || "Le tableau suivant contient des donnes sans coordonnes valides.  <a href='#WhyAmISeeingThis'>Pourquoi cela saffiche-t-il?</a>";
	globalConfig.whyAmISeeingThisLang = globalConfig.whyAmISeeingThisLang || "<a id='WhyAmISeeingThis'>Pourquoi cela saffiche-t-il?</a><br>Les lieux indiqus par des points sur la carte ont t dtermins en fonction dadresses ou dautres renseignements servant  calculer un emplacement physique sur la carte. Dans certains cas, ces renseignements taient incomplets, incorrects ou manquants. Les donnes fournies dans le deuxime tableau ont t incluses, car il y a une correspondance troite avec le nom de la ville ou dautre champ. Ces donnes peuvent ou non tre proches du lieu prcis, et on doit les utiliser avec prudence. Elles ont t incluses seulement parce quil peut y avoir une correspondance.";	
	globalConfig.ThisResultDoesNotHaveValidCoordinates = globalConfig.ThisResultDoesNotHaveValidCoordinates || "This result does not have valid coordinates.";
	globalConfig.AmongReturnedResults = globalConfig.AmongReturnedResults || "Parmi les rsultats obtenus";
	globalConfig.ResultDoesNotHaveValidCoordinates = globalConfig.ResultDoesNotHaveValidCoordinates || " rsultat na pas de coordonnes valides.";
	globalConfig.ResultsDoNotHaveValidCoordinates = globalConfig.ResultsDoNotHaveValidCoordinates || " rsultats nont pas de coordonnes valides.";
	
	globalConfig.youMaySearchByLang = globalConfig.youMaySearchByLang || "Vous pouvez rechercher par ";
	globalConfig.seeHelpForAdvancedOptionsLang = globalConfig.seeHelpForAdvancedOptionsLang || "ou consulter l'aide pour de l'information sur les recherches avanc&eacute;es.";
	globalConfig.dataTableLang = globalConfig.dataTableLang || {
		"sProcessing":     "Traitement en cours...",
		"sSearch":         "Rechercher&nbsp;:",
		"sLengthMenu":     "Afficher _MENU_ &eacute;l&eacute;ments",
		"sInfo":           "Affichage de l'&eacute;lement _START_ &agrave; _END_ sur _TOTAL_ &eacute;l&eacute;ments",
		"sInfoEmpty":      "Affichage de l'&eacute;lement 0 &agrave; 0 sur 0 &eacute;l&eacute;ments",
		"sInfoFiltered":   "(filtr&eacute; de _MAX_ &eacute;l&eacute;ments au total)",
		"sInfoPostFix":    "",
		"sLoadingRecords": "Chargement en cours...",
		"sZeroRecords":    "Aucun &eacute;l&eacute;ment &agrave; afficher",
		"sEmptyTable":     "Aucune donn&eacute;e disponible dans le tableau",
		"oPaginate": {
			"sFirst":      "Premier",
			"sPrevious":   "Pr&eacute;c&eacute;dent",
			"sNext":       "Suivant",
			"sLast":       "Dernier"
		},
		"oAria": {
			"sSortAscending":  ": activer pour trier la colonne par ordre croissant",
			"sSortDescending": ": activer pour trier la colonne par ordre d&eacute;croissant"
		}
	};
}
globalConfig.u2019Lang = "\u2019";
globalConfig.nbspLang = "&nbsp";

var globalConfig = globalConfig || {};
if (typeof console == "undefined") {
	window.console = {
		log: function () {}
	};
}
/*Add trim function to String. This function will remove the spaces and tabs in the beginning and ending of a String.*/
if (!('trim' in String.prototype)){   
	String.prototype.trim = function() { return this.replace(/^\s+|\s+$/g,""); };    
}
// Production steps of ECMA-262, Edition 5, 15.4.4.14
// Reference: http://es5.github.io/#x15.4.4.14
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function(searchElement, fromIndex) {

    var k;

    // 1. Let O be the result of calling ToObject passing
    //    the this value as the argument.
    if (this == null) {
      throw new TypeError('"this" is null or not defined');
    }

    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get
    //    internal method of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If len is 0, return -1.
    if (len === 0) {
      return -1;
    }

    // 5. If argument fromIndex was passed let n be
    //    ToInteger(fromIndex); else let n be 0.
    var n = +fromIndex || 0;

    if (Math.abs(n) === Infinity) {
      n = 0;
    }

    // 6. If n >= len, return -1.
    if (n >= len) {
      return -1;
    }

    // 7. If n >= 0, then Let k be n.
    // 8. Else, n<0, Let k be len - abs(n).
    //    If k is less than 0, then let k be 0.
    k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

    // 9. Repeat, while k < len
    while (k < len) {
      var kValue;
      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the
      //    HasProperty internal method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      //    i.  Let elementK be the result of calling the Get
      //        internal method of O with the argument ToString(k).
      //   ii.  Let same be the result of applying the
      //        Strict Equality Comparison Algorithm to
      //        searchElement and elementK.
      //  iii.  If same is true, return k.
      if (k in O && O[k] === searchElement) {
        return k;
      }
      k++;
    }
    return -1;
  };
}

/*Add contains function to Array. This function will test whether an Array contains an element or not.*/			
if (!('contains' in Array.prototype)){
	Array.prototype.contains = function(obj) {
		return (this.indexOf(obj) >= 0);
		/*var i = this.length;
		while (i--) {
			if (this[i] === obj) {
				return true;
			}
		}
		return false;*/
	};
}
/*Add unique function to Array. This function will return the unique elements in an array*/						
if (!('unique' in Array.prototype)){
	Array.prototype.unique = function() {
		var n = [];
		for(var i = 0; i < this.length; i++) {
			if(n.indexOf(this[i]) < 0) {
				n.push(this[i]);
			}
		}
		return n;
	/*
		var a = this.concat();
		for(var i=0; i<a.length; ++i) {
			for(var j=i+1; j<a.length; ++j) {
				if(a[i] === a[j]){
					a.splice(j, 1);
				}
			}
		}
		return a;*/
	};
}

// Production steps of ECMA-262, Edition 5, 15.4.4.19
// Reference: http://es5.github.com/#x15.4.4.19
//https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/map
if (!Array.prototype.filter) {
	Array.prototype.filter = function(fun /*, thisp */){
		"use strict";

		if (this == null)
			throw new TypeError();

		var t = Object(this);
		var len = t.length >>> 0;
		if (typeof fun != "function")
			throw new TypeError();

		var res = [];
		var thisp = arguments[1];
		for (var i = 0; i < len; i++) {
			if (i in t){
				var val = t[i]; // in case fun mutates this
				if (fun.call(thisp, val, i, t))
					res.push(val);
			}
		}
		return res;
	};
}


// Production steps of ECMA-262, Edition 5, 15.4.4.19
// Reference: http://es5.github.com/#x15.4.4.19
if (!Array.prototype.map) {
	Array.prototype.map = function(callback, thisArg) {

		var T, A, k;

		if (this === null) {
			throw new TypeError(" this is null or not defined");
		}

		// 1. Let O be the result of calling ToObject passing the |this| value as the argument.
		var O = Object(this);

		// 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
		// 3. Let len be ToUint32(lenValue).
		var len = O.length >>> 0;

		// 4. If IsCallable(callback) is false, throw a TypeError exception.
		// See: http://es5.github.com/#x9.11
		if (typeof callback !== "function") {
			throw new TypeError(callback + " is not a function");
		}

		// 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
		if (thisArg) {
			T = thisArg;
		}

		// 6. Let A be a new array created as if by the expression new Array(len) where Array is
		// the standard built-in constructor with that name and len is the value of len.
		A = new Array(len);

		// 7. Let k be 0
		k = 0;

		// 8. Repeat, while k < len
		while(k < len) {

			var kValue, mappedValue;

			// a. Let Pk be ToString(k).
			//   This is implicit for LHS operands of the in operator
			// b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
			//   This step can be combined with c
			// c. If kPresent is true, then
			if (k in O) {

				// i. Let kValue be the result of calling the Get internal method of O with argument Pk.
				kValue = O[ k ];

				// ii. Let mappedValue be the result of calling the Call internal method of callback
				// with T as the this value and argument list containing kValue, k, and O.
				mappedValue = callback.call(T, kValue, k, O);

				// iii. Call the DefineOwnProperty internal method of A with arguments
				// Pk, Property Descriptor {Value: mappedValue, : true, Enumerable: true, Configurable: true},
				// and false.

				// In browsers that support Object.defineProperty, use the following:
				// Object.defineProperty(A, Pk, { value: mappedValue, writable: true, enumerable: true, configurable: true });

				// For best browser support, use the following:
				A[ k ] = mappedValue;
			}
			// d. Increase k by 1.
			k++;
		}

		// 9. return A
		return A;
	};      
}			

if ('function' !== typeof Array.prototype.reduce) {
  Array.prototype.reduce = function(callback, opt_initialValue){
    'use strict';
    if (null === this || 'undefined' === typeof this) {
      // At the moment all modern browsers, that support strict mode, have
      // native implementation of Array.prototype.reduce. For instance, IE8
      // does not support strict mode, so this check is actually useless.
      throw new TypeError(
          'Array.prototype.reduce called on null or undefined');
    }
    if ('function' !== typeof callback) {
      throw new TypeError(callback + ' is not a function');
    }
    var index = 0, length = this.length >>> 0, value, isValueSet = false;
    if (1 < arguments.length) {
      value = opt_initialValue;
      isValueSet = true;
    }
    for ( ; length > index; ++index) {
      if (!this.hasOwnProperty(index)) continue;
      if (isValueSet) {
        value = callback(value, this[index], index, this);
      } else {
        value = this[index];
        isValueSet = true;
      }
    }
    if (!isValueSet) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
    return value;
  };
}

Array.range = function (a, b, step) {
    var A = [];
    if (typeof a == 'number') {
        A[0] = a;
        step = step || 1;
        while (a + step <= b) {
            A[A.length] = a += step;
        }
    } else {
        var s = 'abcdefghijklmnopqrstuvwxyz';
        if (a === a.toUpperCase()) {
            b = b.toUpperCase();
            s = s.toUpperCase();
        }
        s = s.substring(s.indexOf(a), s.indexOf(b) + 1);
        A = s.split('');
    }
    return A;
}

/** Converts numeric degrees to radians http://www.movable-type.co.uk/scripts/latlong.html */
if (typeof Number.prototype.toRad == 'undefined') {
    Number.prototype.toRad = function () {
        return this * Math.PI / 180;
    }
}

globalConfig.replaceChar =  globalConfig.replaceChar || function(str, charA, charB) {
	var temp = [];
	temp = str.split(charA);
	var result = temp[0];
	if (temp.length >= 2) {
		for (var i = 1; i < temp.length; i++) {
			result = result + charB + temp[i];
		}
	}
	return result;
};
globalConfig.wordCapitalize = globalConfig.wordCapitalize || function (str){
	var strArray = str.trim().split(' ');
	for(var i=0; i < strArray.length; i++) {
				strArray[i] = strArray[i].substring(0,1).toUpperCase() + strArray[i].substring(1,strArray[i].length).toLowerCase();
	}
	return strArray.join(' ');
};
	
globalConfig.convertLatLngtoUTM = globalConfig.convertLatLngtoUTM || function(lat, lng) {
	var pi = 3.14159265358979; //PI
	var a = 6378137; //equatorial radius for WGS 84
	var k0 = 0.9996; //scale factor
	var e = 0.081819191; //eccentricity
	var e_2 = 0.006694380015894481; //e'2
	var A0 = 6367449.146;
	var B0 = 16038.42955;
	var C0 = 16.83261333;
	var D0 = 0.021984404;
	var E0 = 0.000312705;

	var zone = 31 + Math.floor(lng / 6);
	var lat_r = lat * pi / 180.0;
	var t1 = Math.sin(lat_r); // SIN(LAT)
	var t2 = e * t1 * e * t1;
	var t3 = Math.cos(lat_r); // COS(LAT)
	var t4 = Math.tan(lat_r); // TAN(LAT)
	var nu = a / (Math.sqrt(1 - t2));
	var S = A0 * lat_r - B0 * Math.sin(2 * lat_r) + C0 * Math.sin(4 * lat_r) - D0 * Math.sin(6 * lat_r) + E0 * Math.sin(8 * lat_r);
	var k1 = S * k0;
	var k2 = nu * t1 * t3 * k0 / 2.0;
	var k3 = ((nu * t1 * t2 * t2 * t2) / 24) * (5 - t4 * t4 + 9 * e_2 * t3 * t3 + 4 * e_2 * e_2 * t3 * t3 * t3 * t3) * k0;
	var k4 = nu * t3 * k0;
	var k5 = t3 * t3 * t3 * (nu / 6) * (1 - t4 * t4 + e_2 * t3 * t3) * k0;

	//var lng_r = lng*pi/180.0;
	var lng_zone_cm = 6 * zone - 183;
	var d1 = (lng - lng_zone_cm) * pi / 180.0;
	var d2 = d1 * d1;
	var d3 = d2 * d1;
	var d4 = d3 * d1;

	var x = 500000 + (k4 * d1 + k5 * d3);
	var rawy = (k1 + k2 * d2 + k3 * d4);
	var y = rawy;
	if (y < 0) {
		y = y + 10000000;
	}
	var res = {
		Zone: zone,
		Easting: x.toFixed(0),
		Northing: y.toFixed(0)
	};
	return res;
};	

globalConfig.convertUTMtoLatLng = globalConfig.convertUTMtoLatLng || function(zone, north, east) {
	var pi = 3.14159265358979; //PI
	var a = 6378137; //equatorial radius for WGS 84
	var k0 = 0.9996; //scale factor
	var e = 0.081819191; //eccentricity
	var e_2 = 0.006694380015894481; //e'2
	//var corrNorth = north; //North Hemishpe
	var estPrime = 500000 - east;
	var arcLength = north / k0;
	var e_4 = e_2 * e_2;
	var e_6 = e_4 * e_2;
	var t1 = Math.sqrt(1 - e_2);
	var e1 = (1 - t1) / (1 + t1);
	var e1_2 = e1 * e1;
	var e1_3 = e1_2 * e1;
	var e1_4 = e1_3 * e1;

	var C1 = 3 * e1 / 2 - 27 * e1_3 / 32;
	var C2 = 21 * e1_2 / 16 - 55 * e1_4 / 32;
	var C3 = 151 * e1_3 / 96;
	var C4 = 1097 * e1_4 / 512;

	var mu = arcLength / (a * (1 - e_2 / 4.0 - 3 * e_4 / 64 - 5 * e_6 / 256));
	var FootprintLat = mu + C1 * Math.sin(2 * mu) + C2 * Math.sin(4 * mu) + C3 * Math.sin(6 * mu) + C4 * Math.sin(8 * mu);
	var FpLatCos = Math.cos(FootprintLat);
	//var C1_an = e_2*FpLatCos*FpLatCos;
	var FpLatTan = Math.tan(FootprintLat);
	var T1 = FpLatTan * FpLatTan;
	var FpLatSin = Math.sin(FootprintLat);
	var FpLatSin_e = e * FpLatSin;
	var t2 = 1 - FpLatSin_e * FpLatSin_e;
	var t3 = Math.sqrt(t2);
	var N1 = a / t3;
	var R1 = a * (1 - e_2) / (t2 * t3);
	var D = estPrime / (N1 * k0);
	var D_2 = D * D;
	var D_4 = D_2 * D_2;
	var D_6 = D_4 * D_2;
	var fact1 = N1 * FpLatTan / R1;
	var fact2 = D_2 / 2;
	var fact3 = (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * e_2) * D_4 / 24;
	var fact4 = (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * e_2 - 3 * C1 * C1) * D_6 / 720;
	var lofact1 = D;
	var lofact2 = (1 + 2 * T1 + C1) * D_2 * D / 6;
	var lofact3 = (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * e_2 + 24 * T1 * T1) * D_4 * D / 120;
	var delta_Long = (lofact1 - lofact2 + lofact3) / FpLatCos;
	var zone_CM = 6 * zone - 183;
	var latitude = 180 * (FootprintLat - fact1 * (fact2 + fact3 + fact4)) / pi;
	var longitude = zone_CM - delta_Long * 180 / pi;
	var res = {
		Latitude: latitude.toFixed(8),
		Longitude: longitude.toFixed(8)
	};
	return res;
};
globalConfig.isInsidePolygon = globalConfig.isInsidePolygon || function (gLatLng, poly) {
	var lat = gLatLng.lat();
	var lng = gLatLng.lng();
	var numPoints = poly.length;
	var inPoly = false;
	var j = numPoints - 1;
	for (var i = 0; i < numPoints; i++) {
		var vertex1 = {x: poly[i].lng(), y: poly[i].lat()};
		var vertex2 = {x: poly[j].lng(), y: poly[j].lat()}; //poly[j];

		if (vertex1.x < lng && vertex2.x >= lng || vertex2.x < lng && vertex1.x >= lng) {
			if (vertex1.y + (lng - vertex1.x) / (vertex2.x - vertex1.x) * (vertex2.y - vertex1.y) < lat) {
				inPoly = !inPoly;
			}
		}

		j = i;
	}
	return inPoly;
};
globalConfig.deciToDegree = globalConfig.deciToDegree || function (degree){
	if(Math.abs(degree) <= 0.1){
		return "N/A";
	}
	var sym = "N";
	if(degree<0){
		degree = -degree;
		sym = globalConfig.westSymbolLang;
	}
	var deg = Math.floor(degree);
	var temp = (degree - deg)*60;
	var minute = Math.floor(temp);
	//var second = Math.floor((temp- minute)*60);
	var second = ((temp- minute)*60).toFixed(0);
	var res = "";
	if(second<1){
		res ="" + deg + globalConfig.degreeSymbolLang + minute + "'";
	}else if(second>58){
		res ="" + deg + globalConfig.degreeSymbolLang + (minute+1) + "'";
	}else{
		res ="" + deg + globalConfig.degreeSymbolLang + minute + "'" + second + "\"";
	}
	return res + sym;
};

/*
 * This function adds HTML tag <br> to a long text and returns it as the results. 
 * When a line has more than 50 letters including spaces, a <br> will be inserted
 * into the first space appears. 
 * 
 * @param text the input text
 * @return the text with <br> inserted or if the length of text is less than 50
 * No <br> is inserted. 
*/	
globalConfig.addBRtoLongText = function (text) {
	var lineCount = 0;
	var readyForBreak = false;
	if (text.length <= 40) {
		return text;
	}
	var textArray = text.split('');
	var result = "";	
	for (var i = 0; i < textArray.length; i++) {
		if (lineCount > 40) {
			readyForBreak = true;
		}
		result = result + textArray[i];
		if ((readyForBreak) && (textArray[i] === " ")) {
			lineCount = 0;
			result = result + "<br>";
			readyForBreak = false;
		}
		lineCount = lineCount + 1;
	}
	return result;
};

globalConfig.processNA = function (str) {
	if (typeof(str) === 'undefined') {
		return "N/A";
	}
	if (str === "null") {
		return "N/A";
	}
	if (str === "Null") {
		return "N/A";
	}
	return str;
};	/*global document:false */
/*global google:false */
/*global gmaps:false */
/*global LOCATOR:false */
/*global LATLNG_LOCATOR:false */
/*global UTM_LOCATOR:false */
/*global TWP_LOCATOR:false */
/*global ADDRESS_LOCATOR:false */

/*
This module is used to convert the user inputs, such as latitude & longitude, UTM coordinates, 
Geographic Township with/without lot and concession, and address, to decimal laitude and longitude. 

This module requires the following properties are defined in globalConfig.
1) validateLatLngWithRegion method: Give two values, decide which one is latitude and which one is 
longitude. In Ontario, this is determined by the fact that the absoulte value of longitude is always 
larger than the absolute value of latitude. That is the predefined method in globalConfig. Developers
can define their own method with the same name to override this method. 

2) defaultZone: The default UTM zone number. If the users only input the easting and northing, the 
default UTM zone will be used in the UTM search. The predefined UTM zone in globalConfig is 17. 

3) geogTwpService: The URL for Geographic Township with/without lot and concession web service. It contains
the following properties: 
	geogTwpService: {
		url: "http://www.appliomaps.lrc.gov.on.ca/ArcGIS/rest/services/MOE/sportfishservice/MapServer",  //URL
		TWPLayerID: 0,   // layer id for Geographic Township layer
		LotLayerID: 1,   // layer id for Geographic Township with lot and concession layer
		outFields: ["CENX", "CENY"],  // output fields for Geographic Township with lot and concession layer
		TWPLayerNameField: "NAME", // Geographic Township Name field inGeographic Township layer
		LotLayerNameFields: {    // Geographic Township Name field, Lot, Concession fields in Geographic Township with lot and concession layer
			TownshipField: "OFFICIAL_NAME_UPPER",
			LotField: "LOT_NUM_1",
			ConField: "CONCESSION_NUMBER"
		}
	}

4) regionAddressProcess: test whether the input contains province name. In globalConfig, a default method is provided to 
test whether the input contains Ontario or not. If not, Ontario is added to the ending of user input. 

5) regionBoundary: stores the boundary of the province polygon. It is used to test whether a point is within the province or not. 
In globalConfig, the boundary of Ontario is provided. 

6) UTMRange: store the value ranges of easting and northing in UTM coordinates. In globalConfig, the UTM ranges of Ontario is provided as following: 
	UTMRange: {
		minEasting: 258030.3,        
		maxEasting: 741969.7,        
		minNorthing: 4614583.73,        
		maxNorthing: 6302884.09
	}
7) locatorsAvailable: stores whether specific locator services is available or not. In globalConfig, the default seting makes all four locator services
available. 
	locatorsAvailable: {
		latlng: true,
		utm: true,
		township: true,
		address: true
	}. 

The is an example of configuration in globalConfig:
	regionBoundary: [{x: -95.29920350, y: 48.77505703},	{x: -95.29920350, y: 53.07150598}, 	{x: -89.02502409, y: 56.95876930}, 	{x: -87.42238044, y: 56.34499088}, 	{x: -86.36531760, y: 55.93580527}, 	{x: -84.69447635, y: 55.45842206}, 	{x: -81.89837466, y: 55.35612565}, 	{x: -81.96657226, y: 53.17380238}, 	{x: -80.84131182, y: 52.28723355}, 	{x: -79.98884179, y: 51.80985033}, 	{x: -79.34096457, y: 51.74165273}, 	{x: -79.34096457, y: 47.54750019}, 	{x: -78.55669214, y: 46.49043736}, 	{x: -76.61306048, y: 46.14944935}, 	{x: -75.59009645, y: 45.77436253}, 	{x: -74.12384800, y: 45.91075774}, 	{x: -73.98745279, y: 45.02418891}, 	{x: -75.07861443, y: 44.61500329}, 	{x: -75.86288685, y: 44.03532368}, 	{x: -76.88585089, y: 43.69433566}, 	{x: -79.20, y: 43.450196}, 	{x: -78.62488975, y: 42.94416204}, 	{x: -79.54555738, y: 42.43268002}, 	{x: -81.28459623, y: 42.15988961}, 	{x: -82.54625188, y: 41.58020999}, 	{x: -83.26232670, y: 41.95529681}, 	{x: -83.36462310, y: 42.43268002}, 	{x: -82.61444948, y: 42.73956923}, 	{x: -82.17116506, y: 43.59203926}, 	{x: -82.61444948, y: 45.36517692}, 	{x: -84.08069793, y: 45.91075774}, 	{x: -84.93316796, y: 46.69503016}, 	{x: -88.27485047, y: 48.22947621}, 	{x: -89.33191330, y: 47.78619180}, 	{x: -90.32077854, y: 47.68389540}, 	{x: -92.09391619, y: 47.95668581}, 	{x: -94.07164666, y: 48.33177262}, 	{x: -95.29920350, y: 48.77505703}],
	UTMRange: {
		minEasting: 258030.3,        
		maxEasting: 741969.7,        
		minNorthing: 4614583.73,        
		maxNorthing: 6302884.09
	},
	locatorsAvailable: {
		latlng: true,
		utm: true,
		township: true,
		address: true
	},
	validateLatLngWithRegion: function(v1, v2){
		var lat = Math.min(v1, v2);
		var lng = -Math.max(v1, v2);
		return {lat: lat, lng: lng};
	},
	regionAddressProcess: function(addressStr){
		var address = addressStr.toUpperCase();
		var regionNames = ["ON", "ONT", "ONTARIO"];
		var res = false;
		for(var i=0; i<regionNames.length; i++){
			if(globalConfig.isAddressEndsWithRegionName(address, regionNames[i])){
				res = true;
			}
		}
		if(!res){
			return addressStr + " Ontario";
		}
		return addressStr;
	},
	defaultZone: 17,
	geogTwpService: {
		url: "http://www.appliomaps.lrc.gov.on.ca/ArcGIS/rest/services/MOE/sportfishservice/MapServer",
		TWPLayerID: 0,
		LotLayerID: 1,
		outFields: ["CENX", "CENY"],
		TWPLayerNameField: "NAME",
		LotLayerNameFields: {
			TownshipField: "OFFICIAL_NAME_UPPER",
			LotField: "LOT_NUM_1",
			ConField: "CONCESSION_NUMBER"
		}
	}
*/

var globalConfig = globalConfig || {};
/*globalConfig.informationDivId = globalConfig.informationDivId || 'information';
globalConfig.noResultFound = globalConfig.noResultFound || function(){
	document.getElementById(globalConfig.informationDivId).innerHTML ="<i>" + globalConfig.noResultFoundMsg + "</i>";	
};*/
	/* This the center of Ontario. If the geocoder returns this location as the results, it will be a failure of geocoding. */
	globalConfig.failedLocation = globalConfig.failedLocation || {
		positions: [[51.253775,-85.32321389999998], [42.832714, -80.279923]],
		difference: 0.00001
	};
	/* LOCATOR setting Starts */
	globalConfig.regionBoundary = globalConfig.regionBoundary || [{x: -95.29920350, y: 48.77505703},{x: -95.29920350, y: 53.07150598}, 	{x: -89.02502409, y: 56.95876930}, 	{x: -87.42238044, y: 56.34499088}, 	{x: -86.36531760, y: 55.93580527}, 	{x: -84.69447635, y: 55.45842206}, 	{x: -81.89837466, y: 55.35612565}, 	{x: -81.96657226, y: 53.17380238}, 	{x: -80.84131182, y: 52.28723355}, 	{x: -79.98884179, y: 51.80985033}, 	{x: -79.34096457, y: 51.74165273}, 	{x: -79.34096457, y: 47.54750019}, 	{x: -78.55669214, y: 46.49043736}, 	{x: -76.61306048, y: 46.14944935}, 	{x: -75.59009645, y: 45.77436253}, 	{x: -74.12384800, y: 45.91075774}, 	{x: -73.98745279, y: 45.02418891}, 	{x: -75.07861443, y: 44.61500329}, 	{x: -75.86288685, y: 44.03532368}, 	{x: -76.88585089, y: 43.69433566}, 	{x: -79.20, y: 43.450196}, 	{x: -78.62488975, y: 42.94416204}, 	{x: -79.54555738, y: 42.43268002}, 	{x: -81.28459623, y: 42.15988961}, 	{x: -82.54625188, y: 41.58020999}, 	{x: -83.26232670, y: 41.95529681}, 	{x: -83.36462310, y: 42.43268002}, 	{x: -82.61444948, y: 42.73956923}, 	{x: -82.17116506, y: 43.59203926}, 	{x: -82.61444948, y: 45.36517692}, 	{x: -84.08069793, y: 45.91075774}, 	{x: -84.93316796, y: 46.69503016}, 	{x: -88.27485047, y: 48.22947621}, 	{x: -89.33191330, y: 47.78619180}, 	{x: -90.32077854, y: 47.68389540}, 	{x: -92.09391619, y: 47.95668581}, 	{x: -94.07164666, y: 48.33177262}, 	{x: -95.29920350, y: 48.77505703}];
	globalConfig.TWPSearch = false;  //use to remember whether it is a Township location search. 
	globalConfig.TWPLotConSearch = false; //use to remember whether it is a Township with lot and concession location search.
	globalConfig.UTMRange = globalConfig.UTMRange ||{
		minEasting: 258030.3,        
		maxEasting: 741969.7,        
		minNorthing: 4614583.73,        
		maxNorthing: 6302884.09
	};
	globalConfig.locatorsAvailable = globalConfig.locatorsAvailable || {
		latlng: true,
		utm: true,
		township: true,
		address: true
	};
	globalConfig.validateLatLngWithRegion = globalConfig.validateLatLngWithRegion  || function(v1, v2){
		var lat = Math.min(v1, v2);
		var lng = -Math.max(v1, v2);
		return {lat: lat, lng: lng};
	};
	//Private method: test whether the input ends keywords
	globalConfig.isAddressEndsWithRegionName = globalConfig.isAddressEndsWithRegionName || function(address, str) {
		if (address.length > str.length + 1) {
			var substr = address.substring(address.length - str.length - 1);
			if (substr === (" " + str) || substr === ("," + str)) {
				return true;
			}
		}
		return false;
	};
	//Private method: test whether the input contains keywords by calling testOntario
	globalConfig.regionAddressProcess = globalConfig.regionAddressProcess || function(addressStr){
		var address = addressStr.toUpperCase();
		var regionNames = ["ON", "ONT", "ONTARIO"];
		var res = false;
		for(var i=0; i<regionNames.length; i++){
			if(globalConfig.isAddressEndsWithRegionName(address, regionNames[i])){
				res = true;
			}
		}
		if(!res){
			return addressStr + " Ontario";
		}
		return addressStr;
	};
	globalConfig.defaultZone = globalConfig.defaultZone || 17;
	globalConfig.geogTwpService = globalConfig.geogTwpService ||{
		url: "http://www.appliomaps.lrc.gov.on.ca/ArcGIS/rest/services/MOE/sportfishservice/MapServer",
		TWPLayerID: 0,
		LotLayerID: 1,
		latitude: "CENY",
		longitude: "CENX",		
		TWPLayerNameField: "NAME",
		LotLayerNameFields: {
			TownshipField: "OFFICIAL_NAME_UPPER",
			LotField: "LOT_NUM_1",
			ConField: "CONCESSION_NUMBER"
		}
	};
	/*globalConfig.locationServicesList = globalConfig.locationServicesList || [
		{
			mapService: "http://138.218.29.100/ArcGIS/rest/services/DevJerry/Parcels/MapServer",
			layerID: 0,
			displayPolygon: true,  //For non-polygon layers, it is always false. For polygon layers, you can turn on and off to visualize the polygon.  
			fieldsInInfoWindow: ["ARN"], 
			getInfoWindow: function(attributes){
				return "Assessment Parcel Number: <strong>" + attributes.ARN + "</strong>";
			}, 
			latitude: "Latitude",
			longitude: "Longitude",
			getSearchCondition: function(searchString){
				return "ARN = '" + searchString + "'";
			}, 
			isInputFitRequirements: function(searchString){
				var reg_isInteger = /^\d+$/;
				if ((searchString.length === 20) && (reg_isInteger.test(searchString))) {
					return true;
				}
				return false;				
			}
		},
		{
			mapService: "http://www.appliomaps.lrc.gov.on.ca/ArcGIS/rest/services/MOE/permitstotakewater/MapServer",
			layerID: 0,
			displayPolygon: false,  //For non-polygon layers, it is always false. For polygon layers, you can turn on and off to visualize the polygon.  
			fieldsInInfoWindow: ["OFF_NAME"], 
			getInfoWindow: function(attributes){
				return "<strong>" + attributes.OFF_NAME + "</strong>";
			},
			latitude: "LAT_DD",
			longitude: "LONG_DD",
			getSearchCondition: function(searchString){
				return "UPPER(OFF_NAME) = '" + searchString.toUpperCase() + "'";
			}, 
			isInputFitRequirements: function(searchString){
				var coorsArray = searchString.toUpperCase().split(/\s+/);
				if((coorsArray.length <= 1)||(coorsArray.length >= 4)){
					return false;
				}				
				var str = coorsArray[coorsArray.length - 1];		
				if((str === "RIVER") || (str === "CREEK") || (str === "BROOK") || (str === "LAKE") || (str === "HILL")|| (str === "ISLAND")){
					return true;
				}
				return false;
			}
		}		
	];*/
	/* LOCATOR setting Ends */
	
LOCATOR = (function () {
	var regIsFloat = /^(-?\d+)(\.\d+)?$/;
 
	//http://appdelegateinc.com/blog/2010/05/16/point-in-polygon-checking/
	// Ray Cast Point in Polygon extension for Google Maps GPolygon
	// App Delegate Inc <htttp://appdelegateinc.com> 2010
    function isInPolygon(lat, lng1) {
        var lng = lng1;
        if (lng1 > 0) {
            lng = -lng;
        }
        var poly = globalConfig.regionBoundary;
        var numPoints = poly.length;
        var inPoly = false;
        var j = numPoints - 1;
        for (var i = 0; i < numPoints; i++) {
            var vertex1 = poly[i];
            var vertex2 = poly[j];

            if (vertex1.x < lng && vertex2.x >= lng || vertex2.x < lng && vertex1.x >= lng) {
                if (vertex1.y + (lng - vertex1.x) / (vertex2.x - vertex1.x) * (vertex2.y - vertex1.y) < lat) {
                    inPoly = !inPoly;
                }
            }

            j = i;
        }
        return inPoly;
    }
	
   function validateLatLng(lat, lng) {
        if (isInPolygon(lat, lng)) {
            return {
                latLng: new google.maps.LatLng(lat, lng),
                success: true
            };
        }else {
            return {success: false};
        }
    }
		
    function isInPolygonUTM(easting, northing) {
		var UTMRange = globalConfig.UTMRange;
        return ((easting < UTMRange.maxEasting) && (easting > UTMRange.minEasting) && (northing < UTMRange.maxNorthing) && (northing > UTMRange.minNorthing));
    }
	
    function replaceChar(str, charA, charB) {
        var temp = [];
        temp = str.split(charA);
        var result = temp[0];
        if (temp.length >= 2) {
            for (var i = 1; i < temp.length; i++) {
                result = result + charB + temp[i];
            }
        }
        return result;
    }
/*
    function convertUTMtoLatLng(zone, north, east) {
        var pi = 3.14159265358979; //PI
        var a = 6378137; //equatorial radius for WGS 84
        var k0 = 0.9996; //scale factor
        var e = 0.081819191; //eccentricity
        var e_2 = 0.006694380015894481; //e'2
        //var corrNorth = north; //North Hemishpe
        var estPrime = 500000 - east;
        var arcLength = north / k0;
        var e_4 = e_2 * e_2;
        var e_6 = e_4 * e_2;
        var t1 = Math.sqrt(1 - e_2);
        var e1 = (1 - t1) / (1 + t1);
        var e1_2 = e1 * e1;
        var e1_3 = e1_2 * e1;
        var e1_4 = e1_3 * e1;

        var C1 = 3 * e1 / 2 - 27 * e1_3 / 32;
        var C2 = 21 * e1_2 / 16 - 55 * e1_4 / 32;
        var C3 = 151 * e1_3 / 96;
        var C4 = 1097 * e1_4 / 512;

        var mu = arcLength / (a * (1 - e_2 / 4.0 - 3 * e_4 / 64 - 5 * e_6 / 256));
        var FootprintLat = mu + C1 * Math.sin(2 * mu) + C2 * Math.sin(4 * mu) + C3 * Math.sin(6 * mu) + C4 * Math.sin(8 * mu);
        var FpLatCos = Math.cos(FootprintLat);
        //var C1_an = e_2*FpLatCos*FpLatCos;
        var FpLatTan = Math.tan(FootprintLat);
        var T1 = FpLatTan * FpLatTan;
        var FpLatSin = Math.sin(FootprintLat);
        var FpLatSin_e = e * FpLatSin;
        var t2 = 1 - FpLatSin_e * FpLatSin_e;
        var t3 = Math.sqrt(t2);
        var N1 = a / t3;
        var R1 = a * (1 - e_2) / (t2 * t3);
        var D = estPrime / (N1 * k0);
        var D_2 = D * D;
        var D_4 = D_2 * D_2;
        var D_6 = D_4 * D_2;
        var fact1 = N1 * FpLatTan / R1;
        var fact2 = D_2 / 2;
        var fact3 = (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * e_2) * D_4 / 24;
        var fact4 = (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * e_2 - 3 * C1 * C1) * D_6 / 720;
        var lofact1 = D;
        var lofact2 = (1 + 2 * T1 + C1) * D_2 * D / 6;
        var lofact3 = (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * e_2 + 24 * T1 * T1) * D_4 * D / 120;
        var delta_Long = (lofact1 - lofact2 + lofact3) / FpLatCos;
        var zone_CM = 6 * zone - 183;
        var latitude = 180 * (FootprintLat - fact1 * (fact2 + fact3 + fact4)) / pi;
        var longitude = zone_CM - delta_Long * 180 / pi;
        var res = {
            Latitude: latitude.toFixed(8),
            Longitude: longitude.toFixed(8)
        };
        return res;
    }
	*/
	//Private method: get the centroid and add the polylines

	function returnCentroidAndPolyline(fset, latitude, longitude) {
		var totalX = 0;
		var totalY = 0;
		var totalArea = 0;
		var polylines = [];
		for (var polygonIndex = 0; polygonIndex < fset.features.length; polygonIndex++) {
			var att = fset.features[polygonIndex].attributes;
			var area = 0;
			for (var geometryIndex = 0; geometryIndex < fset.features[polygonIndex].geometry.length; geometryIndex++) {
				var gpolygon = fset.features[polygonIndex].geometry[geometryIndex];
				area = area + google.maps.geometry.spherical.computeArea(gpolygon.getPath());
				polylines.push(gpolygon);
			}
			totalY = totalY + (att[latitude] * area);
			totalX = totalX + (att[longitude] * area);
			totalArea = totalArea + area;
		}
		var gLatLng = new google.maps.LatLng(totalY/totalArea, totalX/totalArea);
		return {
			gLatLng: gLatLng, 
			polylines: polylines
		};
	}
	
	function returnCentroid(fset, latitude, longitude) {
		var totalX = 0;
		var totalY = 0;
		for (var i = 0; i < fset.features.length; i++) {
			var att = fset.features[i].attributes;
			totalY = totalY + att[latitude];
			totalX = totalX + att[longitude];
		}
		var gLatLng = new google.maps.LatLng(totalY/fset.features.length, totalX/fset.features.length);
		return {
			gLatLng: gLatLng
		};
	}
	
	LATLNG_LOCATOR = (function () {

		function processRegionValidation(v1, v2){
			var result = {lat: v1, lng: v2};
			result = globalConfig.validateLatLngWithRegion(v1, v2);
			return result;
		}
		//Private method: parse decimal degree.

		function processDecimalDegree(coorsArray) {
			if (regIsFloat.test(coorsArray[0])&&regIsFloat.test(coorsArray[1])) {					
				var v1 = Math.abs(parseFloat(coorsArray[0]));
				var v2 = Math.abs(parseFloat(coorsArray[1]));
				var result = processRegionValidation(v1, v2);
				return validateLatLng(result.lat, result.lng);
			} else {
				return {success:false};
			}
		}
		
		//Private method: Parse the string. called by parseLatLng

		function parseDMS(s, unparsed) {
			var res = {
				ParsedNum: 0,
				Unparsed: ""
			};
			if (unparsed.length === 0) {
				return res;
			}
			var arr = unparsed.split(s);
			var result = 0;
			if (arr.length <= 2) {
				if (regIsFloat.test(arr[0])) {						
					result = parseFloat(arr[0]);
				}
				if (arr.length === 2) {
					unparsed = arr[1];
				} else {
					unparsed = "";
				}
			}
			res = {
				ParsedNum: result,
				Unparsed: unparsed
			};
			return res;
		}
		
		//Private method: Parse the string by calling parseDMS. Called by processSymbol and processSymbolDMS

		function parseLatLng(val, s1, s2, s3) {
			var result = 0;
			var parsed = parseDMS(s1, val);
			var deg = parsed.ParsedNum;
			parsed = parseDMS(s2, parsed.Unparsed);
			var min = parsed.ParsedNum;
			parsed = parseDMS(s3, parsed.Unparsed);
			var sec = parsed.ParsedNum;
			if (deg > 0) {
				result = deg + min / 60.0 + sec / 3600.0;
			} else {
				result = deg - min / 60.0 - sec / 3600.0;
			}
			result = Math.abs(result);
			return result;
		}
		
		//Private method: parse symbol degree, minute and second. Need to call parseLatLng method.

		function processSymbol(coorsArray) {
			var degreeSym = String.fromCharCode(176);
			if (((coorsArray[0]).indexOf(degreeSym) > 0) && ((coorsArray[1]).indexOf(degreeSym) > 0)) {
				var v1 = parseLatLng(coorsArray[0], degreeSym, "'", "\"");
				var v2 = parseLatLng(coorsArray[1], degreeSym, "'", "\"");
				var result = processRegionValidation(v1, v2);
				return validateLatLng(result.lat, result.lng);
			} else {
				return {success:false};
			}
		}
		
		//Private method: valide whether input contains a number with D. called by processSymbolDMS

		function validateLatLngFormat(str) {
			for (var i = 0; i <= 9; i++) {
				if (str.indexOf(i + "D") > 0) {
					return 1;
				}
			}
			return 0;
		}
		
		//Private method: parse symbol (DMS) degree, minute and second. Need to call parseLatLng and validateLatLngFormat methods.

		function processSymbolDMS(coorsArray) {
			var str1 = (coorsArray[0]).toUpperCase();
			var str2 = (coorsArray[1]).toUpperCase();
			var valid = validateLatLngFormat(str1) * validateLatLngFormat(str2);
			if (valid > 0) {
				var v1 = parseLatLng(str1, "D", "M", "S");
				var v2 = parseLatLng(str2, "D", "M", "S");
				var result = processRegionValidation(v1, v2);
				return validateLatLng(result.lat, result.lng);
			} else {
				return {success:false};
			}
		}


		//Public method: use three methods: decimal degree, DMS, and DMS symbols to parse the input
		function process(queryParams, coorsArray) {
			if (coorsArray.length !== 2) {
				return {success:false};
			}
			var res = processDecimalDegree(coorsArray);
			if (!res.success) {
				res = processSymbol(coorsArray);
			}
			if (!res.success) {
				res = processSymbolDMS(coorsArray);
			}
			
			if (res.success) {
				queryParams.gLatLng = res.latLng;
				queryParams.callback(queryParams);
			}
			return res;
		}
				
		var module = {
			process: process
		};
		return module;
	})();

	//Parse the input as UTM
	UTM_LOCATOR = (function () {

		//Private method: Parse default UTM ZONE with only easting and northing

		function processDefaultZone(coorsArray, defaultZone) {
			if (coorsArray.length !== 2) {
				return {success:false};
			}
			if (regIsFloat.test(coorsArray[0])&&regIsFloat.test(coorsArray[1])) {			
				var v1 = Math.abs(parseFloat(coorsArray[0]));
				var v2 = Math.abs(parseFloat(coorsArray[1]));
				var v3 = Math.min(v1, v2);
				var v4 = Math.max(v1, v2);
				if (isInPolygonUTM(v3, v4)) {
					var latlng = globalConfig.convertUTMtoLatLng(defaultZone, v4, v3);
					return validateLatLng(latlng.Latitude, latlng.Longitude);
				} else {
					return {success:false};
				}
			} else {
				return {success:false};
			}
		}
		//Private method: Parse general UTM with zone, easting and northing

		function processGeneralUTM(coorsArray) {
			var res = {success:false};
			if (coorsArray.length !== 3) {
				return res;
			}
			var a1 = (coorsArray[0]).replace(",", " ").trim();
			var a2 = (coorsArray[1]).replace(",", " ").trim();
			var a3 = (coorsArray[2]).replace(",", " ").trim();
			if (regIsFloat.test(a1)&&regIsFloat.test(a2)&&regIsFloat.test(a3)) {
				var values = [Math.abs(parseFloat(a1)), Math.abs(parseFloat(a2)), Math.abs(parseFloat(a3))];
				values.sort(function (a, b) {
					return a - b;
				});
				var zoneStr = (values[0]).toString(); //zone
				var reg_isInteger = /^\d+$/;
				if (reg_isInteger.test(zoneStr)) {
					if ((values[0] >= 15) && (values[0] <= 18)) {
						if (isInPolygonUTM(values[1], values[2])) {
							var latlng = globalConfig.convertUTMtoLatLng(values[0], values[2], values[1]); //Zone, Northing, Easting
							return validateLatLng(latlng.Latitude, latlng.Longitude);
						}
					}
				}
			}
			return res;
		}
		function process(queryParams, coorsArray) {
			var res = processDefaultZone(coorsArray, globalConfig.defaultZone);
			if (!res.success) {
				res = processGeneralUTM(coorsArray);
			}
			if (res.success) {
				queryParams.gLatLng = res.latLng;
				queryParams.callback(queryParams);
			}
			return res;
		}		
		var module = {
			process: process
		};
		return module;
	})();

	//Parse the input as Township, Lot, Concession
	TWP_LOCATOR = (function () {


		//Private method: parse the input to get Lot, Concession

		function processLotCon(arr1) {
			if (arr1.length !== 2) {
				return {
					TWP: "",
					Lot: "",
					Con: "",
					isTWPOnly: false,
					success: false
				};
			}
			var TWPname = (arr1[0]).trim().split(/\s+/).join(' '); //replace multiple spaces with one space
			var con = "";
			var lot = "";
			if (((arr1[1]).indexOf("LOT") > 0) && ((arr1[1]).indexOf("CON") > 0)) {
				var arr2 = ((arr1[1]).trim()).split("CON");
				if ((arr2[0]).length === 0) {
					var arr3 = (arr2[1]).split("LOT");
					con = (arr3[0]).trim();
					lot = (arr3[1]).trim();
				} else {
					var arr4 = (arr2[0]).split("LOT");
					con = (arr2[1]).trim();
					lot = (arr4[1]).trim();
				}
			}
			var TWPOnly = false;
			if ((con.length === 0) && (lot.length === 0)) {
				TWPOnly = true;
			}
			return {
				TWP: TWPname,
				Lot: lot,
				Con: con,
				isTWPOnly: TWPOnly,
				success: true
			};
		}
		
		//Private method: parse the input to get Township, Lot, Concession by calling processLotCon

		function preprocessTWP(coors_Up) {
			var res = {
				TWP: "",
				Lot: "",
				Con: "",
				isTWPOnly: false,
				success: false
			};
			if (coors_Up.indexOf(' TWP') > 0) {
				res = processLotCon(coors_Up.split(" TWP"));
			}
			if (!res.success) {
				if (coors_Up.indexOf(' TOWNSHIP') > 0) {
					res = processLotCon(coors_Up.split(" TOWNSHIP"));
				}
			}
			if (!res.success) {
				if (coors_Up.indexOf('CANTON ') === 0) {
					var str = coors_Up.substring(7).trim();
					var lotIndex = str.indexOf(" LOT ");
					var conIndex = str.indexOf(" CON ");
					var index = lotIndex;
					if (conIndex < lotIndex) {
						index = conIndex;
					}
					var parsedList = [];
					if (index === -1) {
						parsedList.push(str);
						parsedList.push("");
					} else {
						parsedList.push(str.substring(0, index));
						parsedList.push(str.substring(index));
					}
					res = processLotCon(parsedList);
				}
			}
			return res;
		}
		
		//Public method: parse the input as Township, Lot, Concession information by calling preprocessTWP, getCentroidAndAddPolylines

		function process(queryParams, coorsArray) {
			var coors_Up = coorsArray.join(' ').toUpperCase();
			var twpInfo = preprocessTWP(coors_Up);

			if (twpInfo.success) {
				var geogTwpService = globalConfig.geogTwpService;								
				var params = {
					returnGeometry: true,
					outFields: [geogTwpService.latitude, geogTwpService.longitude]
				};
				var layerId;
				if (twpInfo.isTWPOnly) {
					params.where = geogTwpService.TWPLayerNameField + " = '" + twpInfo.TWP + "'";
					layerId = geogTwpService.TWPLayerID; //Twp layer
					globalConfig.TWPSearch = true;
				} else {
					params.where = geogTwpService.LotLayerNameFields.TownshipField + " = '" + twpInfo.TWP + "' AND " + geogTwpService.LotLayerNameFields.ConField + " = 'CON " + twpInfo.Con + "' AND " + geogTwpService.LotLayerNameFields.LotField + " = 'LOT " + twpInfo.Lot + "'";
					layerId = geogTwpService.LotLayerID; //Lot Con layer
					globalConfig.TWPLotConSearch = true;
				}
				
				var layer = new gmaps.ags.Layer(geogTwpService.url + "/" + layerId);
				layer.query(params, function (fset) {
					if (fset.features.length > 0) {
						var res = returnCentroidAndPolyline(fset, geogTwpService.latitude, geogTwpService.longitude);
						queryParams.gLatLng = res.gLatLng;
						queryParams.polylines = res.polylines;
						queryParams.zoomlevel = (twpInfo.isTWPOnly) ? globalConfig.twpZoomLevel : globalConfig.lotConcessionZoomLevel;
						queryParams.callback(queryParams);
					} else {
						//console.log("1");
						queryParams.totalCount = 0;
						globalConfig.resultFoundSimple(queryParams);
						//globalConfig.noResultFound();
					}
				});
				return {
					success: true
				};
			} else {
				return {success:false};
			}
		}		
		var module = {
			process: process
		};
		return module;
	})();

	ADDRESS_LOCATOR = (function () {
	    //validate the input is a latitude & longitude. 
		function validateLatLngSearch (coorsArray) {
			if (coorsArray.length === 2) {
				if (regIsFloat.test(coorsArray[0])&&regIsFloat.test(coorsArray[1])) {
					return true;
				}
				var degreeSym = String.fromCharCode(176);
				if (((coorsArray[0]).indexOf(degreeSym) > 0) && ((coorsArray[1]).indexOf(degreeSym) > 0)) {
					return true;
				}
				var validateLatLngFormat = function(str) {
					for (var i = 0; i <= 9; i++) {
						if (str.indexOf(i + "D") > 0) {
							return 1;
						}
					}
					return 0;
				};
				var str1 = (coorsArray[0]).toUpperCase();
				var str2 = (coorsArray[1]).toUpperCase();
				var valid = validateLatLngFormat(str1) * validateLatLngFormat(str2);
				if (valid > 0) {
					return true;					
				}
			}
			return false;
		}
		
		//Public method: parse the input as address information by calling isContarionOntario and showRevGeocodeResult		
		function process(queryParams, coorsArray) {
			if (validateLatLngSearch(coorsArray)) {
				queryParams.totalCount = 0;
				globalConfig.resultFoundSimple(queryParams);			
				//globalConfig.noResultFound();
				return;
			}
			
			var geocoder = new google.maps.Geocoder();
			var addressStr = queryParams.address;
			if (addressStr.toUpperCase() === "ONTARIO") {
				queryParams.totalCount = 0;
				globalConfig.resultFoundSimple(queryParams);			
				//globalConfig.noResultFound();
				return;
			}
			addressStr = globalConfig.regionAddressProcess(addressStr);
			geocoder.geocode({
				'address': addressStr
			}, function (results, status) {
				if (status === google.maps.GeocoderStatus.OK) {
					var max = results.length;
					var notMoved = true;
					for (var i = 0; i < max; i++) {
						var point = results[i].geometry.location;
						var failedPositions = globalConfig.failedLocation.positions;
						var failedDifference = globalConfig.failedLocation.difference;
						var isThisPositionFailed = false;
						for (var j = 0; j < failedPositions.length; j ++) {
							var diff = Math.abs(point.lat() - failedPositions[j][0]) + Math.abs(point.lng() - failedPositions[j][1]);
							if (diff < failedDifference){
								isThisPositionFailed = true;
								break;
							}							
						}
						if (isThisPositionFailed) {
							continue;
						} 
						if (isInPolygon(point.lat(), point.lng())) {
							queryParams.gLatLng = point;
							queryParams.returnedAddress = results[i].formatted_address.toString();
							queryParams.callback(queryParams);
							notMoved = false;
							break;
						}
					}
					if (notMoved) {
						queryParams.totalCount = 0;
						globalConfig.resultFoundSimple(queryParams);					
						//globalConfig.noResultFound();
					}
				} else {
					queryParams.totalCount = 0;
					globalConfig.resultFoundSimple(queryParams);				
					//globalConfig.noResultFound();
				}
			});
		}
		var module = {
			process: process
		};
		return module;
	})();
	

	
    function locate(queryParams) {
        var coors = replaceChar(queryParams.address, ',', ' ').trim();
        var coorsArray = coors.split(/\s+/);
		var res = {success: false};
		/*Use the location service defined in configuration to search the user input. */
		if(typeof(globalConfig.locationServicesList) !== "undefined"){
			for (var i = 0; i < globalConfig.locationServicesList.length; i++) {
				var service = globalConfig.locationServicesList[i];
				if((!res.success)&&service.isInputFitRequirements(coors)){
					res.success = true;
					service.returnGeometry = false;
					if(service.displayPolygon){
						service.returnGeometry = true;
					}
					var outFields2 = service.fieldsInInfoWindow;
					outFields2.push(service.latitude);
					outFields2.push(service.longitude);
					var params = {
						returnGeometry: service.returnGeometry,
						where: service.getSearchCondition(coors),
						outFields: outFields2
					};
					var layer = new gmaps.ags.Layer(service.mapService + "/" +  service.layerID);
					var getInfoWindow = service.getInfoWindow;
					var displayPolygon = service.displayPolygon;
					var latField = service.latitude;
					var lngField = service.longitude;
					layer.query(params, function (fset) {
						var size = 0;
						if(fset){
							size = fset.features.length;
							if (size > 0) {
								queryParams.address = getInfoWindow(fset.features[0].attributes);
								if(displayPolygon){
									var centroid = returnCentroidAndPolyline(fset, latField, lngField);
									queryParams.gLatLng = centroid.gLatLng;
									queryParams.polylines = centroid.polylines;
									queryParams.callback(queryParams);
								}else{
									var centroid2 = returnCentroid(fset, latField, lngField);
									queryParams.gLatLng = centroid2.gLatLng;
									queryParams.callback(queryParams);									
								}
							}else{
								return {success: false};
							}
						}else{
							return {success: false};
						}
					});							
				}
			}
		}
		
		var locatorsAvailable = globalConfig.locatorsAvailable;
		if((!res.success)&&locatorsAvailable.latlng){
			res = LATLNG_LOCATOR.process(queryParams, coorsArray);
		}
        if ((!res.success)&&locatorsAvailable.utm) {
            res = UTM_LOCATOR.process(queryParams, coorsArray);
        }
        if ((!res.success)&&locatorsAvailable.township) {
            res = TWP_LOCATOR.process(queryParams, coorsArray);
        }
        if ((!res.success)&&locatorsAvailable.address) {
            res = ADDRESS_LOCATOR.process(queryParams, coorsArray);
        }
    }
    var module = {
        locate: locate
    };
    return module;
})();
/*global TABS_CALCULATOR:false */

TABS_CALCULATOR = (function () {
	/*call by getRequiredFields. This function is called recursively to find the fields used in the Tab*/
	function getRequiredFieldsFromOneString(infoWindowString, fields){
		var start = infoWindowString.indexOf("{");
        var end = infoWindowString.indexOf("}");
        if ((start >= 0) && (end >= 0)) {
			var str1 = infoWindowString.substring(0, start);
			var str2 = infoWindowString.substring(start + 1, end);
			var str3 = infoWindowString.substring(end + 1);
			var funStart = str2.indexOf("(");
			var funEnd = str2.indexOf(")");
			if ((funStart >= 0) && (funEnd >= 0)) { //function
				var parameters = str2.substring(funStart + 1, funEnd);
				var paraArray = parameters.split(",");
				for (var j = 0; j < paraArray.length; j++) {
					fields.push((paraArray[j]).trim());
				}
			}else{
				fields.push(str2.trim());
			}
			infoWindowString = getRequiredFieldsFromOneString(str3, fields);
		}
		return fields;
	}
	
    function removeConditionInfoWindow(infoWindowString, attributes, start, end) {
        var str1 = infoWindowString.substring(0, start);
        var str2 = infoWindowString.substring(start + 1, end);
        var str3 = infoWindowString.substring(end + 1);
        var index = str2.indexOf("}");
        var fieldName = str2.substring(1, index);
        var str4 = str2.substring(index + 2);
        index = str4.indexOf("?");
        var result = "";
        if (attributes[fieldName] > 0) {
            result = str1 + str4.substring(index + 1);
        } else {
            result = str1 + str4.substring(0, index);
        }
        var start1 = str3.indexOf("[");
        var end1 = str3.indexOf("]");
        if ((start1 >= 0) && (end1 >= 0)) {
            str3 = removeConditionInfoWindow(str3, attributes, start1, end1);
        }
        result = result + str3;
        return result;
    }
	
    function processNA(str) {
        if (typeof(str) === 'undefined') {
            return "N/A";
        }
        if (str === "null") {
            return "N/A";
        }
        if (str === "Null") {
            return "N/A";
        }
        return str;
    }

    function getInfoWindowString(infoWindowString, attributes, start, end) {
        var str1 = infoWindowString.substring(0, start);
        var fieldName = infoWindowString.substring(start + 1, end);
        var str3 = infoWindowString.substring(end + 1);

        var dataStr = " ";
        var funStart = fieldName.indexOf("(");
        var funEnd = fieldName.indexOf(")");
        if ((funStart >= 0) && (funEnd >= 0)) {
            var funName = fieldName.substring(0, funStart);
            var parameters = fieldName.substring(funStart + 1, funEnd);
            var paraArray = parameters.split(",");
            funName = funName + "(";
            for (var j = 0; j < paraArray.length; j++) {
                if ((paraArray[j]).indexOf("'") === -1) {
                    var attrValue = attributes[(paraArray[j]).trim()];
					attrValue = processNA(attrValue);
					if(attrValue === null){
						attrValue = "N/A";
					}
                    if (typeof attrValue === "number") {						
                        funName = funName + attrValue;
                    }
                    if (typeof attrValue === "string") {
                        if (attrValue.indexOf("'") === -1) {
                            funName = funName + "'" + attrValue + "'";
                        } else if (attrValue.indexOf('"') === -1) {
                            funName = funName + "\"" + attrValue + "\"";
                        } else {
                            //funName = funName + '"' + attrValue.replace('"', '\"') + '"';
							funName = funName + '"' + attrValue.replace('"', "\\\"") + '"';
                        }
                    }
                } else {
                    funName = funName + paraArray[j];
                }
                if (j < paraArray.length - 1) {
                    funName = funName + ",";
                }
            }
			
            funName = funName + ");";
            dataStr = eval(funName);
        } else {
            if (attributes[fieldName] !== "Null") {
                dataStr = attributes[fieldName];
            }
        }
        var start1 = str3.indexOf("{");
        var end1 = str3.indexOf("}");
        if ((start1 >= 0) && (end1 >= 0)) {
            str3 = getInfoWindowString(str3, attributes, start1, end1);
        }
        var result = str1 + dataStr + str3;
        return result;
    }
	
    function getInfoWindowContent(attributes, infoWindowString) {
        var start = infoWindowString.indexOf("[");
        var end = infoWindowString.indexOf("]");
        if ((start >= 0) && (end >= 0)) {
            infoWindowString = removeConditionInfoWindow(infoWindowString, attributes, start, end);
        }
        start = infoWindowString.indexOf("{");
        end = infoWindowString.indexOf("}");
        if ((start >= 0) && (end >= 0)) {
            infoWindowString = getInfoWindowString(infoWindowString, attributes, start, end);
        }
        return infoWindowString;
    }

	/*call getRequiredFieldsFromOneString to figure out the required fields in tabs*/
    function getRequiredFields(tabs) {
        var fields = [];
        for (var i = 0; i < tabs.length; i++) {
            var tab = tabs[i];
            fields = getRequiredFieldsFromOneString(tab.label, fields);
			fields = getRequiredFieldsFromOneString(tab.content, fields);
        }
        return fields.unique();
    }
	
   function getContent(attributes, tabs) {
        var contents = [];
        for (var i = 0; i < tabs.length; i++) {
            var tab = tabs[i];
            var tabName = getInfoWindowContent(attributes, tab.label);
            if (tabName.trim().length > 1) {
                var tabContent = getInfoWindowContent(attributes, tab.content);
				//console.log(i);
				//console.log(tabContent);
                contents.push({
                    label: tabName,
                    content: tabContent
                });
            }
        }
		//console.log(contents[0]);
		//console.log(contents[0].content);
        return contents;
    }	
    var module = {
        getContent: getContent,
		getRequiredFields: getRequiredFields
    };
    return module;
})();
/*global document:false */
/*global google:false */
/*global gmaps:false */
/*global MOEMAP:false */
/*global INITIALIZATION:false */
	var globalConfig = globalConfig || {};
	globalConfig.testDivExist = globalConfig.testDivExist || function (divId) {
		return (!!document.getElementById(divId))
	};
	globalConfig.disclaimerDivId = globalConfig.disclaimerDivId || 'disclaimer';
	//if (typeof globalConfig.displayDisclaimer === "undefined"){globalConfig.displayDisclaimer = false;}
	globalConfig.coordinatesDivId = globalConfig.coordinatesDivId || 'coordinates';    //The div id for coordinates status.
	globalConfig.updateCoordinates = globalConfig.updateCoordinates || function(lat, lng){
		var utm = globalConfig.convertLatLngtoUTM(lat, lng);
		//document.getElementById(globalConfig.coordinatesDivId).innerHTML = "Latitude:" + lat.toFixed(6) + ", Longitude:" + lng.toFixed(6) + " (" + globalConfig.UTM_ZoneLang + ":" + utm.Zone + ", " + globalConfig.EastingLang + ":" + utm.Easting + ", " + globalConfig.NorthingLang +":" + utm.Northing + ") <br><br><div align=\"left\">" + globalConfig.designLang + "</div><br>";
		document.getElementById(globalConfig.coordinatesDivId).innerHTML = "Latitude:" + lat.toFixed(5) + ", Longitude:" + lng.toFixed(5) + " (" + globalConfig.UTM_ZoneLang + ":" + utm.Zone + ", " + globalConfig.EastingLang + ":" + utm.Easting + ", " + globalConfig.NorthingLang +":" + utm.Northing + ")<br>";
	};
	//globalConfig.defaultCoordinateLang = globalConfig.defaultCoordinateLang || "Latitude : 48.950861, Longitude : -83.486242 (" + globalConfig.UTM_ZoneLang + ":17, " + globalConfig.EastingLang + ":317978.96, " + globalConfig.NorthingLang + ":5424971.70)  <br><br><div align=\"left\">" + globalConfig.designLang + "</div><br>";		
	
	if (typeof globalConfig.useSystemDefinedInit === "undefined"){globalConfig.useSystemDefinedInit = true;}
	if (typeof globalConfig.allowMultipleIdentifyResult === "undefined"){globalConfig.allowMultipleIdentifyResult = true;}
	if (typeof globalConfig.displayTotalIdentifyCount === "undefined"){globalConfig.displayTotalIdentifyCount = true;}
	if (typeof globalConfig.isCoordinatesVisible === "undefined"){globalConfig.isCoordinatesVisible = true;}	
	
	globalConfig.orgLatitude = globalConfig.orgLatitude || 49.764775;
	globalConfig.orgLongitude = globalConfig.orgLongitude || -85.323214;
	globalConfig.orgzoomLevel = globalConfig.orgzoomLevel || 5;
	globalConfig.lotConcessionZoomLevel = globalConfig.lotConcessionZoomLevel || 14;
	globalConfig.twpZoomLevel = globalConfig.twpZoomLevel || 11;
	globalConfig.minMapScale = globalConfig.minMapScale || 5;
	globalConfig.maxMapScale = globalConfig.maxMapScale || 21;
	globalConfig.tableID = globalConfig.tableID || "myTable";
	globalConfig.tableWidth = globalConfig.tableWidth || 650; //The total width of the table below the map
	if(!globalConfig.accessible){
		globalConfig.defaultMapTypeId = globalConfig.defaultMapTypeId || google.maps.MapTypeId.ROADMAP;
	}
	globalConfig.accessibleTableClassName = globalConfig.accessibleTableClassName || "fishTable";	
	globalConfig.generalTableClassName = globalConfig.generalTableClassName || "tablesorter";	
	globalConfig.accessible = globalConfig.accessible || false;
	if(globalConfig.accessible){
		globalConfig.tableClassName = globalConfig.accessibleTableClassName;
	} else {
		globalConfig.tableClassName = globalConfig.generalTableClassName;	
	}
	globalConfig.mapCanvasDivId = globalConfig.mapCanvasDivId || "map_canvas";
	globalConfig.opacity = globalConfig.opacity || 1;   //define the layer's opacity.
	globalConfig.locationTypeSelectionDivId = globalConfig.locationTypeSelectionDivId || "locationType";
	globalConfig.radiusSelectionDivId = globalConfig.radiusSelectionDivId || "lstRadius";
	globalConfig.businessTypeParameter = globalConfig.businessTypeParameter || "Business";
	globalConfig.searchBusinessDivId = globalConfig.searchBusinessDivId || "searchBusiness";
	globalConfig.searchLocationDivId = globalConfig.searchLocationDivId || "searchLocation";
	globalConfig.searchInputBoxDivId = globalConfig.searchInputBoxDivId || "map_query";
	globalConfig.currentMapExtentDivId = globalConfig.currentMapExtentDivId || "currentMapExtent";
	globalConfig.preInitialize = globalConfig.preInitialize || function(){
	};
	globalConfig.postInitialize = globalConfig.postInitialize || function(map){
		//console.log(map);
		if (document.getElementById(globalConfig.searchBusinessDivId)) {
			document.getElementById(globalConfig.searchBusinessDivId).checked = true;
		}
		if(document.getElementById(globalConfig.searchLocationDivId)){
			document.getElementById(globalConfig.searchLocationDivId).checked = false;
		}
		if(document.getElementById(globalConfig.radiusSelectionDivId)){
			document.getElementById(globalConfig.radiusSelectionDivId).disabled = true;
		}
		if(document.getElementById(globalConfig.searchInputBoxDivId)){
			document.getElementById(globalConfig.searchInputBoxDivId).focus();//Make sure the input box is focused when the page is initialized.
		}	
	};
	//if this function is defined, the program will call this rather the predefine initialization method. use it with caution.
	/*selfDefinedInitialize: function(){}*/

	globalConfig.searchChange = globalConfig.searchChange || function(type){
		if(type === globalConfig.businessTypeParameter){
			document.getElementById(globalConfig.radiusSelectionDivId).disabled = true;
		}else{
			document.getElementById(globalConfig.radiusSelectionDivId).disabled = false;
		}
	};
	globalConfig.search = globalConfig.search || function(){
			var name = document.getElementById(globalConfig.searchInputBoxDivId).value.trim();
			if(name.length === 0){
				return;
			}
			document.getElementById(globalConfig.queryTableDivId).innerHTML = "";
			MOEMAP.clearOverlays();
			if(document.getElementById(globalConfig.searchBusinessDivId).checked){
				name = name.toUpperCase();
				name = globalConfig.replaceChar(name, "'", "''");
				name = globalConfig.replaceChar(name, globalConfig.u2019Lang, "''");
				var attributeSearchItems = globalConfig.attributeSearchItems;
				MOEMAP.queryLayerWithFuzzyMatch(attributeSearchItems[0].field, name);
				return;
			}
			if(document.getElementById(globalConfig.searchLocationDivId).checked){
				var radius = document.getElementById(globalConfig.radiusSelectionDivId).value;
				MOEMAP.queryLayerWithLocationRadius(name, radius);
			}			
	};
	globalConfig.extraImageService = globalConfig.extraImageService || {
		id: "arcgis",
		name: "ESRI",
		url: 'http://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer',
		visible: true
	};
	globalConfig.entsub = globalConfig.entsub || function(event){
		if (event && event.which === 13){
			globalConfig.search();
		}else{
			return true;
		}
	};
	globalConfig.searchTheMapDivId = globalConfig.searchTheMapDivId || 'searchTheMap';
	globalConfig.searchHelpDivId = globalConfig.searchHelpDivId || 'searchHelp';
	globalConfig.informationDivId = globalConfig.informationDivId || 'information';
	globalConfig.createTablesInfoWindows = globalConfig.createTablesInfoWindows || function(tabsTableTemplate) {
		var mapfunction = function(tab) {
			return {label: tab.label,
				head: "<table class='tabtable'><tr><th>" + tab.content.map(function(b) {return b.name;}).join("</th><th>") + "</th></tr>",
				content: "<tr><td>" + tab.content.map(function(b) {return b.value;}).join("</td><td>") + "</td></tr>",
				tail: "</table>"};
		};
		return tabsTableTemplate.map(mapfunction)
	};

	globalConfig.createTableBelowMap = globalConfig.createTableBelowMap || function(tableSimpleTemplate) {
		return {
			head: tableSimpleTemplate.title + "<table id=\"" + globalConfig.tableID + "\" class=\"" + globalConfig.tableClassName + "\" width=\"" + globalConfig.tableWidth + "\" border=\"0\" cellpadding=\"0\" cellspacing=\"1\"><thead><tr><th><center>" + tableSimpleTemplate.content.map(function(b) {return b.name;}).join("</center></th><th><center>") + "</center></th></tr></thead><tbody>",
			content: "<tr><td>" + tableSimpleTemplate.content.map(function(b) {return b.value;}).join('</td><td>') + "</td></tr>",
			tail: "</tbody></table>"
		};
	};
	globalConfig.noCoordinatesTableID = globalConfig.noCoordinatesTableID || "noCoordinatesTable";
	globalConfig.createNoCoordinatesTableBelowMap = globalConfig.createNoCoordinatesTableBelowMap || function(tableSimpleTemplate) {
		//console.log(tableSimpleTemplate);
		return {
			head: globalConfig.noCoordinatesTableTitleLang + "<table id=\"" + globalConfig.noCoordinatesTableID + "\" class=\"" + globalConfig.tableClassName + "\" width=\"" + globalConfig.tableWidth + "\" border=\"0\" cellpadding=\"0\" cellspacing=\"1\"><thead><tr><th><center>" + tableSimpleTemplate.content.map(function(b) {return b.name;}).join("</center></th><th><center>") + "</center></th></tr></thead><tbody>",
			content: "<tr><td>" + tableSimpleTemplate.content.map(function(b) {return b.value;}).join('</td><td>') + "</td></tr>",
			tail: "</tbody></table>"
		};
	};	
/*	
	globalConfig.searchControlHTMLGenerator = globalConfig.searchControlHTMLGenerator || function () {
		return '<table width="100%" cellpadding="5" cellspacing="0" border="0" style="margin-bottom:15px;" summary="' 
				+ globalConfig.SearchInteractiveMapFormLang  + '">' +
				'<caption style="text-align:left;">' + globalConfig.SearchInteractiveMapLang  + '</caption>' + 
				'<tr>' + 
					'<th scope="col"></th>' + 
					'<th scope="col"></th>' + 
				'</tr>' + 
				'<tr>' + 
					'<td valign="top" width="'+ globalConfig.InputBoxSizeLang  + '">' + 
						'<input id="map_query" type="text" size="50" onkeypress="return globalConfig.entsub(event)" maxlength="100" title="' 
							+ globalConfig.TermLang  + '"></input>' + globalConfig.nbspLang + '<input type="submit" onclick="globalConfig.search()" value="' + 
							globalConfig.SearchLang  + '" title="' + globalConfig.SearchLang  + '"></input>' + 
					'</td>' + 
					'<td valign="top">'+ 	
						'<input id="currentMapExtent" type="checkbox" name="currentExtent" title="' + globalConfig.CurrentMapDisplayLang  + '"><span title="' + globalConfig.CurrentMapDisplayTitleLang  + '" class="tooltip">' + globalConfig.CurrentMapDisplayLang  + '</span>' + 
					'</td>' + 
				'</tr>' + 
				'<tr>' + 
					'<td colspan="2">' + 
						'<div id="information" style="margin-top:10px;">' + 
							globalConfig.searchHelpTxt + 
						'</div>' + 
					'</td>' + 
				'</tr>' + 
			'</table>';
	};
*/
	globalConfig.chooseLang = globalConfig.chooseLang || function (en, fr) {return (globalConfig.language === "EN") ? en : fr;};
	if ((globalConfig.searchableFieldsList) && (!globalConfig.searchHelpTxt)) {
		globalConfig.searchHelpTxt = globalConfig.youMaySearchByLang;
		for(var i=0; i<globalConfig.searchableFieldsList.length - 1; i++) {
			globalConfig.searchHelpTxt = globalConfig.searchHelpTxt + "<strong>" + globalConfig.chooseLang(globalConfig.searchableFieldsList[i].en, globalConfig.searchableFieldsList[i].fr) + "</strong>, ";
		}
		globalConfig.searchHelpTxt = globalConfig.searchHelpTxt + "<strong>" + globalConfig.chooseLang(globalConfig.searchableFieldsList[i].en, globalConfig.searchableFieldsList[i].fr) + "</strong> " + globalConfig.seeHelpForAdvancedOptionsLang;
	}
	globalConfig.searchControlHTMLGenerator = globalConfig.searchControlHTMLGenerator || function () {
		//return //'<h4>' + globalConfig.SearchInteractiveMapLang  + '</h4>' + 
			//'<div id="information">' + globalConfig.searchHelpTxt + '</div>' + 
			//'<input id="map_query" type="text" size="50" onkeypress="return globalConfig.entsub(event)" maxlength="100" title="' + globalConfig.TermLang  + '">' + globalConfig.nbspLang + '<input type="submit" onclick="globalConfig.search()" value="' + globalConfig.SearchLang  + '" title="' + globalConfig.SearchLang  + '"><br/>' + 
			//'<input id="currentMapExtent" type="checkbox" name="currentExtent" title="' + globalConfig.CurrentMapDisplayLang  + '"> <label for="currentExtent" class=\'option\'>' + globalConfig.CurrentMapDisplayLang  + '</label>';			
		/*return '<label class="element-invisible" for="map_query">Search the map</label> \
			<input id="map_query" type="text" size="50" onkeypress="return globalConfig.entsub(event)" maxlength="100" title="Search term" /> \
			<label class="element-invisible" for="search_submit">Search</label> \
			<input type="submit" onclick="globalConfig.search()" id="search_submit" value="Search" title="Search" /> \
			<br/> \
			<input id="currentMapExtent" type="checkbox" name="currentExtent" title="Current Map Display"> \
			<label for="currentExtent" class=\'option\'>' + globalConfig.CurrentMapDisplayLang + '</label>';*/
		return '<div id="searchTheMap"></div><div id="searchHelp"></div><br>\
			<label class="element-invisible" for="map_query">' + globalConfig.chooseLang('Search the map', 'Recherche carte interactive') + '</label>\
			<input id="map_query" type="text" title="' + globalConfig.chooseLang('Search term', 'Terme de recherche') + '" maxlength="100" size="50" onkeypress="return globalConfig.entsub(event)"></input>\
			<label class="element-invisible" for="search_submit">' + globalConfig.chooseLang('Search', 'Recherche') + '</label>\
			<input id="search_submit" type="submit" title="' + globalConfig.chooseLang('Search', 'Recherche') + '" onclick="globalConfig.search()" value="' + globalConfig.chooseLang('Search', 'Recherche') + '"></input>\
			<br/>\
			<input id="currentMapExtent" type="checkbox" name="currentExtent" title="' + globalConfig.chooseLang('Current Map Display', "tendue de la carte courante") + '" /> <label for="currentExtent" class=\'option\'>' + globalConfig.chooseLang('Search current map display only', "\u00c9tendue de la carte courante") + '</label>\
			<div id="information"></div>';
	};
	
	if(!globalConfig.hasOwnProperty('searchControlHTML')) {
		//If the configuration file does not contain searchControlHTML, use the default generator to create it. 
		globalConfig.searchControlHTML = globalConfig.searchControlHTMLGenerator();
	}
	// 
	/*Map Initialization module provides the init method to be called to initialize the Google Maps and other setting. */
	INITIALIZATION = (function () {
		/*
			Use the tabsTableTemplate to generate the tabsTemplate. This is used to generate the table in the pop-up window. 
			Use tableSimpleTemplate to generate the tableTemplate. This is used to generate the table in the bottom of the Google Maps. 
		*/
		function setupTableTemplate(){
			if((!globalConfig.hasOwnProperty('queryLayerList')) && globalConfig.hasOwnProperty('identifyMultiplePolygonLayersServicesTemplate')) {
				globalConfig.queryLayerList = globalConfig.identifyMultiplePolygonLayersServicesTemplate.layerList;
				if (globalConfig.identifyMultiplePolygonLayersServicesTemplate.hasOwnProperty('merge')) {
					globalConfig.mergeFunction = globalConfig.identifyMultiplePolygonLayersServicesTemplate.merge;
				}
			} else {
				var getRequiredFields = function (tabs) {
					var getRequiredFieldsFromOneString = function (infoWindowString, fields){
						var start = infoWindowString.indexOf("{");
						var end = infoWindowString.indexOf("}");
						if ((start >= 0) && (end >= 0)) {
							var str1 = infoWindowString.substring(0, start);
							var str2 = infoWindowString.substring(start + 1, end);
							var str3 = infoWindowString.substring(end + 1);
							var funStart = str2.indexOf("(");
							var funEnd = str2.indexOf(")");
							if ((funStart >= 0) && (funEnd >= 0)) { //function
								var parameters = str2.substring(funStart + 1, funEnd);
								var paraArray = parameters.split(",");
								for (var j = 0; j < paraArray.length; j++) {
									fields.push((paraArray[j]).trim());
								}
							}else{
								fields.push(str2.trim());
							}
							infoWindowString = getRequiredFieldsFromOneString(str3, fields);
						}
						return fields;
					};
					var fields = [];
					for (var i = 0; i < tabs.length; i++) {
						var tab = tabs[i];
						fields = getRequiredFieldsFromOneString(tab.label, fields);
						fields = getRequiredFieldsFromOneString(tab.content, fields);
					}
					return fields.unique();
				};			
				for (var i=0; i<globalConfig.queryLayerList.length; i++) {
					var layerSetting = globalConfig.queryLayerList[i];	
					if ((!layerSetting.hasOwnProperty('tabsTemplate')) && layerSetting.hasOwnProperty('tabsTableTemplate')) {
						//console.log("should not");
						layerSetting.tabsTemplate = globalConfig.createTablesInfoWindows(layerSetting.tabsTableTemplate);		
					}
					var outFields = [];
					if(layerSetting.hasOwnProperty('tabsTemplate')) {
						//console.log(layerSetting.tabsTemplate);
						outFields = getRequiredFields(layerSetting.tabsTemplate);
					}
					if ((!layerSetting.hasOwnProperty('tableTemplate')) && layerSetting.hasOwnProperty('tableSimpleTemplate')) {
						layerSetting.tableTemplate = globalConfig.createTableBelowMap(layerSetting.tableSimpleTemplate);
						//console.log(layerSetting.tableTemplate);
						layerSetting.noCoordinatesTableTemplate = globalConfig.createNoCoordinatesTableBelowMap(layerSetting.tableSimpleTemplate);
						//console.log(layerSetting.noCoordinatesTableTemplate);
					}
					if(layerSetting.hasOwnProperty('tableTemplate')) {
						var outFields2 = getRequiredFields([{ label:globalConfig.InformationLang, content:layerSetting.tableTemplate.content}]); 
						if(outFields.length === 0) {
							outFields = outFields2.unique();
						} else {
							outFields = outFields.concat(outFields2).unique();
						}
					}
					globalConfig.queryLayerList[i].outFields = outFields;
				}
			}			
			/*
				If the tabsTemplate is not defined in the configuration, use the tabsTableTemplate item in the configuration to generate it.
				The tabsTemplate is an object array. Every element in this array is related to one tab in the popup window. Every element 
				has the following four properties: label, head, content, and tail. The label is the tab name. The head and the tail are only 
				repeat only once even if there are multiple results. The head is located in the beginning and the tail is located in the ending. 
				The content part will be repeated several times. The number of times is equal to the total number of records. 
				
				The tabsTableTemplate is an object array. Each element in this array contains two properties: label and content. The label is the 
				tab name and the content is an object array. The object array of content contains the objects with two properties: name and value. 
				The name property contains the field name in the table in the tab, while the value property contains the formule to calculate the value
				which will be displayed in the table. 
			
			if(!accessible){
				if(typeof(globalConfig.tabsTemplate) === "undefined"){
					var tabsTableTemplate = globalConfig.tabsTableTemplate;
					if(typeof(tabsTableTemplate) !== "undefined"){
						globalConfig.tabsTemplate = tabsTableTemplate.map(function(a) {
								return {label: a.label,
									head: "<table><tr><th>" + a.content.map(function(b) {return b.name;}).join("</th><th>") + "</th></tr>",
									content: "<tr><td>" + a.content.map(function(b) {return b.value;}).join("</td><td>") + "</td></tr>",
									tail: "</table>"};
						});
					}
				}
			}
			/*
				If the tableTemplate is not defined in the configuration, use the tableSimpleTemplate item in the configuration to generate it.
				The tableTemplate is an object with the following three properties: head, content, and tail. The head is the table head and the tail 
				is the table tail. Both of them only repeat once. The content part will be repeated several times. The number of times is equal to 
				the total number of records. 
				
				The tableSimpleTemplate is an object with two properties: title and content. The title is the content which will be displayed above the table
				and the content is an object array. The object array of content contains the objects with two properties: name and value. 
				The name property contains the field name in the table, while the value property contains the formule to calculate the value
				which will be displayed in the table. 
			
			if(typeof(globalConfig.tableTemplate) === "undefined"){			
				var tableSimpleTemplate = globalConfig.tableSimpleTemplate;
				if(typeof(tableSimpleTemplate) !== "undefined"){
					globalConfig.tableTemplate = {
						head: tableSimpleTemplate.title + "<table id=\"" + globalConfig.tableID + "\" class=\"" + globalConfig.tableClassName + "\" border=\"0\" cellpadding=\"0\" cellspacing=\"1\"><thead><tr><th><center>" + tableSimpleTemplate.content.map(function(b) {return b.name;}).join("</center></th><th><center>") + "</center></th></tr></thead><tbody>",
						content: "<tr><td>" + tableSimpleTemplate.content.map(function(b) {return b.value;}).join('</td><td>') + "</td></tr>",
						tail: "</tbody></table>"
					};
				}
			}*/
		}
		
		/*
			Initialize the Google Maps and map services. 
		*/
		
		function init() {
		
			var map;
			if(typeof(globalConfig.preInitialize) !== "undefined"){
				globalConfig.preInitialize();
			}			
			if(typeof(globalConfig.selfDefinedInitialize)!== "undefined"){
				globalConfig.selfDefinedInitialize();
			}else{		
				setupTableTemplate();			
				if(!globalConfig.accessible){
					//var mapOptions = getInitialMapOptions();
					var mapOptions = {
						zoom: globalConfig.orgzoomLevel,
						center: new google.maps.LatLng(globalConfig.orgLatitude, globalConfig.orgLongitude),
						scaleControl: true,
						streetViewControl: true,
						mapTypeId: globalConfig.defaultMapTypeId
					};

					var extraImageService = globalConfig.extraImageService;
					if(extraImageService.visible){
						mapOptions.mapTypeControlOptions = {
							mapTypeIds: [extraImageService.id, google.maps.MapTypeId.ROADMAP, google.maps.MapTypeId.SATELLITE ,google.maps.MapTypeId.HYBRID ,google.maps.MapTypeId.TERRAIN ]
						};
					}				
					map = new google.maps.Map(document.getElementById(globalConfig.mapCanvasDivId), mapOptions);
					//setup extraImageService if there is one
					if(extraImageService.visible){
						var agsType = new gmaps.ags.MapType(extraImageService.url, {
							name: extraImageService.name
						});
						map.mapTypes.set(extraImageService.id, agsType);
					}
					//Create map service
					if(typeof(globalConfig.url)!== "undefined"){
						var mapService = new gmaps.ags.MapService(globalConfig.url);
						var agsLayer = new gmaps.ags.MapOverlay(mapService, {opacity: globalConfig.opacity});	
						agsLayer.setMap(map);
					}
					if(typeof(globalConfig.tileLayerService)!== "undefined"){
						var agsType = new gmaps.ags.MapType(globalConfig.tileLayerService.url,{name:globalConfig.tileLayerService.name, opacity:globalConfig.tileLayerService.opacity});
						map.overlayMapTypes.insertAt(0, agsType);					
					}
					MOEMAP.init(map);
					TOOLSLEGEND.init(map);
					globalConfig.updateCoordinates (globalConfig.orgLatitude, globalConfig.orgLongitude);
					//document.getElementById(globalConfig.coordinatesDivId).innerHTML = globalConfig.defaultCoordinateLang;
				}
				if (typeof globalConfig.searchControlHTML !== "undefined") {
					globalConfig.searchControlDivId = globalConfig.searchControlDivId || 'searchControl'; 
					if (globalConfig.testDivExist(globalConfig.searchControlDivId)) {
						document.getElementById(globalConfig.searchControlDivId).innerHTML = globalConfig.searchControlHTML;
					}
				}
				
				if (typeof globalConfig.otherInfoHTML !== "undefined") {
					globalConfig.otherInfoDivId = globalConfig.otherInfoDivId || 'otherInfo'; 
					if (globalConfig.testDivExist(globalConfig.otherInfoDivId)) {
						document.getElementById(globalConfig.otherInfoDivId).innerHTML = globalConfig.otherInfoHTML;
					}
				}
				if (typeof globalConfig.applicationTitle !== "undefined")  {
					globalConfig.applicationTitleDivId = globalConfig.applicationTitleDivId || 'applicationTitle'; 
					if (globalConfig.testDivExist(globalConfig.applicationTitleDivId)) {
						document.getElementById(globalConfig.applicationTitleDivId).innerHTML = globalConfig.applicationTitle;
					}
				}										
				/*if ((typeof(globalConfig.searchHelpTxt)!== "undefined") && globalConfig.testDivExist(globalConfig.informationDivId)){
					document.getElementById(globalConfig.informationDivId).innerHTML = globalConfig.searchHelpTxt;
				}*/
				if (globalConfig.testDivExist(globalConfig.searchTheMapDivId)) {
					document.getElementById(globalConfig.searchTheMapDivId).innerHTML = "<h2>" + globalConfig.SearchInteractiveMapLang + "</h2>";
				}
				if (globalConfig.testDivExist(globalConfig.searchHelpDivId)) {
					document.getElementById(globalConfig.searchHelpDivId).innerHTML = globalConfig.searchHelpTxt;
				}				
				if ((typeof(globalConfig.disclaimerLang)!== "undefined") && globalConfig.displayDisclaimer && globalConfig.testDivExist(globalConfig.disclaimerDivId)){
					document.getElementById(globalConfig.disclaimerDivId).innerHTML = globalConfig.disclaimerLang;
				}
			}
			if(typeof(globalConfig.postInitialize)!== "undefined"){
				globalConfig.postInitialize(map);
			}
		}
		
		var module = {
			init: init
		};
		return module;
	})();
	if (globalConfig.useSystemDefinedInit){
		window.onload = INITIALIZATION.init;
	}
	/*global document:false */
/*global google:false */
/*global window:false */
/*global TOOLSLEGEND:false */

	var globalConfig = globalConfig || {};
	/*globalConfig.selectTooltip is defined in LANGUAGE.js*/
	globalConfig.imageURL = "http://files.ontariogovernment.ca/moe_mapping/mapping/js/MOEMap/images/";
	globalConfig.legend = globalConfig.legend || {
		available: false,	
		url: globalConfig.imageURL + "legend.png", 
		size: {width: 270, height: 81},   //Width and Height
		location: {ratioX: 0.01, ratioY: 0.25}  //
	};
	globalConfig.pointBufferTool = globalConfig.pointBufferTool || {
		available: true,
		upIcon: globalConfig.imageURL + "Bptu.png",
		downIcon: globalConfig.imageURL + "Bptd.png",
		size: {width: 31, height: 31},   //Width and Height
		location: {ratioX: 0.12, ratioY: 0.98}  //
	};
	/*globalConfig.generateURLTool = globalConfig.generateURLTool || {
		available: true,
		upIcon: "http://10.60.13.84/Public/PTTW/generateURL.jpeg", 
		downIcon: "http://10.60.13.84/Public/PTTW/generateURL.jpeg",
		size: {width: 31, height: 31},   //Width and Height
		location: {ratioX: 0.18, ratioY: 0.98}  //
	};
	
	globalConfig.generateURL = globalConfig.generateURL || function(){
		var msg = "Generate URL";
		if (globalConfig.language === "FR"){
			msg = "French.";
		}
		return msg;
	};
	globalConfig.infomationDivId = globalConfig.infomationDivId || 'information';	
	globalConfig.generateURLMessage = globalConfig.generateURLMessage || function(url){
		var msg = "The generated URL is <a href=\"" + url + "\">" + url + "</a> and you can select it and paste it to emails and share it with friends.";
		if (globalConfig.language === "FR"){
			msg = "French.";
		}
		document.getElementById(globalConfig.infomationDivId).innerHTML = msg;
	};*/

TOOLSLEGEND = (function () {
	var pointBufferToolMarker, legendMarker;//, generateURLToolMarker;
	//var urlParametes = {};		
	var map;
	/*Change the Status of Buffer Tool. If the paramter is true, the Tool is slected. If it is flase, this Tool is unselected.*/
	function setPointBufferTool(isDownIcon){
		var pointBufferTool = globalConfig.pointBufferTool;
		var bounds = map.getBounds();
		var sw = bounds.getSouthWest();
		var ne = bounds.getNorthEast();
		var latDiff = ne.lat() - sw.lat();
		var lngDiff = ne.lng() - sw.lng();			
		var icon = "";
		if(isDownIcon){
			icon = pointBufferTool.downIcon;
		}else{
			icon = pointBufferTool.upIcon;
		}
		var newIcon = new google.maps.MarkerImage(icon, new google.maps.Size(pointBufferTool.size.width, pointBufferTool.size.height),
				new google.maps.Point(0, 0), new google.maps.Point(0, 0), new google.maps.Size(pointBufferTool.size.width, pointBufferTool.size.height));
		
		if(pointBufferToolMarker){
			pointBufferToolMarker.setMap(null);
		}
		pointBufferToolMarker = new google.maps.Marker({
			position: new google.maps.LatLng(sw.lat() + pointBufferTool.location.ratioY*latDiff, sw.lng() + pointBufferTool.location.ratioX*lngDiff),
			icon: newIcon,
			title: globalConfig.selectTooltip,
			map: map
		});
	}
	/*Test whether the Buffer Tool is selected or not*/
	function isPointBufferToolSelected(){
		var pointBufferTool = globalConfig.pointBufferTool;
		if(pointBufferToolMarker && (pointBufferToolMarker.icon.url === pointBufferTool.downIcon)){
			return true;
		}
		return false;
	}
	/*Setup the legend's location by using the configuration information.*/
	function setupLegend(sw, latDiff, lngDiff){
		var legend = globalConfig.legend;
		if(legend.available) {
			var gLatLng = new google.maps.LatLng(sw.lat() + legend.location.ratioY*latDiff, sw.lng() + legend.location.ratioX*lngDiff);
			if(legendMarker){
				legendMarker.setMap(null);
			}
			var icon = new google.maps.MarkerImage(legend.url, new google.maps.Size(legend.size.width, legend.size.height),
				new google.maps.Point(0, 0), new google.maps.Point(0, 0), new google.maps.Size(legend.size.width, legend.size.height));
			legendMarker = new google.maps.Marker({
				position: gLatLng,
				icon: icon,
				map: map
			});
		}	
	}
	/*Setup the Buffer Tool's location by using the configuration information.*/
	function setupPointBufferTool(){
		var pointBufferTool = globalConfig.pointBufferTool;
		if(typeof(pointBufferTool) !== "undefined") {
			if(pointBufferTool.available){
				setPointBufferTool(false);  //The buffer Tool is unselected. 
				var container = "";
				(function (container, pointBufferToolMarker) {
					google.maps.event.addListener(pointBufferToolMarker, 'click', function () {
						setPointBufferTool(true);   //The buffer Tool is selected. 
					});
				})(container, pointBufferToolMarker);				
			}
		}
	}
	/*Setup the Generate URL Tool's location by using the configuration information.*/
	/*function setupGenerateURLTool(sw, latDiff, lngDiff){
		var generateURLTool = globalConfig.generateURLTool;
		if(typeof(generateURLTool) !== "undefined") {
			if(generateURLTool.available){
				var gLatLng = new google.maps.LatLng(sw.lat() + generateURLTool.location.ratioY*latDiff, sw.lng() + generateURLTool.location.ratioX*lngDiff);
				if(generateURLToolMarker){
					generateURLToolMarker.setMap(null);
				}
				var icon = new google.maps.MarkerImage(generateURLTool.upIcon, new google.maps.Size(generateURLTool.size.width, generateURLTool.size.height),
					new google.maps.Point(0, 0), new google.maps.Point(0, 0), new google.maps.Size(generateURLTool.size.width, generateURLTool.size.height));
				generateURLToolMarker = new google.maps.Marker({
					position: gLatLng,
					icon: icon,
					title: globalConfig.generateURL(),
					map: map
				});

				var container = "";
				(function (container, generateURLToolMarker) {
					//Once the user clicks on the Generate URL Tool, this event handler will be called to generate the information and display it
					google.maps.event.addListener(generateURLToolMarker, 'click', function () {
						var str = window.location.href;
						var end = str.indexOf("?");
						if( end > 0){
							str = str.substring(0, end);
						}
						var lat = map.getCenter().lat().toFixed(4);
						var lng = map.getCenter().lng().toFixed(4);						
						str = str + "?lev=" + map.getZoom() + "&lat=" + lat + "&lng=" + lng;
						if((typeof(urlParametes.location) !== "undefined") && (typeof(urlParametes.radius) !== "undefined")){
							urlParametes.radius = urlParametes.radius * 1.0;
							str = str +  "&" + globalConfig.locationURLParaName + "=" + urlParametes.location + "&" + globalConfig.radiusURLParaName + "=" + urlParametes.radius.toFixed(3);
						}
						if((typeof(urlParametes.field) !== "undefined") && (typeof(urlParametes.value) !== "undefined") && (typeof(urlParametes.fuzzy) !== "undefined")){
							var fuz = 0;
							if(urlParametes.fuzzy){
								fuz = 1;
							}
							str = str +  "&" + globalConfig.fieldURLParaName + "=" + urlParametes.field + "&" + globalConfig.valueURLParaName + "=" + urlParametes.value  + "&" + globalConfig.fuzzyURLParaName + "=" + fuz;
						}
						globalConfig.generateURLMessage(str);
					});
				})(container, generateURLToolMarker);
			}
		}		
	}*/
	/*If the maps bound changes, this function will be called to adjust the positions of Legend, Buffer Tool, and URL Generator Tools.*/
	function boundsChangedHandler(){
		var bounds = map.getBounds();
		var sw = bounds.getSouthWest();
		var ne = bounds.getNorthEast();
		var latDiff = ne.lat() - sw.lat();
		var lngDiff = ne.lng() - sw.lng();
		setupLegend(sw, latDiff, lngDiff);
		setupPointBufferTool();
		//setupGenerateURLTool(sw, latDiff, lngDiff);
	}
	
	/*set up the Google Maps object!*/
	function init(theMap){
		map = theMap;
		google.maps.event.addListener(map, 'bounds_changed', boundsChangedHandler);
	}
	
	/*Update parameters which will be used to generate URL.*/
	/*function updateURLParameter (newURLParametes){
		urlParametes = newURLParametes;
	}
	*/
	var module = {
		init: init,
		//updateURLParameter: updateURLParameter,
		isPointBufferToolSelected: isPointBufferToolSelected,
		setPointBufferTool: setPointBufferTool//,
		//boundsChangedHandler: boundsChangedHandler
	};
	return module;
})();
/*global document:false */
/*global goog:false */
/*global MOEMAP:false */
/*global google:false */
/*global INITIALIZATION:false */
/*global TOOLSLEGEND:false */
/*global gmaps:false */
/*global TABS_CALCULATOR:false */
/*global LOCATOR:false */
/*global window:false */
 
var globalConfig = globalConfig || {};
globalConfig.drawingCircleMessage = globalConfig.drawingCircleMessage || function(lat, lng, radius){
	document.getElementById(globalConfig.informationDivId).innerHTML = globalConfig.searchCenterLang + " (latitude:" + lat.toFixed(6) + ", longitude:" + lng.toFixed(6) + "), " + globalConfig.searchRadiusLang + " (" + radius.toFixed(2) + " " + globalConfig.searchKMLang + ")";
};
globalConfig.totalFeatureReturned = globalConfig.totalFeatureReturned || function(count){
	return globalConfig.totalFeatureReturnedLang + ": <strong>" + count + "</strong>";
};
globalConfig.totalFeatureReturnedOnlyOneDisplayed = globalConfig.totalFeatureReturnedOnlyOneDisplayed || function(count){
	return globalConfig.totalFeatureReturnedLang + ": <strong>" + count + "</strong>" + globalConfig.only1DisplayedLang;
};
globalConfig.maxQueryReturn = globalConfig.maxQueryReturn || 500;	
globalConfig.resultFound = globalConfig.resultFound || function(validCount, totalCount){
	var queryParams = {totalCount: totalCount};
	globalConfig.resultFoundSimple (queryParams);
};
globalConfig.resultFoundSimple = globalConfig.resultFoundSimple || function(queryParams){
	var searchString = queryParams.searchString;
	var totalCount = queryParams.totalCount;
	var regionName = "";
	if (typeof(queryParams.withinExtent) !== "undefined") {
		regionName = " " + (queryParams.withinExtent ? globalConfig.inCurrentMapExtentLang : globalConfig.inGobalRegionLang);
	}
	var searchString = " ";
	if (typeof(queryParams.searchString) !== "undefined") {
		searchString = " " + globalConfig.forLang + " <strong>"  + queryParams.searchString + "</strong> ";
	}
	
	var message = "";
	if (queryParams.hasOwnProperty("invalidCount") && (queryParams.invalidCount > 0)) {
		var invalidResultMsg = (queryParams.invalidCount === 1) ? globalConfig.ResultDoesNotHaveValidCoordinates : globalConfig.ResultsDoNotHaveValidCoordinates;
		
		if(totalCount === 0){
			message = globalConfig.yourSearchLang + searchString + globalConfig.returnedNoResultLang + regionName + ". " + globalConfig.pleaseRefineSearchLang + ".";
		} else if(totalCount === 1){
			message = globalConfig.oneResultFoundLang  + searchString + regionName + "." + globalConfig.ThisResultDoesNotHaveValidCoordinates;
		} else if(totalCount >= globalConfig.maxQueryReturn){
			message = globalConfig.moreThanLang + " " + globalConfig.maxQueryReturn + " " + globalConfig.resultsFoundLang + searchString + regionName + ". " + globalConfig.onlyLang + " " + globalConfig.maxQueryReturn + " " + globalConfig.returnedLang + ". " + globalConfig.seeHelpLang + "." + globalConfig.AmongReturnedResults + ", " + queryParams.invalidCount + invalidResultMsg;
		} else {
			message = totalCount + " " + globalConfig.resultsFoundLang + searchString + regionName + ". " + globalConfig.AmongReturnedResults + ", " + queryParams.invalidCount + invalidResultMsg;
		}	
	} else {
		if(totalCount === 0){
			message = globalConfig.yourSearchLang + searchString + globalConfig.returnedNoResultLang + regionName + ". " + globalConfig.pleaseRefineSearchLang + ".";
		} else if(totalCount === 1){
			message = globalConfig.oneResultFoundLang  + searchString + regionName + ".";
		} else if(totalCount >= globalConfig.maxQueryReturn){
			message = globalConfig.moreThanLang + " " + globalConfig.maxQueryReturn + " " + globalConfig.resultsFoundLang + searchString + regionName + ". " + globalConfig.onlyLang + " " + globalConfig.maxQueryReturn + " " + globalConfig.returnedLang + ". " + globalConfig.seeHelpLang + ".";
		} else {
			message = totalCount + " " + globalConfig.resultsFoundLang + searchString + regionName + ".";
		}
	}
	document.getElementById(globalConfig.informationDivId).innerHTML ="<i>" + message + "</i>";
};	
globalConfig.noResultFound = globalConfig.noResultFound || function(){
	document.getElementById(globalConfig.informationDivId).innerHTML ="<i>" + globalConfig.noResultFoundMsg + "</i>";	
};
globalConfig.searchInProgress = globalConfig.searchInProgress || function(){
	document.getElementById(globalConfig.informationDivId).innerHTML = "<i>" + globalConfig.searchingLang + "</i>";
};
globalConfig.maxQueryZoomLevel = globalConfig.maxQueryZoomLevel || 17;
globalConfig.maxQueryZoomLevelTWPSearch = globalConfig.maxQueryZoomLevelTWPSearch || 11;  //Zoom Level for Township search
globalConfig.maxQueryZoomLevelTWPLotConSearch = globalConfig.maxQueryZoomLevelTWPLotConSearch || 14;	// Zoom Level for Township with Lot and Concession search
globalConfig.queryTableDivId = globalConfig.queryTableDivId || 'query_table';
//globalConfig.queryTableTemplateDivId = globalConfig.queryTableTemplateDivId || 'QueryTableTemplate';

if (typeof globalConfig.usejQueryUITable === "undefined"){
	globalConfig.usejQueryUITable = true;   //whether want to use the predefined multiple tab supports. If it is false, it will only support one tab. 
}
if(globalConfig.usejQueryUITable && (!globalConfig.accessible) && (!!yepnope)){	
	yepnope({
		load: "http://files.ontario.ca/moe_mapping/mapping/js/MOEMap/css/jquery.dataTables.css", 
		callback: function () {
			//console.log("multipletabs.css loaded!");
		}
	});
	
	yepnope({
		load: "http://files.ontario.ca/moe_mapping/mapping/js/MOEMap/js/jquery.dataTables.js", 
		callback: function () {
			//console.log("closure-library-multipletabs-min.js loaded!");
		}
	});
}
//globalConfig.supportTableDownload = globalConfig.supportTableDownload || true;	

//whether want to use the predefined multiple tab supports. If it is false, it will only support one tab. 
if (typeof globalConfig.usePredefinedMultipleTabs === "undefined"){
	globalConfig.usePredefinedMultipleTabs = true;
}
if(globalConfig.usePredefinedMultipleTabs && (!globalConfig.accessible) && (!!yepnope)){	
		yepnope({
			load: "http://files.ontario.ca/moe_mapping/mapping/js/MOEMap/css/multipletabs.css", 
			callback: function () {
				//console.log("multipletabs.css loaded!");
			}
		});
		
		yepnope({
			load: "http://files.ontario.ca/moe_mapping/mapping/js/MOEMap/js/closure-library-multipletabs-min.js", 
			callback: function () {
				//console.log("closure-library-multipletabs-min.js loaded!");
			}
		});
		/*
		goog.require('goog.dom');
		goog.require('goog.ui.Tab');
		goog.require('goog.ui.TabBar');
		*/
}
globalConfig.searchedLocationIcon = globalConfig.searchedLocationIcon || "http://gmaps-samples.googlecode.com/svn/trunk/markers/blue/blank.png";
globalConfig.twpBoundary = globalConfig.twpBoundary || {
	color: '#8583f3',
	opacity: 1, 
	weight: 4
};
globalConfig.pointBuffer = globalConfig.pointBuffer || {
	color: "#FF0000",
	opacity: 1,
	weight: 2
};
globalConfig.identifyMarkerRedTearDrop = globalConfig.identifyMarkerRedTearDrop || false;

globalConfig.identifyRadiusZoomLevelList = globalConfig.identifyRadiusZoomLevelList || {
	21 : 0.001,
	20 : 0.001,
	19 : 0.002,
	18 : 0.003,
	17 : 0.005,
	16 : 0.01,
	15 : 0.02,
	14 : 0.05,
	13 : 0.08,
	12 : 0.16,
	11 : 0.3,
	10 : 0.6,
	9  : 1.2,
	8  : 2.4,
	7  : 4.8,
	6  : 9.6,
	5  : 20,
	4  : 40,
	3  : 80,
	2  : 160,
	1  : 320
};

/*
	queryParams contains gLatLng, map, preQueryCallback (globalConfig.preIdentifyCallback), 
	postQueryCallback (globalConfig.postIdentifyCallback), layerList, currentLayerId as its properties. 
*/
globalConfig.preIdentifyCallbackName = globalConfig.preIdentifyCallbackName || "Wells";
globalConfig.preIdentifyCallbackList = globalConfig.preIdentifyCallbackList || {
	"Wells": function (queryParams) {
		var radius = globalConfig.identifyRadiusZoomLevelList[queryParams.map.getZoom()];
		var layerSetting = queryParams.layerList[queryParams.currentLayerId];
		var circle = globalConfig.calculateCirclePolyline(queryParams.gLatLng, radius*1000);	
		var params = {
			returnGeometry: false,
			outFields: layerSetting.outFields,
			geometry: new google.maps.Polygon({
				paths: circle.getPath()
			}),
			geometryType: 'esriGeometryPolygon'
		};
		return params;
	},
	"SWPLocator": function (queryParams) {
		/*if (globalConfig.identifyMultiplePolygonLayersServicesTemplate.hasOwnProperty('displayResultBelowMap') && (globalConfig.identifyMultiplePolygonLayersServicesTemplate.displayResultBelowMap)) {
			globalConfig.identifyResults = {};
		}*/
		var layerSetting = queryParams.layerList[queryParams.currentLayerId];
		var params = {
			returnGeometry: layerSetting.hasOwnProperty('returnGeometry') ? layerSetting.returnGeometry : false,
			geometryType: 'esriGeometryPoint',
			geometry: queryParams.gLatLng,				
			outFields: layerSetting.returnFields
		};			
		return params;
	}	
};
globalConfig.preIdentifyCallback = globalConfig.preIdentifyCallback || globalConfig.preIdentifyCallbackList[globalConfig.preIdentifyCallbackName];

globalConfig.createControllableInfoWindowContent = function (content) {
	var container = document.createElement('div');
	container.style.width = globalConfig.infoWindowWidth;
	if (globalConfig.hasOwnProperty('infoWindowHeight')){ 
		container.style.height = globalConfig.infoWindowHeight;
	}
	container.innerHTML = content;
	return container;
};
globalConfig.postIdentifyCallbackName = globalConfig.postIdentifyCallbackName || "Wells";
globalConfig.postIdentifyCallbackList = globalConfig.postIdentifyCallbackList || {
	"Wells": function (queryParams) {
		var features = Array.range(0, queryParams.layerList.length - 1).reduce(function(previousValue, currentValue) {
			var result = queryParams.layerList[currentValue].result;
			if (result.hasOwnProperty('features')) {
				return previousValue.concat(result.features);
			} else {
				return previousValue;
			}
		}, []);
		if(features.length === 0) {
			return;
		}
		var container = globalConfig.calculateMulitpleTabsOneFeature(features, queryParams.layerList[0].tabsTemplate);
		MOEMAP.openInfoWindow(queryParams.gLatLng, container);
	},
	"SportFish": function (queryParams) {
		//console.log("In Identify");
		var features = Array.range(0, queryParams.layerList.length - 1).reduce(function(previousValue, currentValue) {
			var result = queryParams.layerList[currentValue].result;
			if (result.hasOwnProperty('features')) {
				return previousValue.concat(result.features);
			} else {
				return previousValue;
			}
		}, []);
		if(features.length === 0) {
			return;
		}
		var tableTemplate = queryParams.layerList[0].tabsTemplate;
		var calculateContents = TABS_CALCULATOR.getContent(features[0].attributes, tableTemplate);
		var container = globalConfig.createControllableInfoWindowContent(calculateContents[0].content);
		MOEMAP.openInfoWindow(queryParams.gLatLng, container);
	},
	"SWPLocatorReverseGeocoding": function (queryParams) {
		if (globalConfig.avoidReverseGeocoding) {
			globalConfig.avoidReverseGeocoding = false;
			globalConfig.postIdentifyCallbackList["SWPLocator"](queryParams);
		} else {
			var geocoder = new google.maps.Geocoder();
			var latlng = queryParams.gLatLng;
			geocoder.geocode({
				'address': latlng.lat() + ',' + latlng.lng()
			}, function (results, status) {
				if (status === google.maps.GeocoderStatus.OK) {
					globalConfig.returnedAddress = results[0].formatted_address.toString();
					globalConfig.postIdentifyCallbackList["SWPLocator"](queryParams);
				} else {
					alert("Geocode was not successful for the following reason: " + status);
				}
			});
		}
	},
	"SWPLocator": function (queryParams) {
		MOEMAP.clearOverlays();	
		var layerList = queryParams.layerList;
		var container = "";
		if (queryParams.hasOwnProperty('mergeFunction')) {
			container = queryParams.mergeFunction(queryParams.gLatLng);
		} else {
			container = Array.range(0, layerList.length - 1).map(function (i) {
				var features = layerList[i]["result"].features;
				if (features.length > 0) {
					return Array.range(0, features.length - 1).map(function (j) {
						return layerList[i].callback(features[j].attributes) + "<br>";
					}).join("");
				} else {
					return "";
				}			
			}).join("");
		}
		var identifyMarker = globalConfig.identifyMarkerRedTearDrop ? (new google.maps.Marker({
				position: queryParams.gLatLng,
				draggable: true
			})) : (new google.maps.Marker({
				position: queryParams.gLatLng,
				icon: globalConfig.searchedLocationIcon,				
				draggable: true
			}));
		MOEMAP.addOverlay(identifyMarker);
		/*
		if (globalConfig.identifyMultiplePolygonLayersServicesTemplate.hasOwnProperty('displayResultBelowMap') && (globalConfig.identifyMultiplePolygonLayersServicesTemplate.displayResultBelowMap)) {
			globalConfig.identifyResults["LatLng"] = queryParams.gLatLng;
			globalConfig.identifyResults["UTM"] = globalConfig.convertLatLngtoUTM(queryParams.gLatLng.lat(), queryParams.gLatLng.lng());		
			//var template = document.getElementById(globalConfig.queryTableTemplateDivId).innerHTML;
			document.getElementById(globalConfig.queryTableDivId).innerHTML = _.template(globalConfig.identifyMultiplePolygonLayersServicesTemplate.queryTableTemplate, globalConfig.identifyResults);
			//console.log(container);
			container = _.template(globalConfig.identifyMultiplePolygonLayersServicesTemplate.popupTemplate, globalConfig.identifyResults);
		}*/ //else {
		container = globalConfig.createControllableInfoWindowContent(container);
		MOEMAP.openInfoWindow(queryParams.gLatLng, container);	
		(function (container, identifyMarker) {
			google.maps.event.addListener(identifyMarker, 'click', function () {
				MOEMAP.openInfoWindow(identifyMarker.getPosition(), container);
			});
		})(container, identifyMarker);
		//}
		google.maps.event.addListener(identifyMarker, 'dragend', function () {
			MOEMAP.clearOverlays();
			if(document.getElementById(globalConfig.searchInputBoxDivId)){
				document.getElementById(globalConfig.searchInputBoxDivId).value="";
				document.getElementById(globalConfig.searchInputBoxDivId).focus();
			}
			if(document.getElementById(globalConfig.queryTableDivId)){
				document.getElementById(globalConfig.queryTableDivId).innerHTML = "";
			}
			var geocoder = new google.maps.Geocoder();
			var latlng = identifyMarker.getPosition();
			queryParams.map.setCenter (latlng);
			geocoder.geocode({
				'address': latlng.lat() + ',' + latlng.lng()
			}, function (results, status) {
				if (status === google.maps.GeocoderStatus.OK) {
					globalConfig.returnedAddress = results[0].formatted_address.toString();
					MOEMAP.mouseClickHandler({latLng: latlng});
				} else {
					alert("Geocode was not successful for the following reason: " + status);
				}
			});					

		});
		
		for (var i = 0; i<layerList.length; i++) {
			if (layerList[i].hasOwnProperty('displayPolygon') && (layerList[i].displayPolygon)) {
				var features = layerList[i]["result"].features;
				for (var j=0; j<features.length; j++) {
					var geometryPoly = features[j].geometry[0];
					geometryPoly.setOptions(layerList[i].style);
					MOEMAP.addOverlay(geometryPoly);	
				}
			}
		}
		//console.log(container.innerHTML);
		if (globalConfig.testDivExist(globalConfig.queryTableDivId)) {
			document.getElementById(globalConfig.queryTableDivId).innerHTML = "<br>" + container.innerHTML;
		}
		/*
		if (globalConfig.identifyMultiplePolygonLayersServicesTemplate.hasOwnProperty('success')) {
			globalConfig.identifyMultiplePolygonLayersServicesTemplate.success();
		}*/
		/*
		if ((typeof(globalConfig.searchHelpTxt)!== "undefined") && globalConfig.testDivExist(globalConfig.informationDivId)){
			document.getElementById(globalConfig.informationDivId).innerHTML = globalConfig.searchHelpTxt;
		}*/		
	}
};
globalConfig.postIdentifyCallback = globalConfig.postIdentifyCallback || globalConfig.postIdentifyCallbackList[globalConfig.postIdentifyCallbackName];

/*
	queryParams contains gLatLng, radius, map, preQueryCallback (globalConfig.preBufferCallback), 
	postQueryCallback (globalConfig.postBufferCallback), layerList, currentLayerId as its properties. 
*/
globalConfig.preBufferCallbackName = globalConfig.preBufferCallbackName || "Wells";
globalConfig.preBufferCallbackList = globalConfig.preBufferCallbackList || {
	"Wells": function (queryParams) {
		var radius = queryParams.radius;
		var marker = globalConfig.createMarker(queryParams.gLatLng, "" + queryParams.gLatLng.lat().toFixed(5) + ", " + queryParams.gLatLng.lng().toFixed(5), globalConfig.searchedLocationIcon);
		MOEMAP.addOverlay(marker);
		
		var layerSetting = queryParams.layerList[queryParams.currentLayerId];
		var circle = globalConfig.calculateCirclePolyline(queryParams.gLatLng, radius*1000);
		var bounds = globalConfig.calculatePolylineBounds(circle);
		globalConfig.setMapBound(queryParams.map,bounds);
		MOEMAP.addOverlay(circle);
		var params = {
			returnGeometry: true, 
			outFields: layerSetting.outFields,
			geometry: new google.maps.Polygon({
				paths: circle.getPath()
			}),
			geometryType: 'esriGeometryPolygon'
		};
		
		if (queryParams.hasOwnProperty('where')) {
			params.where = queryParams.where;
		}
		return params;
	}
};
globalConfig.preBufferCallback = globalConfig.preBufferCallback || globalConfig.preBufferCallbackList[globalConfig.preBufferCallbackName];

globalConfig.postBufferCallbackName = globalConfig.postBufferCallbackName || "Wells";
globalConfig.postBufferCallbackList = globalConfig.postBufferCallbackList || {
	"Wells": function (queryParams) {
		var features = Array.range(0, queryParams.layerList.length - 1).reduce(function(previousValue, currentValue) {
			var result = queryParams.layerList[currentValue].result;
			if (result.hasOwnProperty('features')) {
				return previousValue.concat(result.features);
			} else {
				return previousValue;
			}
		}, []);
		if(features.length === 0) {
			queryParams.totalCount = 0;
			globalConfig.resultFoundSimple(queryParams);				
			return;
		}
		globalConfig.addMarkers(features, queryParams.layerList[0].tabsTemplate);
		var templates = {
			"coordinatesTable": queryParams.layerList[0].tableTemplate,
			"noCoordinatesTable": queryParams.layerList[0].noCoordinatesTableTemplate
		};
		//globalConfig.renderTable(features, queryParams.layerList[0].tableTemplate, queryParams.gLatLng);
		globalConfig.renderTable(features, templates, queryParams.gLatLng);
		queryParams.totalCount = features.length;
		globalConfig.resultFoundSimple(queryParams);		
	}
};
globalConfig.postBufferCallback = globalConfig.postBufferCallback || globalConfig.postBufferCallbackList[globalConfig.postBufferCallbackName];

globalConfig.addMarkers = globalConfig.addMarkers || function(features, tabsTemplate) {
	var pointClusters = globalConfig.calculateClusters(features);
	for (var x = 0; x < pointClusters.length; x++) {
		var gLatLng = pointClusters[x].gLatLng;
		var container = globalConfig.calculateMulitpleTabsOneFeature(pointClusters[x].list, tabsTemplate);
		var marker = new google.maps.Marker({
			position: gLatLng
		});		
		(function (container, marker) {
			google.maps.event.addListener(marker, 'click', function () {
				MOEMAP.openInfoWindow(marker.getPosition(), container);
			});
		})(container, marker);
		MOEMAP.addOverlay(marker);
	}
};

globalConfig.addMarkersSimple = globalConfig.addMarkersSimple || function(features, tabsTemplate) {
	for (var x = 0; x < features.length; x++) {
		var gLatLng = features[x].geometry[0].getPosition();
		var calculateContents = TABS_CALCULATOR.getContent(features[x].attributes, tabsTemplate);
		//var container = calculateContents[0].content;
		var container = globalConfig.createControllableInfoWindowContent(calculateContents[0].content);
		var marker = new google.maps.Marker({
			position: gLatLng
		});		
		(function (container, marker) {
			google.maps.event.addListener(marker, 'click', function () {
				MOEMAP.openInfoWindow(marker.getPosition(), container);
			});
		})(container, marker);
		MOEMAP.addOverlay(marker);
	}
};

globalConfig.renderTable = function(features, templates, searchCenter){
	var tableTemplate = templates.coordinatesTable;
	var noCoordinatesTableTemplate = templates.noCoordinatesTable;
	var featuresValidCoors = features.filter(globalConfig.validFeaturesFilter);
	var featuresInvalidCoors = features.filter(function (feature) {
		return  !globalConfig.validFeaturesFilter(feature);
	});
	var tableHead = tableTemplate.head;
	//console.log(tableHead);
	var requireDistanceField = (typeof(searchCenter) !== "undefined");
	if(requireDistanceField) {
		var resArrays = tableTemplate.head.split("<table");
		if(resArrays.length === 2){
			tableHead = resArrays[0] + globalConfig.distanceFieldNote + "<table" + resArrays[1];
		}
		var resArrays = tableHead.split("</tr>");
		if(resArrays.length === 2){
			tableHead = resArrays[0] + "<th><center>" + globalConfig.distanceLang + "</center></th></tr>" + resArrays[1];
		}
		//console.log(tableHead);
	}
	var getTableContent = function(features, requireDistanceField, tableTemplateContent){
		var table = "";
		var size = features.length;
		for (var x = 0; x < size; x++) {
			var findResult = features[x];
			var calculateContents = TABS_CALCULATOR.getContent(findResult.attributes, [{ label:globalConfig.InformationLang, content:tableTemplateContent}]);
			var str = calculateContents[0].content;
			var gLatLng = findResult.geometry[0].getPosition();
			if(requireDistanceField) {
				var resArrays = str.split("</tr>");
				str = resArrays[0] + "<td>" + (google.maps.geometry.spherical.computeDistanceBetween(gLatLng, searchCenter)/1000).toFixed(2)  + "</td></tr>" ;
			}
			table = table + str;
		}
		return table;
	};
	//var table = tableHead + getTableContent(features) + tableTemplate.tail + "<br><br><br>";
	var table = (featuresValidCoors.length === 0) ? "" : (tableHead + getTableContent(featuresValidCoors, requireDistanceField, tableTemplate.content) + tableTemplate.tail + "<br><br><br>");
	table = table + ((featuresInvalidCoors.length === 0) ? "" : (noCoordinatesTableTemplate.head + getTableContent(featuresInvalidCoors, false, noCoordinatesTableTemplate.content) + noCoordinatesTableTemplate.tail + "<br><br><br>" + globalConfig.whyAmISeeingThisLang));
	document.getElementById(globalConfig.queryTableDivId).innerHTML = table;
	var tableID = globalConfig.tableID;
	if(globalConfig.usejQueryUITable){
		var dataTableOptions = {
			"bJQueryUI": true,
			"sPaginationType": "full_numbers" 
			};
		if (globalConfig.language !== "EN") {
			dataTableOptions["oLanguage"] = globalConfig.dataTableLang;
		}
		/*
		if ((globalConfig.supportTableDownload) && (!$.browser.msie)) {
			dataTableOptions["sDom"] = 'T<"clear">lfrtip';
			dataTableOptions["oTableTools"] = {
					"sSwfPath": "http://files.ontario.ca/moe_mapping/mapping/js/MOEMap/js/TableTools-2.1.4/media/swf/copy_csv_xls.swf",
					"aButtons": ["xls"]
				};
		}*/
		if(requireDistanceField) {
			var fields = tableHead.split("</th><th>");
			dataTableOptions["aaSorting"] = [[ fields.length-1, "asc" ]];
		}
		$('#' + tableID).dataTable(dataTableOptions);
		$('#' + globalConfig.noCoordinatesTableID).dataTable(dataTableOptions);
	}
};
	
/*
	queryParams contains map, preQueryCallback (globalConfig.preConditionsCallback), 
	postQueryCallback (globalConfig.postConditionsCallback), layerList, currentLayerId
	searchString, where, withinExtent, requireGeocode as its properties. 
*/
globalConfig.preConditionsCallbackName = globalConfig.preConditionsCallbackName || "Wells";
globalConfig.preConditionsCallbackList = globalConfig.preConditionsCallbackList || {
	"Wells": function (queryParams) {
		var layerSetting = queryParams.layerList[queryParams.currentLayerId];
		var params = {
			returnGeometry: (globalConfig.accessible) ? false : true, 
			outFields: layerSetting.outFields,
			where: queryParams.where		
		};
		if(queryParams.withinExtent) {
			var getCurrentMapExtent = function(map) {
				var currentBounds = map.getBounds();
				var swLatLng = currentBounds.getSouthWest();
				var neLatLng = currentBounds.getNorthEast();
				var seLatLng = new google.maps.LatLng(swLatLng.lat(), neLatLng.lng());
				var nwLatLng = new google.maps.LatLng(neLatLng.lat(), swLatLng.lng());
				return new google.maps.Polygon({
					paths: [swLatLng, seLatLng, neLatLng, nwLatLng, swLatLng]
				});	
			};
			params.geometry = getCurrentMapExtent(queryParams.map);
		}
		return params;
	}
};
globalConfig.preConditionsCallback = globalConfig.preConditionsCallback || globalConfig.preConditionsCallbackList[globalConfig.preConditionsCallbackName];
globalConfig.validFeaturesFilter = globalConfig.validFeaturesFilter || function(feature) {
	var p = feature.geometry[0].position;
	return (p.lat() > 0.0001 && p.lng() < 0.0001);
};
globalConfig.postConditionsCallbackName = globalConfig.postConditionsCallbackName || "Wells";
//console.log(globalConfig.postConditionsCallbackName);
globalConfig.postConditionsCallbackList = globalConfig.postConditionsCallbackList || {
	"Wells": function (queryParams) {
		//console.log("Wells inside");
		var features = Array.range(0, queryParams.layerList.length - 1).reduce(function(previousValue, currentValue) {
			var result = queryParams.layerList[currentValue].result;
			if (result.hasOwnProperty('features')) {
				return previousValue.concat(result.features);
			} else {
				return previousValue;
			}
		}, []);
		if(features.length === 0) {
			queryParams.totalCount = 0;
			globalConfig.resultFoundSimple(queryParams);		
			if(queryParams.requireGeocode) {
				MOEMAP.geocodeAddress(queryParams);		
			}		
			return;
		}
		var featuresValidCoors = features.filter(globalConfig.validFeaturesFilter);
		var featuresInvalidCoors = features.filter(function (feature) {
			return  !globalConfig.validFeaturesFilter(feature);
		});
		queryParams.totalCount = features.length;
		queryParams.validCount = featuresValidCoors.length;
		queryParams.invalidCount = featuresInvalidCoors.length;
		globalConfig.resultFoundSimple(queryParams);		
		//console.log(featuresValidCoors);
		if((!queryParams.withinExtent) && (featuresValidCoors.length > 0)) {	
			//var bounds = globalConfig.calculatePointsBounds(features);
			var bounds = globalConfig.calculatePointsBounds(featuresValidCoors);
			globalConfig.setMapBound(queryParams.map,bounds);	
		}
		if (globalConfig.usePredefinedMultipleTabs) {
			//globalConfig.addMarkers(features,queryParams.layerList[0].tabsTemplate);
			globalConfig.addMarkers(featuresValidCoors,queryParams.layerList[0].tabsTemplate);
			//globalConfig.addMarkers(featuresValidCoors,queryParams.layerList[0].tabsTemplate);
		} else {
			globalConfig.addMarkersSimple(featuresValidCoors, queryParams.layerList[0].tabsTemplate);
		}
		if (queryParams.layerList[0].hasOwnProperty('tableTemplate')){
			var templates = {
				"coordinatesTable": queryParams.layerList[0].tableTemplate,
				"noCoordinatesTable": queryParams.layerList[0].noCoordinatesTableTemplate
			};
			//console.log(templates);
			//globalConfig.renderTable(features,queryParams.layerList[0].tableTemplate);
			globalConfig.renderTable(features,templates);
		}
	},
	"AccessibleWells": function (queryParams) {
		//console.log("AccessibleWells inside");
		var features = Array.range(0, queryParams.layerList.length - 1).reduce(function(previousValue, currentValue) {
			var result = queryParams.layerList[currentValue].result;
			if (result.hasOwnProperty('features')) {
				return previousValue.concat(result.features);
			} else {
				return previousValue;
			}
		}, []);
		queryParams.totalCount = features.length;
		globalConfig.resultFoundSimple(queryParams);		
		if(features.length === 0) {
			return;
		}
		var tableTemplate = queryParams.layerList[0].tableTemplate;
		var table = tableTemplate.head + Array.range(0, features.length - 1).reduce(function(previousValue, currentValue) {
			var calculateContents = TABS_CALCULATOR.getContent(features[currentValue].attributes, [{ label:globalConfig.InformationLang, content:tableTemplate.content}]);
			var str = calculateContents[0].content;
			if(currentValue%2 === 1) {
				str = globalConfig.replaceChar(str, "<td>", "<td  class='shaded'>");
			} 
			return previousValue + str;
		}, "") + tableTemplate.tail;
		document.getElementById(globalConfig.queryTableDivId).innerHTML = table;
	},
	"SportFish": function (queryParams) {
		//console.log("In Search");
		//console.log("SportFish inside");
		var features = Array.range(0, queryParams.layerList.length - 1).reduce(function(previousValue, currentValue) {
			var result = queryParams.layerList[currentValue].result;
			if (result.hasOwnProperty('features')) {
				return previousValue.concat(result.features);
			} else {
				return previousValue;
			}
		}, []);
		if(features.length === 0) {
			if(queryParams.requireGeocode) {
				MOEMAP.geocodeAddress(queryParams);		
			} else {
				queryParams.totalCount = 0;
				globalConfig.resultFoundSimple(queryParams);							
			}
			return;
		}
		queryParams.totalCount = features.length;
		globalConfig.resultFoundSimple(queryParams);				
		if(!queryParams.withinExtent) {	
			var bounds = globalConfig.calculatePointsBounds(features);
			globalConfig.setMapBound(queryParams.map,bounds);	
		}
		globalConfig.addMarkersSimple(features, queryParams.layerList[0].tabsTemplate);
	}	
};
globalConfig.postConditionsCallback = globalConfig.postConditionsCallback || globalConfig.postConditionsCallbackList[globalConfig.postConditionsCallbackName];

globalConfig.addressGeocodingCallbackName = globalConfig.addressGeocodingCallbackName || "Wells";
globalConfig.addressGeocodingCallbackList = globalConfig.addressGeocodingCallbackList || {
	"Wells": function (queryParams) {
		var withinExtent = queryParams.hasOwnProperty('withinExtent') ? queryParams.withinExtent : false;
		var map = queryParams.map;
		if (withinExtent && (!queryParams.map.getBounds().contains(queryParams.gLatLng))) {
			queryParams.totalCount = 0;
			globalConfig.resultFoundSimple(queryParams);
			return;
		}
		if (queryParams.hasOwnProperty('polylines')) {
			MOEMAP.addPolylinesToMap(queryParams.polylines);
		}
		var marker = globalConfig.createMarker(queryParams.gLatLng, queryParams.searchString, globalConfig.searchedLocationIcon);
		MOEMAP.addOverlay(marker);
		if (!withinExtent) {
			queryParams.map.setCenter(queryParams.gLatLng);
			if (queryParams.hasOwnProperty('zoomlevel')) {
				queryParams.map.setZoom(queryParams.zoomlevel);
			} else {
				if (queryParams.map.getZoom() <= globalConfig.maxQueryZoomLevel) {
					queryParams.map.setZoom(globalConfig.maxQueryZoomLevel);
				}
			}
		}
		queryParams.totalCount = 1;
		globalConfig.resultFoundSimple(queryParams);					
	},
	"SWPLocator": function (queryParams) {
		var map = queryParams.map;
		if (queryParams.hasOwnProperty('polylines')) {
			MOEMAP.addPolylinesToMap(queryParams.polylines);
		}
		var gLatLng = queryParams.gLatLng;
		//var address = queryParams.address;  //returnedAddress
		if (queryParams.hasOwnProperty('returnedAddress')) {
			globalConfig.returnedAddress = queryParams.returnedAddress;			
		} else {
			globalConfig.returnedAddress = queryParams.address;
		}
		map.setCenter(gLatLng);
		if (queryParams.hasOwnProperty('zoomLevel')) {
			map.setZoom(queryParams.zoomLevel);
		} else {
			if (map.getZoom() <= globalConfig.maxQueryZoomLevel) {
				map.setZoom(globalConfig.maxQueryZoomLevel);
			}
		}
		MOEMAP.mouseClickHandler({latLng: gLatLng});
	}	
};
globalConfig.addressGeocodingCallback = globalConfig.addressGeocodingCallback || globalConfig.addressGeocodingCallbackList[globalConfig.addressGeocodingCallbackName];

globalConfig.calculatePointsBounds = globalConfig.calculatePointsBounds || function (features){
	var bounds = new google.maps.LatLngBounds();
	var size = features.length;
	for (var x = 0; x < size; x++) {
		var gLatLng = features[x].geometry[0].getPosition();
		bounds.extend(gLatLng);		
	}
	return bounds;
};

globalConfig.setMapBound = globalConfig.setMapBound || function (map, bounds){
	map.fitBounds(bounds);
	var maxQueryZoomLevel = globalConfig.maxQueryZoomLevel;
	if(globalConfig.TWPSearch){
		maxQueryZoomLevel = globalConfig.maxQueryZoomLevelTWPSearch;
		globalConfig.TWPSearch = false;
	}else if(globalConfig.TWPLotConSearch){
		maxQueryZoomLevel = globalConfig.maxQueryZoomLevelTWPLotConSearch;
		globalConfig.TWPLotConSearch = false;
	}			
	if (map.getZoom() > maxQueryZoomLevel) {
		map.setZoom(maxQueryZoomLevel);
	}
};	

globalConfig.calculateClusters = globalConfig.calculateClusters || function (features){
	var size = features.length;
	var pointClusters = [];
	for (var x = 0; x < size; x++) {
		var findResult = features[x];
		//var attributes = findResult.attributes;
		var gLatLng = findResult.geometry[0].getPosition();
		if (Math.abs(gLatLng.lng()) + Math.abs(gLatLng.lat()) > 0.001) {
			var foundCluster = false;
			for(var i = 0; i < pointClusters.length; i++){
				var center = pointClusters[i].gLatLng;
				var diff = Math.abs(gLatLng.lng() - center.lng()) + Math.abs(gLatLng.lat() - center.lat());
				if(diff < 0.000001){
					(pointClusters[i]).list.push(findResult);
					foundCluster = true;
				}
			}				
			if(!foundCluster){
				var cluster = {gLatLng: gLatLng, list: [findResult]};
				pointClusters.push(cluster);
			}				
		}
	}
	return pointClusters;
};
	
/*
	Usage: Create a marker on a location with pop up content and used icon. 
	Called by: queryLayerWithPointBuffer.
	Rely on: map, openInfoWindow function.  
*/	
globalConfig.createMarker = globalConfig.createMarker || function (gLatLng, popupContent, icon) {
	var marker = new google.maps.Marker({
		position: gLatLng,
		icon: icon
	});
	(function (popupContent, marker) {
		google.maps.event.addListener(marker, 'click', function () {
			MOEMAP.openInfoWindow(marker.getPosition(), popupContent);
		});
	})(popupContent, marker);
	return marker;
};

globalConfig.infoWindowWidth = globalConfig.infoWindowWidth || '450px';
/*
	Usage: According to the features and the template, generate tab information and finally generate the tabs.  
	Called by: QUERYLAYER.queryLayer, mouseClickHandler
*/		
globalConfig.calculateMulitpleTabsOneFeature = globalConfig.calculateMulitpleTabsOneFeature || function (features, tabsTemplate){
	/*
		Usage: According to the generated tab information, generate the tabs.  
		Called by: calculateMulitpleTabsOneFeature
	*/	
	var createTabBar = function (tabs){
		// the following code based on ESRI sample
		// create and show the info-window with tabs, one for each map service layer		  
		var container = document.createElement('div');
		container.style.width = globalConfig.infoWindowWidth;
		if (globalConfig.hasOwnProperty('infoWindowHeight')){ 
			container.style.height = globalConfig.infoWindowHeight;
		}
            // =======START  TAB UI ================             
		var tabBar = new goog.ui.TabBar();
		for (var i = 0; i < tabs.length; i++) {
			var tab = new goog.ui.Tab(tabs[i].label);
			tab.content = tabs[i].content;
			tabBar.addChild(tab, true);
		}
		tabBar.render(container);
		goog.dom.appendChild(container, goog.dom.createDom('div', {
			'class': 'goog-tab-bar-clear'
		}));
		var contentDiv = goog.dom.createDom('div', {
			'class': 'goog-tab-content'
		});
		if (globalConfig.hasOwnProperty('infoWindowContentHeight')){ 
			contentDiv.style.height = globalConfig.infoWindowContentHeight;
		}
		if (globalConfig.hasOwnProperty('infoWindowContentWidth')){ 
			contentDiv.style.width = globalConfig.infoWindowContentWidth;
		}
		
		//contentDiv.style.width=globalConfig.infoWindowWidth;
		//contentDiv.style.height=globalConfig.infoWindowWidth;
		
		goog.dom.appendChild(container, contentDiv);            
		goog.events.listen(tabBar, goog.ui.Component.EventType.SELECT, function(e) {
			contentDiv.innerHTML = e.target.content;
		});
		tabBar.setSelectedTabIndex(0);
		return container;
            // =======END  TAB UI ================
	};
	
	var count = features.length;
	//Get the first returned record and generate the content for the pop up window. 
	var tabs = TABS_CALCULATOR.getContent(features[0].attributes, tabsTemplate);
	//If it is required to display more than one record, the allowMultipleIdentifyResult will be true. 
	//Then generate the contents for other records and append it to the content in tabs
	if(globalConfig.allowMultipleIdentifyResult){
		for (var i = 1; i < count; i++) {
			var calTabs = TABS_CALCULATOR.getContent(features[i].attributes, tabsTemplate);

			for (var j = 0; j < calTabs.length; j++) {
				//var tab = calTabs[j];
				tabs[j].content = tabs[j].content + calTabs[j].content;
			}
		}
	}
	/*add the head and tail to the content. The length of content is related to the total nubmer of records. 
		The head and tail parts are always fixed and have nothing to do with the total number of records. 
	*/
	for (var k = 0; k < tabs.length; k++) {
		if(typeof(tabsTemplate[k].head) !== "undefined"){
			tabs[k].content = tabsTemplate[k].head + tabs[k].content;
		}
		if(typeof(tabsTemplate[k].tail) !== "undefined"){
			tabs[k].content = tabs[k].content + tabsTemplate[k].tail;
		}			
		//tabs[k].content = tabsTemplate[k].head + tabs[k].content + tabsTemplate[k].tail;
	}
	//Add Total features returned to the top to table. 
	if((globalConfig.displayTotalIdentifyCount)&&(count > 1)){
		if(globalConfig.allowMultipleIdentifyResult){
			tabs[0].content = globalConfig.totalFeatureReturned(count) + "<br>" + tabs[0].content;
		}else{
			tabs[0].content = globalConfig.totalFeatureReturnedOnlyOneDisplayed(count) + "<br>" + tabs[0].content;
		}
	}
	//If it do not use the Predefined multiple tabs, it will not need to include some js and css file. 
	if(globalConfig.usePredefinedMultipleTabs){
		return createTabBar(tabs);
	}else{
		return tabs[0].content;		
	}
};
	
/*
	Usage: Use the circle center and radius to calculat the vertex array.
	The calculation is using the geometry library provided by Google Maps. 
	Called by: mouseMoveHandler, queryLayerWithPointBuffer
*/
globalConfig.calculateCirclePolyline = globalConfig.calculateCirclePolyline || function (gLatLng, radius){
	var circlePath = [];
	for(var heading = 0; heading<=360; heading = heading + 10){
		var latLng = google.maps.geometry.spherical.computeOffset(gLatLng, radius, heading);			
		circlePath.push(new google.maps.LatLng(latLng.lat().toFixed(5), latLng.lng().toFixed(5)));
	}
	var circle = new google.maps.Polyline({
		path: circlePath,
		strokeColor: globalConfig.pointBuffer.color,  
		strokeOpacity: globalConfig.pointBuffer.opacity,
		strokeWeight: globalConfig.pointBuffer.weight
	});
	return circle;
};

/*
	Usage: Calculate the bounds for a polyline. 
	Called by: mouseMoveHandler, queryLayerWithPointBuffer
*/
globalConfig.calculatePolylineBounds = globalConfig.calculatePolylineBounds || function (polyline){
	var bounds = new google.maps.LatLngBounds();
	var path = polyline.getPath();
	for (var i = 0; i < path.length; i++) {
		bounds.extend(path.getAt(i));
	}
	return bounds;
};

globalConfig.disallowMouseClick = globalConfig.disallowMouseClick || false;

MOEMAP = (function () {
	var map, identifyResults, identifyMarker, infoWindow, gOverlays = [], isCenterSet = false, center, bufferCircle; //, overlays = [], layers;

	/*
		Usage: If the info window is open, it will be closed. 
		Called by: mouseClickHandler, clearOverlays.
	*/
	function closeInfoWindow(){
		if(infoWindow){
			infoWindow.setMap(null);
		}		
	}	
	/*
		Usage: Remove the overlays on the map, the buffer circle, and close the infowindow. 
		Called by: mouseMoveHandler and exposed as public methods. 
	*/	
	function clearOverlays() {		
		if (gOverlays) {
			for (var i = 0; i < gOverlays.length; i++) {
				gOverlays[i].setMap(null);
			}
			gOverlays.length = 0;
		}
		if(bufferCircle){
			bufferCircle.setMap(null);
		}
		closeInfoWindow();
		if(globalConfig.usejQueryUITable){	
			document.getElementById(globalConfig.queryTableDivId).innerHTML = "";
		}
	}
	/*
		Usage: Add the polylines overlays on the map. If the LOCATOR module return the result for Township with/without 
		Lot and Concession, the related polygons will be add to Google Maps by this method. 
		Called by: queryLayerWithPointBuffer 
	*/		
	function addPolylinesToMap(polylines){
		if(typeof(polylines) !== "undefined"){
			for (var i=0; i<polylines.length; i++){
				var polygon = polylines[i];
				var max = polygon.getPaths().getLength();
				for(var j=0;j<max;j++){		
					var polyline = new google.maps.Polyline({    
						path: polygon.getPaths().getAt(j),
						strokeColor: globalConfig.twpBoundary.color,    
						strokeOpacity: globalConfig.twpBoundary.opacity,   
						strokeWeight: globalConfig.twpBoundary.weight,
						geodesic: false
					});		
					polyline.setMap(map);
					gOverlays.push(polyline);		
				}
			}
		}				
	}	
	/*
		Usage: If a user is click on the search result or the searched location, a info window will pop up. 
		Called by: mouseClickHandler,  QUERYLAYER.queryLayer, queryLayerWithPointBuffer.
	*/
	function openInfoWindow(latlng, container){
		if (!infoWindow) {
			infoWindow = new google.maps.InfoWindow({
				content: container,
				position: latlng
			});
		} else {
			infoWindow.setContent(container);
			infoWindow.setPosition(latlng);
		}
		infoWindow.open(map);		
	}

	/*
		Set up the event handler for mouse move event. This handler needs to handle two situations. The first is to update the 
		coordinates in the bottom of them map. The second is when the user is drawing the circle, try to update the circle when
		the user move the mouse. Meanwhile, it also give the event handler which will be called once the user finishs the drawing
		of the circle.
		call: globalConfig.updateCoordinates, calculateCirclePolyline, globalConfig.drawingCircleMessage
	*/				
	function mouseMoveHandler(event) {
		/*Update the Coordinates*/
		if(globalConfig.isCoordinatesVisible){
			globalConfig.updateCoordinates(event.latLng.lat(), event.latLng.lng());
		}
		/*Make sure the user is in the middle of drawing.*/
		if(isCenterSet){							
			if(typeof(event) !== "undefined"){
				//Calculate the current radius
				var distance = google.maps.geometry.spherical.computeDistanceBetween(center, event.latLng);								
				//Remove the old circle
				if(bufferCircle){
					bufferCircle.setMap(null);
				}
				bufferCircle = globalConfig.calculateCirclePolyline(center, distance);
				bufferCircle.setMap(map);
				google.maps.event.addListener(bufferCircle, 'click', finishBufferSearch);
				//update the message to give the user the current circle's centre and radius. 
				globalConfig.drawingCircleMessage(center.lat(), center.lng(), distance/1000);
			}
		}
	}	

	function addressBufferCallback (queryParams) {		
		if (queryParams.hasOwnProperty('returnedAddress')) {
			globalConfig.returnedAddress = queryParams.returnedAddress;			
		} else {
			globalConfig.returnedAddress = queryParams.address;
		}
		queryParams.map = map;
		queryParams.preQueryCallback = globalConfig.preBufferCallback;
		queryParams.postQueryCallback = globalConfig.postBufferCallback;
		queryParams.layerList = globalConfig.queryLayerList;
		clearOverlays();
		addPolylinesToMap(queryParams.polylines);  
		queryLayer2(queryParams,0);		
	}
	function finishBufferSearch (evt) {
		var distance = google.maps.geometry.spherical.computeDistanceBetween(center, evt.latLng)/1000;
		var queryParams = {
			radius: distance,
			gLatLng: center,
			map: map,
			preQueryCallback: globalConfig.preBufferCallback,
			postQueryCallback: globalConfig.postBufferCallback,
			layerList: globalConfig.queryLayerList		
		};
		//clear previous search results
		clearOverlays();
		//Query the layer							
		queryLayer2(queryParams,0);
		//restore the drawing status and the tool status to the original status. 
		isCenterSet = false;
		TOOLSLEGEND.setPointBufferTool(false);					
	}
	
	function queryLayer2(queryParams, layerId){
		if(layerId < queryParams.layerList.length) {
			queryParams.currentLayerId = layerId;
			var params = queryParams.preQueryCallback(queryParams);
			//var layerSetting = queryParams.layerList[layerId];
			var layer = new gmaps.ags.Layer(queryParams.layerList[layerId].url);
			layer.query(params, function (fset) {
				queryParams.layerList[layerId]["result"] = fset;
				queryLayer2(queryParams, layerId + 1);
			});				
		} else {
			queryParams.postQueryCallback(queryParams);
		}
		
	}
	/*
		Set up the event handler for mouse click event. This handler needs to handle two situations. If the user has selected the buffer Tool, 
		the click will be the center of the Circle and the function returns. If not, the function is going to identify the dots on the map. 
		call: TOOLSLEGEND.isPointBufferToolSelected, closeInfoWindow, calculateMulitpleTabsOneFeature, openInfoWindow
	*/					
	function mouseClickHandler(evt) {
		if(TOOLSLEGEND.isPointBufferToolSelected()){
			if(!isCenterSet){
				center = evt.latLng;
				isCenterSet = true;
			} else {
				finishBufferSearch(evt);
			}
			return;
		}		
		//identify
		closeInfoWindow();
		var queryParams = {
			gLatLng: evt.latLng,
			map: map,
			preQueryCallback: globalConfig.preIdentifyCallback,
			postQueryCallback: globalConfig.postIdentifyCallback,
			layerList: globalConfig.queryLayerList
		};
		if (globalConfig.hasOwnProperty('mergeFunction')) {
			queryParams.mergeFunction = globalConfig.mergeFunction;
		}
		queryLayer2(queryParams, 0);
	}

	/*
		Get the location firstly by using LOCATOR module. Then, use the call back function to do a spatial search with this location. 
	*/
	function identifyMultiplePolygonLayersWithLocation(qParams){
		var queryParams = {};
		if (qParams.hasOwnProperty('address')) {
			queryParams = qParams;
			queryParams.searchString = qParams.address;
		} else {
			queryParams = {
				address: qParams,
				searchString: qParams
			};		
		}
		
		if (qParams.hasOwnProperty('gLatLng')) {
			queryParams.map = map;
			globalConfig.addressGeocodingCallback(queryParams);
		} else {
			MOEMAP.geocodeAddress(queryParams);
		}
	}
	
	function showPolygonFeature (layerID, recordID) {
		var layerSetting = globalConfig.identifyMultiplePolygonLayersServicesTemplate.layerList[layerID];
		var geometryPoly = layerSetting["result"].features[recordID].geometry[0];
		geometryPoly.setMap(map);
		geometryPoly.setOptions(layerSetting.style);
		gOverlays.push(geometryPoly);			
	}
	
	function init(theMap){
		map = theMap;
		if (!globalConfig.disallowMouseClick) {
			google.maps.event.addListener(map, 'click', mouseClickHandler);
		}
		google.maps.event.addListener(map, 'mousemove', mouseMoveHandler);
		google.maps.event.addListener(map, 'zoom_changed', zoom_changedHandler);		
	}
	function zoom_changedHandler () {
		if (map.getZoom() > globalConfig.maxMapScale) {
			map.setZoom(globalConfig.maxMapScale);
		}
		if (map.getZoom() < globalConfig.minMapScale) {
			map.setZoom(globalConfig.minMapScale);
		}
	}
	function addOverlay (overlay) {
		overlay.setMap(map);	
		gOverlays.push(overlay);
	}
	function queryLayersWithConditionsExtent (queryParams) {
		queryParams.map = map;
		queryParams.preQueryCallback = globalConfig.preConditionsCallback;
		queryParams.postQueryCallback = globalConfig.postConditionsCallback;
		queryParams.layerList = globalConfig.queryLayerList;		
		queryLayer2(queryParams, 0);
	}
	function geocodeAddress (queryParams) {
		queryParams.map = map;
		queryParams.callback = globalConfig.addressGeocodingCallback;
		queryParams.address = queryParams.searchString;
		LOCATOR.locate(queryParams);
	}
	var module = {
        init: init,
		clearOverlays: clearOverlays,
		openInfoWindow: openInfoWindow,
		addOverlay: addOverlay,
		queryLayersWithConditionsExtent: queryLayersWithConditionsExtent,
		geocodeAddress: geocodeAddress,
		addPolylinesToMap: addPolylinesToMap, 
		mouseClickHandler: mouseClickHandler,
		addressBufferCallback: addressBufferCallback,
		identifyMultiplePolygonLayersWithLocation: identifyMultiplePolygonLayersWithLocation,
		showPolygonFeature: showPolygonFeature
    };
    return module;
})();


 /* Build Time: Oct 1, 2014 12:39:13 */ 